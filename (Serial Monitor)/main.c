#include "SerialComm.h"#include <stdio.h>#include <ctype.h>#include <string.h>SerialDriver	*gSd;class Euracom {	UInt16	CalcCRC(const void *iPtr, UInt16 iCount);public:	OSErr	GetCommand(StringPtr cmd);	OSErr	SendCommand(UInt8 iCmd, const void *iData = nil, SInt16 len = 0);	OSErr	InitCommand();};/*** *	Seriellen Datenstrom als ASCII ausgeben ***/static void		DebugPrint(char* header,StringPtr s,unsigned short len){static FILE	*f = nil;short	i;UInt16	cc;	if (!f) {		f = stdout;//		f = fopen("INPUT","w+");	}	fprintf(f,"%s:",header);	for(i=0; i<len; i++) {		cc = s[i];		if(!isdigit(cc)) {			fprintf(f, "<0x%2.2x>", UInt16(cc));		} else {			fprintf(f, "'%c'", cc);		}	}	fprintf(f, "\n");}/*** *	Befehl von der Euracom erwarten ***/OSErr		Euracom::GetCommand(StringPtr iBuf){	iBuf[0] = 0;					// Längenbyte löschen	do {		if(gSd->Read(iBuf, 1) != 1)	// Längenbyte lesen			return ioErr;			// Timeout!	} while(iBuf[0] == 0);			// Nullbytes ignorieren!	if(gSd->Read(iBuf + 1, iBuf[0] - 1) != iBuf[0] - 1)	// Rest des Befehls lesen		return ioErr;				// Timeout!	return noErr;}/*** *	CRC über die Nutzdaten berechnen ***/UInt16		Euracom::CalcCRC(const void *iPtr, UInt16 iCount){const UInt8		*iSPtr = (const UInt8*)(iPtr);UInt16			oCRC = 0x0000;	while(iCount-- > 0) {		if(oCRC & 1) {			oCRC >>= 1;			oCRC |= 0x8000;		} else			oCRC >>= 1;		oCRC += *iSPtr;		iSPtr++;	}	return oCRC;}/*** *	Senden an die Euracom initieren ***/OSErr		Euracom::InitCommand(){	UInt8	cmd[256];	memset(cmd, 0, sizeof(cmd));	// 256 Nullbytes senden	gSd->Write(cmd, sizeof(cmd));	return noErr;}/*** *	Befehl an die Euracom senden ***/OSErr		Euracom::SendCommand(UInt8 iCmd, const void *iData, SInt16 len){	// Befehlsbuffer allozieren	UInt8	cmd[256];	memset(cmd, 0, sizeof(cmd));	// Byte 2 = Funktionsnummer	cmd[1] = iCmd;	// theLen = |len|	UInt8	theLen = len < 0 ? -len : len;	// Daten mit übergeben?	if(iData != nil) {		if(theLen == 0) theLen = 1;				// dann eine minimale Länge von 1 annehmen!		BlockMoveData(iData, cmd + 4, theLen);	// Daten an den Befehl anhängen		if(len > 0) {							// Länge positiv? => CRC über die Daten errechnen			UInt16	theCRC = CalcCRC(iData, theLen);			cmd[2] = theCRC;					// und einsetzen			cmd[3] = theCRC >> 8;		}	}	// Byte 1 = Länge des Gesamtbefehls	cmd[0] = theLen + 4;	// zum Test: vollständigen Befehl ausgeben	DebugPrint("MAC", cmd, cmd[0]);	// Befehl senden	gSd->Write(cmd, cmd[0]);	return noErr;}/*** *	main() ***/typedef UInt8	Uchar;#include "Euracom.h"void		main(void){	SerialDriver	sd("\pModemanschluß");	gSd = &sd;	gSd->DTR(true);#if 0	Euracom		theIsdn;	theIsdn.InitCommand();	do {		theIsdn.SendCommand(K_GET_EPROM_VER);	// diese Befehle einfach nur bestätigen		Str255	theBuf;		if(theIsdn.GetCommand(theBuf) != noErr)			continue;		DebugPrint("ISDN", theBuf, theBuf[0]);	} while(!Button());#else	EinrichtKonfig	theAnlage;		// Konfiguration der Anlage einlesen	Handle		inH = GetResource('DATA', 128);	if(!inH) { DebugStr("\pEuracom Settings nicht gefunden!"); ExitToShell(); }	BlockMoveData(*inH, &theAnlage, sizeof(theAnlage));	ReleaseResource(inH);	Euracom		theIsdn;	do {		Str255	theBuf;		if(theIsdn.GetCommand(theBuf) != noErr)			continue;		DebugPrint("ISDN", theBuf, theBuf[0]);		UInt8	theAnlagenIndex = ((theBuf[1] & K_B_ANL_OFFSET) == 0x00) ? 0 : 1;		UInt8	thePort = theBuf[4];		switch(theBuf[1] & ~K_B_ANL_OFFSET) {		case K_V24_WR_EINRICHT_START:		case K_V24_RD_EINRICHT_START:		case K_V24_EINRICHT_ENDE:		case K_V24_WR_EINRICHT_START_REPEAT:		case K_V24_EINRICHT_ENDE_REPEAT:				theIsdn.SendCommand(K_WR_OK);	// diese Befehle einfach nur bestätigen				break;		case K_GET_EPROM_VER:				const StringPtr	theVersionStr = "\pEURACOM Version 1.07 Feb 13 1996\0";	// abschließendes Nullbyte nicht vergessen!				theIsdn.SendCommand(K_GET_EPROM_VER, theVersionStr + 1, theVersionStr[0]);				break;		case K_GET_EPROM_CRC:				theIsdn.SendCommand(K_GET_EPROM_CRC, "\0", -2);	// 0x0000 = kein CRC Fehler				break;		case K_CHECK_EEP:				theIsdn.SendCommand(K_CHECK_EEP, "\0", -2);		// 0x0000 = kein CRC Fehler				break;		case K_READ_S0_PORT:				theBuf[0] = theAnlage.S0[theAnlagenIndex].AnzPort;				::BlockMoveData(&theAnlage.S0[theAnlagenIndex].Port[thePort], theBuf + 1, sizeof(IsdnPort));				theIsdn.SendCommand(K_READ_S0_PORT, theBuf, 0x74);				break;		case K_READ_S0_TLN:				theIsdn.SendCommand(K_READ_S0_TLN, &theAnlage.S0[theAnlagenIndex].Port[thePort].TIn[0], sizeof(theAnlage.S0[0].Port[0].TIn));				break;		case K_READ_TLN_RUFNR_LIST:				theIsdn.SendCommand(K_READ_TLN_RUFNR_LIST, &theAnlage.RufNr[theAnlagenIndex], sizeof(RufNrZuord));				break;		case K_READ_TLN_BER_LIST:				theIsdn.SendCommand(K_READ_TLN_BER_LIST, &theAnlage.TInBer[theAnlagenIndex], sizeof(TInBerechtigung));				break;		case K_READ_TLN_RUF_VERT_LIST:				theIsdn.SendCommand(K_READ_TLN_RUF_VERT_LIST, &theAnlage.TInRufVert[theAnlagenIndex], sizeof(TInRufvert));				break;		case K_READ_ANL_DAT_LIST:				theIsdn.SendCommand(K_READ_ANL_DAT_LIST, &theAnlage.AnlDat, sizeof(GlobAnlDaten));				break;		case K_READ_ST_KON_LIST:				theIsdn.SendCommand(K_READ_ST_KON_LIST, &theAnlage.StKon[theAnlagenIndex], sizeof(SteuerKontakt));				break;		case K_READ_TLN_GEB_KONF_LIST:				theIsdn.SendCommand(K_READ_TLN_GEB_KONF_LIST, &theAnlage.TInGebKonf[theAnlagenIndex], sizeof(TInGebKonf));				break;		}	} while(!Button());#endif}