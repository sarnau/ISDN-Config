#include "portab.h"#include "DoEvent.h"#include "GlobalLib.h"#include "DialogLib.h"#include "SerialComm.h"#include "WindowsGlobal.h"#include <AppleEvents.h>void	MenuBarInit(short MenuId);		// Menüleiste initialisierenEventRecord		gTheEvent;				// globaler Event-RecordBoolean			gQuitApplication;		// true, dann Programmende////	das “Hauptprogramm”//void	main(void){	InitAll();						// Utilities, etc. init 	MenuBarInit(128);				// Menüleiste anmelden 	EventLoop();}////	Dialog-Filter, der auf Mausklick oder auf Tastendruck den Dialog verläßt//pascal Boolean	KlickDialogFilter(DialogPtr d,EventRecord *event, WORD *item);pascal Boolean	KlickDialogFilter(DialogPtr d,EventRecord *event, WORD *item){	switch(event->what) {	case mouseDown:	case keyDown:			return(true);	}	return(false);}short		gAppleId,gFileId,gEditId;	// Menü-IDs/*** *	Menüzeile einlesen ***/void	MenuBarInit(short MenuId)				// Menüleiste initialisieren{Handle		MBar;		// Handle der Menüleisteshort		anz;short		*p;MenuHandle	m;	MBar = GetResource('MBAR',MenuId);		// MBAR einlesen	if (!MBar) {		SysError(dsMBarNFnd);		ExitToShell();						// keine Menüleiste da…	}	p = (short*)*MBar;	gAppleId = p[1];	gFileId = p[2];	gEditId = p[3];	ReleaseResource(MBar);	MBar = GetNewMBar(MenuId);				// Menüzeile lesen	if (!MBar) {		SysError(dsMBarNFnd);		ExitToShell();						// keine Menüleiste da…	}	SetMenuBar(MBar);						// und setzen	DisposHandle(MBar);						// und wieder freigeben	m = GetMHandle(gAppleId);				// Handle des Apfel-Menüs	if (!m) {		SysError(dsMBarNFnd);		ExitToShell();						// keine Menüleiste da…	}	AddResMenu(m,'DRVR');					// DAs anhängen	DrawMenuBar();							// Menüzeile zeichnen}/*** *	Mehrere Menüpunkte enablen bzw. disablen. * *	Format: *	m		= MenuHandle des Menüs *	id[]	= Liste der Menüpunkte *			0	= Ende *			<0	= Menüpunkt disablen *			>0	= Menüpunkt enablen ***/void	MenuAble(short menuid,short *id);void	MenuAble(short menuid,short *id){short		i;MenuHandle	m = GetMHandle(menuid);	while(i = *id++) {					// alle Menüpunkte durch?		if (i<0)			DisableItem(m,-i);			// negativ => disablen		else			EnableItem(m,i);			// positiv => enablen	}}////	Menüpunkte en- disablen//void	AdjustMenus(void);void	AdjustMenus(void){	if (FrontWindow()) {		EnableItem(GetMHandle(gFileId),1);	// enablen	} else {		DisableItem(GetMHandle(gFileId),1);	// disablen	}	if (IsDAWindow(FrontWindow())) {	// DA ist aktiv!		static short i[] = {undoCmd,cutCmd,copyCmd,pasteCmd,clearCmd,0};		MenuAble(gEditId,i);	} else {		static short i[] = {-undoCmd,-cutCmd,-copyCmd,-pasteCmd,-clearCmd,0};		MenuAble(gEditId,i);	}	if (Count1Resources('STR#')) {			// Modems vorhanden?		EnableItem(GetMHandle(131),1);		// enablen	} else {		DisableItem(GetMHandle(131),1);		// disablen	}}/*** *	Wird nach dem Anmelden der Menüleiste, Laden der Infos, etc. aufgerufen ***/Boolean	SDCBAppendMenu(WORD index,USTR portname,USTR indriver,USTR outdriver);Boolean	SDCBAppendMenu(WORD index,USTR portname,USTR indriver,USTR outdriver){	AppendMenu(GetMenu(132),portname);	return(false);}//// Modem-Auswahl-Dialog//void	ModemSelect(void);void	ModemSelect(void){DialogPtr	d = GetCenteredDialog(128,nil);ListHandle	l;WORD		item;Str255		ModemName;	if (!d) return;			// Dialog vorhanden?	biene();	InsertMenu(GetMenu(132),-1);		// Popup-Menü laden	SDLookup(SDCBAppendMenu);			// und die Schnittstellen anfügen	l = NewList(d,4,false,true,0);	(*l)->selFlags = lOnlyOne;	// Flags für Einzelselektierung	{	Str255 s; short j;		for(j=1;j<=Count1Resources('STR#');j++) {	// alle Resourcen eines Typs			Handle h; short id; ResType type; OSErr err;			SetResLoad(false);			h = Get1IndResource('STR#',j); err = ResError();	// Resource holen			SetResLoad(true);			if (err) break;			GetResInfo(h,&id,&type,s); err = ResError();// Namen des Modems holen			if (err) break;			if(s[0])					// Name vorhanden?				SortToListMgr(s,l);		// in die Liste einsortieren		}	}	LDoDraw(TRUE,l);	NewPopup(d,8,132,7,1);				// Schnittstelle	pfeil();	ShowWindow((WindowPtr)d);	DrawDialog(d);	do {		HiliteButton(d,1,(FindSelCell(l)<0)?kCntlInactive:kCntlActive);		{		WORD	dataLen = sizeof(ModemName)-1;		Cell	c;			c.h = 0;			c.v = FindSelCell(l);			if(c.v>=0) {				// eine Zelle selektiert?				LGetCell(&ModemName[1],&dataLen,c,l);	// Modemnamen aus der Zelle holen				ModemName[0] = dataLen;	// Länge in den Pascal-String einsetzen			}		}		OutlineDialogItem(d,1);			// Rahmen von Start updaten		ModalDialog((ModalFilterProcPtr)OwnDialogFilter,&item);	} while((item != 1)&&(item != 3));	// Start oder Abbruch?	GetPopupItem(d,8,GetPopupValue(d,8),SDName);	// Schnittstelle ermitteln	DisposeObjects(d);	DisposDialog(d);	if (item == 1) {				// Start?		WORD	index,i,id;		OSErr	err;		Str255	s;		long	baud,timeout;		static	long	baudtab[] = { 38400, 19200, 9600, 4800, 2400, 1200, 300 };		static	short	baudid[] = { 2, baud19200, baud9600, baud4800, baud2400, baud1200, baud300 };		Str255	buf;		{			Handle h; ResType type;			SetResLoad(false);			h = GetNamedResource('STR#',ModemName);			SetResLoad(true);			GetResInfo(h,&id,&type,s);	// Resource-ID holen		}				d = GetCenteredDialog(129,nil);		DrawDialog(d);		biene();		err = noErr;		SDSetBrk(0);					// kein Break-Zeichen		timeout = 1000;					// 1000ms = 1s Timeout		for(index=1;index<999;index++) {// alle Strings durchgehen			GetIndString(s,id,index);			if (!s[0]) break;			// Leerstring => Ende			switch(s[1]) {			case 'B':					// Baudrate						SDClose();						s[2] = s[0] - 2;						StringToNum(&s[2],&baud);						SDInitPara = -1;						for(i=0;i<sizeof(baudtab);i++)		// Baudraten-Timerwert ermitteln							if (baudtab[i] == baud) SDInitPara = baudid[i];						if (SDInitPara < 0) SDInitPara = baud2400;	// Baudrate gültig?						SDInitPara += data8+stop10+noParity;						err = SDOpen();						// serielle Schnittstelle öffnen						if(err) {							StringHandle sH = GetString(130);							if (sH) {								HLock(sH);								SetIText(GetCH(d,3),*sH);								HUnlock(sH);							}						}						break;			case 'S':					// Senden						BlockMove(&s[3],&buf[1],s[0]-2);						buf[0] = s[0]-2;						SetIText(GetCH(d,2),buf);						err = SDWrite(&s[3],s[0]-2);	// Befehl absenden						if(!err)							err = SDWrite((USTR)"\r",1);	// CR mitsenden						if(!err) {							SDTimeout = timeout/(1000/60);	// ms in 60Hz umrechnen							SDSetBrk(10);			// Break-Zeichen: LF							do {								err = SDRead(buf+1,254);								if(err == 0) err = -1;	// 0 Bytes empfangen								if(err<0) break;		// Fehler (z.B. Timeout)								buf[0] = err;			// Stringlänge einsetzen								err = noErr;			// kein Fehler!								SetIText(GetCH(d,3),buf);							} while((buf[1] != 'O')||(buf[2] != 'K')||(buf[3] != '\r'));							SDSetBrk(0);			// kein Break-Zeichen						}						if(err == volOffLinErr) {							StringHandle sH = GetString(128);							if (sH) {								HLock(sH);								SetIText(GetCH(d,3),*sH);								HUnlock(sH);							}							err = -1;							break;						}						if(err<0) break;						break;			case 'T':					// Timeout						s[2] = s[0] - 2;						StringToNum(&s[2],&timeout);						break;			}			if (err) break;		}		if (!err) {						// kein Fehler?		StringHandle sH = GetString(129); // dann entsprechenden Text setzen			if (sH) {				HLock(sH);				SetIText(GetCH(d,3),*sH);				HUnlock(sH);			}		}		SDClose();						// Schnittstelle wieder schließen		pfeil();		do {			while(!GetEvent());			// Event holen			if ((gTheEvent.what == mouseDown)||(gTheEvent.what == keyDown)) break;			DoEvent();					// dann diesen auswerten		} while (0==0);		DisposDialog(d);	}}////	Menüpunkte en- disablen//void	DoMenuCommand(long m);void	DoMenuCommand(long m){short	title	= HiWord(m);		// Menütitelshort	item	= LoWord(m);		// Menüpunkt	if ((title == gAppleId)&&(item != 1)) {	// DA öffnen?		Str63	accName;		GetItem(GetMHandle(gAppleId),item,accName);		OpenDeskAcc(accName);			// DA öffnen	} else {		if (title == gAppleId) {		// “About” angewählt			DialogPtr	d;			d = GetCenteredDialog(130,nil);			ModalDialog((ModalFilterProcPtr)KlickDialogFilter,&item);			DisposDialog(d);		} else if (title == gFileId) {	// “Datei”-Menü			switch(item) {			case 1:		if (FrontWindow())							CloseWindow(FrontWindow());						break;			case 3:		gQuitApplication = true;						break;			}		} else if (title == gEditId) {	// Edit-Menü			SystemEdit(item-1);		} else {						// Modem-Menü			switch(item) {			case 1:	ModemSelect();					break;			case 3: {					DialogPtr	d = GetCenteredDialog(131,nil);					ModalDialog((ModalFilterProcPtr)KlickDialogFilter,&item);					DisposDialog(d);					}					break;			}		}	}	HiliteMenu(0);}/*** *	nächsten Event abholen ***/Boolean	GetEvent(void){Boolean	flag;	if (gHasWaitNextEvent)			// System 6 oder höher?		flag = WaitNextEvent(everyEvent,&gTheEvent,MAXSLEEP,nil);	else {		SystemTask();		flag = GetNextEvent(everyEvent,&gTheEvent);	}	return(flag);}/*** *	globale Event-Schleife ***/void	EventLoop(void){GrafPtr		oldGrafPtr;	GetPort(&oldGrafPtr);			// originaler GrafPort	InitAppleEvents();				// AppleEvents anmelden	{	DialogPtr	d;	WORD		item;		d = GetCenteredDialog(130,nil);		ModalDialog((ModalFilterProcPtr)KlickDialogFilter,&item);		DisposDialog(d);	}	ModemSelect();					// sofort die Dialogbox aufrufen	while (!gQuitApplication) {		if (GetEvent())				// ein Event vorhanden?			DoEvent();				// dann diesen auswerten	}}/*** *	aktuellen Event verarbeiten ***/void	DoEvent(void){WindowPtr	window;					// aktives Windowlong		m = gTheEvent.message;	// Message von gTheEvent.messagePoint		p = gTheEvent.where;	// wohin wurde geklicktshort		part;					// angeklicktes Windowelement	switch(gTheEvent.what) {	case	mouseUp:			break;	case	mouseDown:				// mit Doppelklick-Verwaltung			{ WindowPtr w;				part = FindWindow(p,(WindowPtr*)&w);				window = w;			}			switch(part) {			case	inDesk:		break;			case	inSysWindow:SystemClick(&gTheEvent,(WindowPtr)window);								break;			case	inMenuBar:	AdjustMenus();								DoMenuCommand(MenuSelect(p));								break;			case	inDrag:		DragWindow(window,p,&gDesktopRect);								break;			case	inContent:	SelectWindow(window);								break;			case	inGrow:		break;			case	inZoomIn:			case	inZoomOut:			case	inGoAway:	break;			}			break;	case	keyDown:	case	autoKey:			AdjustMenus();		// Menüs updaten			DoMenuCommand(MenuKey(m & charCodeMask));			break;	case	updateEvt:			break;	case	activateEvt:			break;	case	diskEvt:			if (HiWord(m) != noErr) {				Point	p;				SetPt(&p,kDILeft,kDITop);				DIBadMount(p,m);			}			break;	case	kHighLevelEvent:			AEProcessAppleEvent(&gTheEvent);			break;	case	kOSEvent:			switch((m>>24) & 0xFF) {			case	kMouseMovedMessage:					break;			case	kSuspendResumeMessage:					break;			}	}}/*** *	Liste der eigenen AppleEvents ***/pascal OSErr	DoAEOpenApplication(AppleEvent *message,AppleEvent *reply,long refcon);pascal OSErr	DoAEOpenDocuments(AppleEvent *message,AppleEvent *reply,long refcon);pascal OSErr	DoAEPrintDocuments(AppleEvent *message,AppleEvent *reply,long refcon);pascal OSErr	DoAEQuitApplication(AppleEvent *message,AppleEvent *reply,long refcon);static AEEventStruct aeMain[] = {	{ kCoreEventClass, kAEOpenApplication, (ProcPtr)DoAEOpenApplication },	{ kCoreEventClass, kAEOpenDocuments, (ProcPtr)DoAEOpenDocuments },	{ kCoreEventClass, kAEPrintDocuments, (ProcPtr)DoAEPrintDocuments },	{ kCoreEventClass, kAEQuitApplication, (ProcPtr)DoAEQuitApplication }};/*** *	AppleEvents anmelden ***/void	InitAppleEvents(void){short	i;OSErr	err;	if (gHasAppleEvents) {	// Apple Events vorhanden?		for(i=0 ;i<(sizeof(aeMain)/sizeof(AEEventStruct));i++) {			err = AEInstallEventHandler(aeMain[i].theEventClass,// Klasse								  aeMain[i].theEventID,		// Schlüsselwort								  aeMain[i].theHandler,		// Event-Handler								  0L,						// kein RefCon								  FALSE);					// nur unser Programm		}	}}/*** *	Applikation wird gestartet, d.h. neues leere Dokument erzeugen ***/pascal OSErr	DoAEOpenApplication(AppleEvent *message,AppleEvent *reply,long refcon){OSErr			err = noErr;	// evtl. OS-Fehlercodes	AEPutParamPtr(reply,keyReplyErr,typeShortInteger,(Ptr)&err,sizeof(short));	return(err);}/*** *	Übergebene Dokumente öffnen ***/pascal OSErr	DoAEOpenDocuments(AppleEvent *message,AppleEvent *reply,long refcon){OSErr	err = noErr;	AEPutParamPtr(reply,keyReplyErr,typeShortInteger,(Ptr)&err,sizeof(short));	return(err);}/*** *	Übergebene Dokumente drucken ***/pascal OSErr	DoAEPrintDocuments(AppleEvent *message,AppleEvent *reply,long refcon){OSErr		err = noErr;	AEPutParamPtr(reply,keyReplyErr,typeShortInteger,(Ptr)&err,sizeof(short));	return(err);}/*** *	Quit-Event, Programm beenden ***/pascal OSErr	DoAEQuitApplication(AppleEvent *message,AppleEvent *reply,long refcon){OSErr	err = noErr;	gQuitApplication = true;	AEPutParamPtr(reply,keyReplyErr,typeShortInteger,(Ptr)&err,sizeof(short));	return(err);}