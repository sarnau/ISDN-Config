//	================		Demonstration code for Drag and Drop was created by://	== CDDTask.cp ==			gdignard@hookup.net (Gilles Dignard)//	================			©1994 Gilles Dignard. All Rights Reserved#include "CDDTask.h"#include "CDDItem.h"//// LDragTask gives us general drag functionality and behaviour.  CDDTask exists so// that we can add behaviour specific to dragging cItemType items.//// The behaviour we're most interested in is being able to include a 'PICT' flavor// in our drag. Using LDragTask allows you to include only one flavor in the drag.// By subclassing LDragTask and overriding AddFlavors and MakeDragRegion, you can// (a) include as many flavors of an item as you want and (b) define your own outline// to replace the generic rectangle that LDragTask provides.//CDDTask::CDDTask (const EventRecord &inEventRecord, CDDItem* inItem)	: LDragTask(inEventRecord),	  fItem(inItem){	// public}CDDTask::~CDDTask (){	// public, virtual}voidCDDTask::AddFlavors (DragReference inDragRef){	// protected, virtual	Rect theRect;	fItem->CalcLocalFrameRect(theRect);		Int32 theWidth = theRect.right - theRect.left;	Int32 theHeight = theRect.bottom - theRect.top;		//	// Each drag can contain more than one item, and more than one representation	// for each item. In this demo, we're only dragging one item at a time, but	// we would like two representations (flavors) of that item. The first flavor will	// be the actual data structure that we will need to build a new object just like	// the current one. The second representation will be a 'PICT' representation so	// that a clipping file can be kept and viewed at the Finder level.	//	// Since the possibility exists of including more than one item, we must specify	// a unique item reference number for each of our item-specific transactions.	//	// The app doesn't support multiple item selections, so we know we only have one	// item. That makes this part pretty simple.	//	ItemReference theItemRef = 1;		//	// Add the first data flavor (the data structure) to the drag	//	ItemData theFlavorData;	fItem->FillDataStruct(theFlavorData);	::AddDragItemFlavor(inDragRef, theItemRef, cItemType,						&theFlavorData, sizeof(theFlavorData), 0L);		//	// Add the second data flavor (the PICT) to the drag	//	PicHandle thePicH = fItem->CreatePict();	::AddDragItemFlavor(inDragRef, theItemRef, 'PICT',						*thePicH, ::GetHandleSize((Handle) thePicH), 0L);	::KillPicture(thePicH);}voidCDDTask::MakeDragRegion( DragReference inDragRef, RgnHandle inDragRegion){	// protected, virtual	//	// We need to indicate to the drag manager what the outline of our	// object should be.	//	ItemReference theItemRef = 1;	//	// Parts of this code are cribbed from LDragTask::AddRectDragItem.	//	// MD+DDK pages 2-21 through 2-22 also discusses this concept and give	// another (similar) code example.	//	RgnHandle	outerRgn = ::NewRgn();	// Make region containing item	//	// First, create a region containing the 'mask' of our object. We'll	// again use the CDDItem::DoQDInstructions routine to do the QD work for us.	//	::OpenRgn();	Rect theGlobalRect;	fItem->CalcPortFrameRect(theGlobalRect);	::LocalToGlobal(&topLeft(theGlobalRect));	::LocalToGlobal(&botRight(theGlobalRect));	fItem->DoQDInstructions(theGlobalRect);	::CloseRgn(outerRgn);	//	// Take that 'mask', and turn it into an outline by making a copy,	// shrinking it my one pixel, and subtracting the shrunken copy from	// the original.	//	// That outline is then added (via the 'UnionRgn') to the outline of	// the drag as a whole.	//	RgnHandle	innerRgn = ::NewRgn();	// Carve out interior of region so	::CopyRgn(outerRgn, innerRgn);		//   that it's just a one-pixel thick	::InsetRgn(innerRgn, 1, 1);			//   outline of the item rectangle	::DiffRgn(outerRgn, innerRgn, outerRgn);	::DisposeRgn(innerRgn);											// Accumulate this item in our										//   total drag region	::UnionRgn(outerRgn, inDragRegion, inDragRegion);											// Tell Drag Manager about this item	::SetDragItemBounds(inDragRef, theItemRef, &(**outerRgn).rgnBBox);		::DisposeRgn(outerRgn);}