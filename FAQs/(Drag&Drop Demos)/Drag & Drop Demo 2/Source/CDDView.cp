//	================		Demonstration code for Drag and Drop was created by://	== CDDView.cp ==			gdignard@hookup.net (Gilles Dignard)//	================			©1994 Gilles Dignard. All Rights Reserved#include "CDDView.h"#include "CDDItem.h"#include "Drag&Drop.h"#include <LClipboard.h>#include <LStream.h>#include <PP_Messages.h>#include <UDrawingState.h>#include <UDrawingUtils.h>#ifndef __WINDOWS__#include <Windows.h>#endif#ifndef __SOUND__#include <Sound.h>#endifextern Boolean gPlayDropSound;extern Boolean gPlayEnterSound;extern Boolean gPlayExitSound;CDDView*CDDView::CreateDDViewStream(LStream* inStream){	return (new CDDView(inStream));}CDDView::CDDView(LStream* inStream)		: LView(inStream),		  LDragAndDrop(UQDGlobals::GetCurrentPort(), this){	// public	//	// put a couple of CDDItems in this view to get the ball rolling...	//	new CDDItem(this, eOval, eGray, 50, 10, 90, 90);		// top, left, bottom, right	new CDDItem(this, eRectangle, eWhite, 10, 100, 40, 130);}CDDView::~CDDView(){	// public, virtual}voidCDDView::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	switch (inCommand) {		case cmd_Paste:			outEnabled = false;			outUsesMark = false;			LClipboard* theClipboard = LClipboard::GetClipboard();			if (theClipboard)				outEnabled = (theClipboard->GetData(cItemType, nil) != 0);			break;		default:			LCommander::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName);			break;	}}BooleanCDDView::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {		case cmd_Paste:			PasteItem();			break;		default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}voidCDDView::PasteItem(){	// private	LClipboard* theClipboard = LClipboard::GetClipboard();	SignalIf_(theClipboard == nil);		Handle theDataH = ::NewHandle(0);	theClipboard->GetData(cItemType, theDataH);		CDDItem* thePastedItem = new CDDItem(this, *(ItemData*) *theDataH);	ThrowIf_(thePastedItem == nil);		SwitchTarget(thePastedItem);}voidCDDView::ClickSelf(const SMouseDownEvent& /*inMouseDown */){	// protected, virtual	if (!IsTarget()) {		SwitchTarget(this);	}}BooleanCDDView::ItemIsAcceptable(DragReference inDragRef, ItemReference inItemRef)////	ItemIsAcceptable will be called whenever the Drag Manager wants to know if//	the item the user is currently dragging contains any information that we//	can accept.////	In our case, the only thing we'll accept are cItemType items.//{	FlavorFlags		theFlags;	if (GetFlavorFlags(inDragRef, inItemRef, cItemType, &theFlags) == noErr)		return true;		return false;}voidCDDView::EnterDropArea(DragReference inDragRef, Boolean inDragHasLeftSender)//// The cursor has just entered our area.//{	// protected, virtual	// Let LDragAndDrop do its thing (hilight the area)	LDragAndDrop::EnterDropArea(inDragRef, inDragHasLeftSender);		// And we'll do ours.	PlaySound(gPlayEnterSound, rsrc_EnterSound);}voidCDDView::LeaveDropArea (DragReference inDragRef)//// The cursor has just left the building. I repeat, the cursor has left the building.//{	// protected, virtual	// Let LDragAndDrop do its thing (removes the hilighting)	LDragAndDrop::LeaveDropArea (inDragRef);		// And we'll do ours.	PlaySound(gPlayExitSound, rsrc_ExitSound);}		voidCDDView::InsideDropArea (DragReference inDragRef)//// The cursor is still in our area.//{	// protected, virtual		//	// Let LDragAndDrop do its thing - this is not really necessary, since	//		the inherited version doesn't do anything. But it's safer this	//		way because someday it might.	//	LDragAndDrop::InsideDropArea(inDragRef);		//	// And we'll do ours - we'll just read the mouse coordinates, but for this	// demo we won't do anything with them.	//	// The mouse location is where the mouse actually is on the screen. The	// alternative is the pinned location, which is _usually_ the same location,	// but can be different if the cursor is being constrained by a tracking handler.	// This is useful when you want an area within a view to be 'off-limits' to	// the ongoing drag.	//	// If we did want to do something based on where the cursor currently is in	// our area (such as indicating an insertion point or something), it would	// usually be best to use the pinned location for that work.	//	// Both mouse locations are returned in global screen coordinates	//	Point	theMouseLocation;	Point	thePinnedLocation;	::GetDragMouse(inDragRef, &theMouseLocation, &thePinnedLocation);}voidCDDView::ReceiveDragItem(	DragReference	inDragRef,	DragAttributes	/* inDragAttrs */,	ItemReference	inItemRef,	Rect			&inItemBounds)	// In Local coordinates//// The user has dropped something in this view.//{	PlaySound(gPlayDropSound, rsrc_DropSound);	::InvalRect(&inItemBounds);		//	// First, we'll figure out whether we want to copy the item(s), or only move the item(s).	//	// The rules for copying vs moving are spelled out in MD+DDK pp 19 through 21, and in	// a simplified form are: copy the item unless where it's coming from and	// where it's going to are the same window; then move it. If the option key	// was held down when the drag began, always copy it.	//	// Optional behaviour is for an application to also check the option	// key at the end of the drag. Copying then takes place if the option key was	// held down at the beginning _OR_ at the end.	//	Boolean optionKeyWasDown = CheckForOptionKey(inDragRef);	//	// Check to see if this View (the destination) is the	// same view (the source) that the object is coming from.	//	Boolean dragIsFromThisView = CheckIfViewIsAlsoSender(inDragRef);		//	// Information about the drag contents we'll be needing.	//	FlavorFlags			theFlags;		// We actually only use the flags to see if a flavor exists	Size				theDataSize;	// How much data there is for us.	ItemData		theFlavorData;	// Where we will put that data.		//	// Check to make sure the drag contains a cItemType item.	//	if (GetFlavorFlags(inDragRef, inItemRef, cItemType, &theFlags) == noErr) {		::GetFlavorDataSize(inDragRef, inItemRef, cItemType, &theDataSize);		if (theDataSize) {			ThrowIf_(theDataSize != sizeof(ItemData));	// sanity check			//			// Get the data about the rectangle we are receiving.			//			::GetFlavorData(inDragRef, inItemRef, cItemType, &theFlavorData, &theDataSize, 0L);			CDDItem* theReceivedItem;			//			// Decide whether we want to move it or to make a new copy for ourselves			//			if (dragIsFromThisView && !optionKeyWasDown) {				//				// Move the item within this window				//				// Since we know it came from this window to this window,				// the pointer must still be good. This is the _only_ time we				// can rely on the pointer field in the structure.				//				// If you come up with (or already know of) a nicer way of				// managing this, please let me know. (gdignard@hookup.net)				//				theReceivedItem = theFlavorData.vPointerToSourceObject;			} else {				//				// Make a new copy of the dragged item				//				theReceivedItem = new CDDItem(this, theFlavorData);			}			//			// Place it correctly in the view			//			// Check to see if the drag includes an HFS flavor. If it does, it means			// the flavor is coming from a clipping. This will be useful to know, since			// if the drag includes an HFS flavor, it means the user is dragging a file			// (ie in our case, a clipping). Since the user is dragging a file, the visual			// feedback they are getting is the outline of a file, not of the item. For that			// reason we'll want to drop the item centered around the current mouse position.			//			// If you want to actually see what this was designed to fix, change the !fromFinder			// in the following test to true, and drag from a clipping file to a CDDView.			//			Boolean fromFinder = (GetFlavorFlags(inDragRef, inItemRef,											flavorTypeHFS, &theFlags) == noErr);						if (!fromFinder) {				//				// Put it where the user dropped the item				//				theReceivedItem->PlaceInSuperFrameAt(inItemBounds.left, inItemBounds.top, true);			} else {				//				// It came from the Finder, place it centered around the drop point.				//				theReceivedItem->PlaceInSuperFrameAt(										inItemBounds.left - theFlavorData.vItemSize.width / 2,										inItemBounds.top - theFlavorData.vItemSize.height / 2,										true);			}						//			// If this view is on duty, make the received item the target			//			if (IsOnDuty()) {				SwitchTarget(theReceivedItem);			}		}	}}BooleanCDDView::CheckForOptionKey(DragReference inDragRef){	// private	//	// We'll check whether the option key was down at either the beginning _or_ the	// end of the drag, since (a) it's the preferred behaviour and (b) its so easy to do.	//	Int16 theModifiersNow;			// The state of the modifier keys right now	Int16 theModifiersAtMouseDown;	// The state of the modifier keys when the drag began	Int16 theModifiersAtMouseUp;	// The state of the modifier keys when the drag ended	::GetDragModifiers(inDragRef, &theModifiersNow, &theModifiersAtMouseDown, &theModifiersAtMouseUp);		return ((theModifiersAtMouseDown & optionKey) || (theModifiersAtMouseUp & optionKey));}BooleanCDDView::CheckIfViewIsAlsoSender(DragReference inDragRef){	// private	//	// Just a note: While we are using the drag attributes only at the end of the	// drag, they are also available to you during the drag.	//	// Drag Attributes are described in MD+DDK, page 2-31.	//	DragAttributes theDragAttributes;	::GetDragAttributes(inDragRef, &theDragAttributes);		return (theDragAttributes & dragInsideSenderWindow);}voidCDDView::PlaySound(Boolean inPlaySound, ResIDT inSoundID)//// Okay, so this really shouldn't be part of CDDView... Easier this way, though :)//{	// private	if (inPlaySound) {		SndListHandle myHandle = (SndListHandle) ::GetResource('snd ', inSoundID);		if (myHandle)			::SndPlay(nil, myHandle, true);	}}