//	================		Demonstration code for Drag and Drop was created by://	== CDDItem.cp ==			gdignard@hookup.net (Gilles Dignard)//	================			©1994 Gilles Dignard. All Rights Reserved#include <Aliases.h>#include <Folders.h>#include <Fonts.h>#include <Menus.h>#include <PP_Messages.h>#include <LClipboard.h>#include <LDragTask.h>#include <UDrawingState.h>#include "CDDItem.h"#include "CDDView.h"#include "CDDTask.h"#include "Drag&Drop.h"extern Boolean gUseLDragTask;CDDItem::CDDItem(	CDDView*	inParentView,					ItemShape	inShape,					ItemFill	inFill,					Int16		inTop,					Int16		inLeft,					Int16		inBottom,					Int16		inRight)	: LPane(),	  LCommander(inParentView),	  fShape(inShape),	  fFill(inFill){	ResizeFrameTo(inRight - inLeft, inBottom - inTop, false);	PutInside(inParentView);	PlaceInSuperFrameAt(inLeft, inTop, true);}CDDItem::CDDItem(CDDView* inParentView, ItemData &inItemData)	: LPane(),	  LCommander(inParentView){	SetShape(inItemData.vItemShape);	SetFill(inItemData.vItemFill);		ResizeFrameTo(inItemData.vItemSize.width, inItemData.vItemSize.height, false);	PutInside(inParentView);	PlaceInSuperFrameAt(inItemData.vLocation.h, inItemData.vLocation.v, true);}CDDItem::~CDDItem(){}voidCDDItem::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	switch (inCommand) {		//		// The Edit menu		//		case cmd_Cut:		case cmd_Copy:		case cmd_Clear:			outEnabled = true;			outUsesMark = false;			break;		//		// The item's shape		//		case cmd_Rectangle:		case cmd_Oval:			outEnabled = true;			outUsesMark = true;			outMark = (GetShape() == inCommand ? checkMark : noMark);			break;		//		// The item's fill		//		case cmd_FillWhite:		case cmd_FillLtGray:		case cmd_FillGray:		case cmd_FillDkGray:			outEnabled = true;			outUsesMark = true;			outMark = (GetFill() == inCommand ? checkMark : noMark);			break;		//		// This menu item isn't for us. Pass it along		//		default:			LCommander::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName);			break;	}}BooleanCDDItem::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {		//		// The Edit menu		//		case cmd_Cut:		case cmd_Copy:			PlaceInClipboard();			if (inCommand == cmd_Cut) {				DeleteSelf();			}			break;		case cmd_Clear:			DeleteSelf();			break;		//		// The item's shape		//		case cmd_Rectangle:		case cmd_Oval:			SetShape((ItemShape) inCommand);			break;		//		// The item's fill		//		case cmd_FillWhite:		case cmd_FillLtGray:		case cmd_FillGray:		case cmd_FillDkGray:			SetFill((ItemFill) inCommand);			break;		//		// This command isn't for us. Pass it along		//		default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}voidCDDItem::PlaceInClipboard(){	// private	//	// Find the application's clipboard	//	LClipboard* theClipboard = LClipboard::GetClipboard();	SignalIf_(theClipboard == nil);	//	// Take the information about this object and put the data into a struct	// which we will then pass to the clipboard. The last parameter in the	// SetData method indicates that we want the clipboard cleared before the	// data we're passing in is added to the clipboard.	//	ItemData theInfo;	FillDataStruct(theInfo);	theClipboard->SetData(cItemType, (Ptr) &theInfo, sizeof(theInfo), true);	//	// Add the picture of the object to the clipboard. Note that the last	// parameter to the SetData call is now false, indicating that the information	// should be added to the clipboard without clearing it first.	//	PicHandle thePicH = CreatePict();	theClipboard->SetData('PICT', (Handle) thePicH, false);	::KillPicture(thePicH);}voidCDDItem::SetShape(ItemShape inShape){	// public	fShape = inShape;	Refresh();}voidCDDItem::SetFill(ItemFill inFill){	// public	fFill = inFill;	Refresh();}voidCDDItem::DrawSelf(){	// protected, virtual	DrawWithFrame(IsTarget());}voidCDDItem::DrawWithFrame(Boolean inDrawThickFrame){	// private	Rect frame;	CalcLocalFrameRect(frame);		DoQDInstructions(frame, inDrawThickFrame);}voidCDDItem::DoQDInstructions(Rect &inFrame, Boolean inDrawThickFrame)////	This is done this way to isolate the QD calls so CDDTask (declared//	as a friend to CDDItem) can use them too when it builds a PICT flavor for//	the drag.//{	// protected, virtual	StColorPenState::Normalize();		if (inDrawThickFrame)		::PenSize(2,2);	else		::PenSize(1,1);		switch (fFill) {		case (eWhite):			::PenPat(&qd.white);			break;		case (eLtGray):			::PenPat(&qd.ltGray);			break;		case (eGray):			::PenPat(&qd.gray);			break;		case (eDkGray):			::PenPat(&qd.dkGray);			break;		default:			::PenPat(&qd.white);			break;	}		switch (fShape) {		case (eRectangle):			::PaintRect(&inFrame);			::PenPat(&qd.black);			::FrameRect(&inFrame);			break;		case (eOval):			::PaintOval(&inFrame);			::PenPat(&qd.black);			::FrameOval(&inFrame);			break;		default:			::PaintRect(&inFrame);			::PenPat(&qd.black);			::FrameRect(&inFrame);	}}voidCDDItem::ClickSelf(const SMouseDownEvent &inMouseDown){	// protected, virtual	SwitchTarget(this);		// Make this item active	//	// Track item long enough to distinguish between a click to	// select, and the beginning of a drag	//	Boolean isDrag = ::WaitMouseMoved(inMouseDown.macEvent.where);		if (isDrag) {		//		// If we leave the window, the drag manager will be changing thePort,		// so we'll make sure thePort remains properly set.		//		mSuperView->FocusDraw();		CreateDragEvent(inMouseDown);		mSuperView->OutOfFocus(nil);	}}voidCDDItem::BeTarget(){	//	// While it would be nice to simply do a Refresh() and let it go at that,	// MD&DDK says to highlight the selection _before_ the drag. We explicitly	// have to pass whether we want the highlight or not (instead of just checking	// IsTarget() because when DontBeTarget is called, a call to IsTarget() is	// still true.	//	FocusDraw();	DrawWithFrame(true);}voidCDDItem::DontBeTarget(){	//	// See notes in BeTarget	//	FocusDraw();	DrawWithFrame(false);}		voidCDDItem::CreateDragEvent(const SMouseDownEvent &inMouseDown){	// private	//	// We can create a Drag Task in one of two ways.	//	// The first is the quick and dirty way. The advantage is that you don't need	// to subclass LDragTask to drag the item. One disadvantage is that you don't	// get the opportunity to include a 'PICT' flavor in the drag. That means if	// the user double-clicks the item in the Finder he/she won't get a graphic	// depiction of the object. Another disadvantage is that we don't have the	// opportunity to define what the drag outline should look like. When we use	// LDragTask, the outline is always a rectangle.	//	// The second way is to subclass LDragTask, and have that subclass know about	// how to build a PICT of the current item to include in the drag, and also	// be able to define outlines customized to the item being dragged.	//	// You would normally choose one or the other way to go. I've done both so you	// can see how each is done. There's a menu item that allows you to switch back	// and forth between the two, so you can see the difference it makes to the user.	//	if (gUseLDragTask) {		//		// This rect is going to be used by the Drag Task to draw the		// outline as the user drags the item around. LDragTask converts		// this rect into a region, which is then passed to the drag manager		// so it knows what the drag outline should look like.		//		Rect theRect;		CalcLocalFrameRect(theRect);		//		// Build a structure to contain the data we'll be passing to the drag event.		//		ItemData theFlavorData;		FillDataStruct(theFlavorData);		//		// Begin the drag task		//		LDragTask theDragTask(	inMouseDown.macEvent, theRect, 1, cItemType,								&theFlavorData, sizeof(theFlavorData), 0L);		//		// If the drag is to the trash, it should be a move, not a copy		//		CheckForTrash(&theDragTask);	} else {		//		// Create a new drag task		//		CDDTask theDragTask (inMouseDown.macEvent, this);		//		// Start it rolling. The task's DoDrag method will first issue itself AddFlavors		// and MakeDragRegion messages before beginning the drag. By overriding these two		// methods in our LDragTask subclass, we get to build custom drag information		// before the drag begins.		//		theDragTask.DoDrag();		//		// If the drag is to the trash, it should be a move, not a copy		//		CheckForTrash(&theDragTask);	}}voidCDDItem::CheckForTrash(LDragTask* inDragTask)//// This method exists because CreateDragEvent gives you the option of// using LDragTask or CDDTask to perform the drag, and this code// is common to both of them.//{	// private	//	// An exception to the copy vs move option is if the user drags	// the item to the trash. Then it should be _moved_, not copied.	//	// If we run into any error messages along the way, we'll abort	// the test. We can't lose any data this way; only _not_ making	// a deletion that really should be made.	//	OSErr	theErr;	AEDesc	theDropDestination;		DragReference theDragRef = inDragTask->GetDragReference();	theErr = ::GetDropLocation(theDragRef, &theDropDestination);		if ((theErr) || (theDropDestination.descriptorType == typeNull))		return;		if (theDropDestination.descriptorType == typeAlias) {		//		// The drag was to the finder. The question now is whether it		// was to the trash.		//		Boolean	aliasWasChanged;		FSSpec	theDestinationFSSpec;		FSSpec	theTrashFSSpec;		short	theTrashVRefNum;		long	theTrashDirID;		//		// First, build the FSSpec of the destination to which the user dragged		// the object		//		HLock(theDropDestination.dataHandle);		theErr = ::ResolveAlias(	nil,									(AliasHandle) theDropDestination.dataHandle,									&theDestinationFSSpec,									&aliasWasChanged);		HUnlock(theDropDestination.dataHandle);		if (theErr)			return;				//		// Next, find the FSSpec of the system's trash		//		theErr = ::FindFolder(	kOnSystemDisk, kTrashFolderType, kDontCreateFolder,								&theTrashVRefNum, &theTrashDirID);		if (theErr)			return;				theErr = ::FSMakeFSSpec( theTrashVRefNum, theTrashDirID, nil, &theTrashFSSpec);		if (theErr)			return;				//		// Compare the two FSSpecs.		//		if ((			theDestinationFSSpec.vRefNum ==	theTrashFSSpec.vRefNum)		&& (			theDestinationFSSpec.parID	 ==	theTrashFSSpec.parID)		&& (EqualString(theDestinationFSSpec.name,		theTrashFSSpec.name, false, true))) {			//			// Since the FSSpec of the destination of the drag is the same as the FSSpec of			// the trash, the drag was to the trash.			//			// We get to this point _after_ the clipping file has been placed in the trash			// so to complete the 'move', we simply delete this item.			//			DeleteSelf();		}	}}#define _72dpi 0x00480000PicHandleCDDItem::CreatePict()//// Create a handle to a pict containing a graphic representation of the item.//// The calling procedure is responsible for issuing the KillPicture(PicHandle)// needed to clean up after we're done with it.//{	// public	RgnHandle theCurrentClipRgn = ::NewRgn();	::GetClip(theCurrentClipRgn);				// Save the current clip region		Rect			thePICTRect		= {0, 0, mFrameSize.height, mFrameSize.width};	OpenCPicParams	myOpenParams	= { {0,0,mFrameSize.height,mFrameSize.width},										_72dpi, _72dpi, -2, 0, 0};	PicHandle		thePicH			= ::OpenCPicture(&myOpenParams);		::ClipRect(&thePICTRect);	DoQDInstructions(thePICTRect);	::ClosePicture();		::SetClip(theCurrentClipRgn);				// Restore the clip region	return thePicH;}voidCDDItem::FillDataStruct(ItemData &inDataStruct)//// Fill the data structure to contain the information necessary// to make another CDDItem just like this one.//{	// public	inDataStruct.vLocation				= mFrameLocation;		// SPoint32	inDataStruct.vItemSize				= mFrameSize;			// SDimension16	inDataStruct.vItemShape				= GetShape();			// ItemShape	inDataStruct.vItemFill				= GetFill();			// ItemFill	inDataStruct.vPointerToSourceObject	= this;					// CDDItem*}voidCDDItem::DeleteSelf(){	// private	Refresh();	delete this;}