/*** *	Library für die serielle Schnittstelle ***/#define SERDEBUG		0#include "SerialComm.h"#if SERDEBUG#include <stdio.h>#endif#include <CommResources.h>#include <CRMSerialDevices.h>/*** *	alle seriellen Ports ermitteln ***/void	SerialDriver::Lookup(){CRMRecPtr		theCRM;CRMRec			theCRMRec;CRMSerialPtr	theSerial;short			old,index;Boolean			flag;char			index1,index2,index3;	old = 0;							// ID des Ports	index = 1;							// Index des Ports	while(1) {		theCRMRec.crmDeviceType = crmSerialDevice;		theCRMRec.crmDeviceID = old;		theCRM = &theCRMRec;		theCRM = CRMSearch((CRMRecPtr)theCRM); // Port suchen		if(!theCRM) 			break;						// keinen weiteren Port gefunden => raus		theSerial = (CRMSerialPtr)(theCRM->crmAttributes);		index1 = HGetState((Handle)theSerial->name);		index2 = HGetState((Handle)theSerial->inputDriverName);		index3 = HGetState((Handle)theSerial->outputDriverName);		HLock((Handle)theSerial->name);		HLock((Handle)theSerial->inputDriverName);		HLock((Handle)theSerial->outputDriverName);		flag = CBOpen(index,*(theSerial->name),*(theSerial->inputDriverName),						*(theSerial->outputDriverName));		HSetState((Handle)theSerial->name,index1);		HSetState((Handle)theSerial->inputDriverName,index2);		HSetState((Handle)theSerial->outputDriverName,index3);		if(flag) break;					// Treiber gefunden => raus		old = theCRM->crmDeviceID;		// der nächste Port		index++;	}}Boolean	SerialDriver::CBOpen(short index,StringPtr portname,StringPtr indriver,StringPtr outdriver){OSErr	err;	if(!EqualString(portname,SDName,false,true))		return false;					// Port gefunden?	err = OpenDriver(indriver,&SDIn);	if(err) {		SDIn = 0;						// Ports löschen		SDCBOpenErr = err;		return true;					// Fehler beim Öffnen => Abbruch	}	err = OpenDriver(outdriver,&SDOut);	if(err) {		CloseDriver(SDIn);				// Eingangstreiber schließen		SDIn = SDOut = 0;				// Ports löschen		SDCBOpenErr = err;		return true;					// Fehler beim Öffnen => Abbruch	}	SDPort = index;						// aktiver Port	SDCBOpenErr = noErr;	return true;}/*** *	seriellen Port wieder abmelden ***/void	SerialDriver::Close(void){OSErr	err = noErr;	if(SDInBuf) {			// seriellen Buffer freigeben		SerSetBuf(SDIn,nil,(short)nil);		DisposePtr((Ptr)SDInBuf);		SDInBuf = nil;	}	if(SDIn) {				// seriellen Port schließen		err = CloseDriver(SDIn);		SDIn = 0;	}	if(SDOut) {		if (err)			CloseDriver(SDOut);		else			err = CloseDriver(SDOut);		SDOut = 0;	}	SDPort = 0;	if(err) throw err;}/*** *	seriellen Port mit 9600 Baud 8N1 XON/XOFF anmelden ***/void	SerialDriver::Open(){SerShk		s;OSErr		err;	if(SDPort > 0) Close();	Lookup();							// Treiber suchen und öffnen	if(SDCBOpenErr) throw SDCBOpenErr;	// kein Treiber gefunden!	SDTimeout = 60;						// Timeout = 1s	err = SerReset(SDOut,SDInitPara);	if(err) {		Close();		throw err;	}	err = SerReset(SDIn,SDInitPara);	if(err) {		Close();		throw err;	}	s.fXOn = true;	// XOn flow control enabled flag	s.fCTS = false;	// CTS flow control enabled flag	s.xOn = XOn;	// XOn character	s.xOff = XOff;	// XOff character	s.errs = parityErr + hwOverrunErr + framingErr;	// errors mask bits	s.evts = 0;		// event enable mask bits	s.fInX = false;	// Input flow control enabled flag	s.fDTR = false;	// DTR input flow control flag#if 1	err = SerHShake(SDOut,&s);	if(err) {		Close();		throw err;	}#endif#if 0	CntrlParam	pb;	pb.ioCRefNum = SDOut;	pb.csCode = serdHShakeDTR;	BlockMoveData(&s, pb.csParam, sizeof(s));	err = PBControlSync((ParmBlkPtr)&pb);	if(err) {		Close();		throw err;	}#endif//	SDInBuf = nil;	SDInBuf = (StringPtr)NewPtr(8192);	if(SDInBuf)			// größeren Buffer für den Eingang		SerSetBuf(SDIn,(Ptr)SDInBuf,8192);}/*** *	DTR-Flag setzen oder löschen ***/void	SerialDriver::DTR(Boolean flag){	CntrlParam	pb;	pb.ioCRefNum = SDOut;	pb.csCode = flag ? kSERDAssertDTR : kSERDNegateDTR;	PBControlSync((ParmBlkPtr)&pb);}/*** *	String der Länge “len” im Stdio-Window mit Steuerzeichen ausgeben ***/#if SERDEBUGvoid		SerialDriver::DebugPrint(char* header,StringPtr s,unsigned short len){short	i;unsigned char	cc;static unsigned char tab[] = {		"NULSOHSTXETXEOTENQACKBELBS TABLF VT FF CR SO SI "		"DLEDC1DC2DC3DC4NAKSYNETBCANEM SUBESCFS GS RS US " };static FILE	*f = nil;	if (!f) {		f = stdout;//		f = fopen("INPUT","w+");	}	fprintf(f,"%s[%c]:",header, SDName[1]);	for(i=0;i<len;i++) {		cc = s[i];		if(cc == 32) cc = '…';		if(cc < 32) {			cc *= 3;			if (tab[cc+2] == ' ')				fprintf(f,"<%c%c:$%2.2x>",tab[cc],tab[cc+1],s[i]);			else				fprintf(f,"<%c%c%c:$%2.2x>",tab[cc],tab[cc+1],tab[cc+2],s[i]);		} else if(cc >= 0x80) {			fprintf(f,"<$%2.2x>",cc);		} else {			short j = i; unsigned char temp;			while(s[i]>=32 && s[i]<0x80 && i<len) {				if(s[i] == 32) s[i] = '…';				i++;			}			temp = s[i]; s[i] = 0;			fprintf(f,"%s",&s[j]);			s[i--] = temp;		}	}	fprintf(f,"\n");}#endif/*** *	auf Bytes an der Seriellen warten ***/OSErr	SerialDriver::Wait(unsigned short timeout,long *count){OSErr			err;unsigned long	time = (unsigned long)TickCount() + timeout;Boolean			flag = false;	while(true) {		err = SerGetBuf(SDIn,(long*)count);	// Bytes im In-Buffer abfragen		if(err) return err;					// OS-Error		if(*count > 0) return noErr;		// es sind Bytes da		if(time < (unsigned long)TickCount()) flag = true;	// Timeout?		if(flag) return 1;					// Timeout	}}/*** *	einen String über die serielle Schnittstelle senden ***/void	SerialDriver::Write(StringPtr s,unsigned short count){OSErr	err;long	c = count;#if SERDEBUG	DebugPrint("MAC",s,count);#endif	err = FSWrite(SDOut,&c,s);			// String senden	if(count != c && err == noErr)		throw ioErr;					// Bytes nicht gesendet}/*** *	count Bytes über die serielle Schnittstelle einlesen ***/short	SerialDriver::Read(StringPtr buf,unsigned short maxbytes){OSErr		err;		// Fehlercode, der letzten Operationlong		count;		// Anzahl der vorhandenen/gelesenen Bytes#if SERDEBUGStringPtr	bufstart = buf;	// Anfangsadresse vom Empfangsbuffer#endifshort		sum = 0;	do {		err = Wait(SDTimeout,&count);	// 1s Timeout		if(err || !count) break;		// Abbruch, wenn Fehler, oder alles gelesen		count = 1;		err = FSRead(SDIn,&count,buf);	// ein Byte aus dem Buffer einlesen		if(err) break;					// Abbruch, wenn Fehler		sum++;		buf++;							// zum nächsten Zeichen	} while(sum < maxbytes);			// alle Bytes gelesen?#if SERDEBUG	DebugPrint("ISDN",bufstart,sum);#endif	return sum;							// Anzahl der gelesenen Bytes}