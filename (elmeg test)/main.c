#include "SerialComm.h"#include <stdio.h>#include <ctype.h>#include <string.h>SerialDriver	*gSd;/*** *	Seriellen Datenstrom als ASCII ausgeben ***/static void		DebugPrint(char* header,StringPtr s,unsigned short len){static FILE	*f = nil;short	i;UInt16	cc;	if (!f) {		f = stdout;//		f = fopen("INPUT","w+");	}	fprintf(f,"%s:",header);	for(i=0; i<len; i++) {		cc = s[i];		if(!isdigit(cc)) {			fprintf(f, "<0x%2.2x>", UInt16(cc));		} else {			fprintf(f, "'%c'", cc);		}	}	fprintf(f, "\n");}/*** *	Elmeg-I/O-Klasse ***/#include "EITYPESH.H"#include "GLTYPESH.H"#define SOH		0x01#define STX		0x02#define ETX 	0x03#define EOT 	0x04#define ENQ 	0x05#define ACK 	0x06#define NAK 	0x15#define CAN 	0x18#define CRC 	'C'#define ESC 	0x1Bclass Elmeg {	UInt16	CalcCRC(const UInt8 *ptr, UInt16 nCount);public:	OSErr	TransmitBlock(const UInt8 *iBlockPtr, UInt16 iBlockSize);	OSErr	ReceiveBlock(UInt8 *oBlockPtr, UInt16 &ioBlockSize);};/*** *	CRC Ÿber die Nutzdaten berechnen ***/UInt16		Elmeg::CalcCRC(const UInt8 *ptr, UInt16 nCount){	UInt16	crc = 0;	while (nCount--) {		crc ^= *ptr++ << 8;		for(int i = 0; i <= 7; i++)			if(crc & 0x8000)				crc = (crc << 1) ^ 0x1021;			else				crc <<= 1;	}	return crc;}/*** *	Block an die Elmeg senden ***/OSErr		Elmeg::TransmitBlock(const UInt8 *iBlockPtr, UInt16 iBlockSize){	// Checksumme berechnen...	UInt16	theCheckSum = CalcCRC(iBlockPtr, iBlockSize);	UInt8	theCmdBuf[8192];	UInt8	*theCmdPtr = theCmdBuf;	// Start der †bertragung, bzw. des Blockes...	*theCmdPtr++ = STX;		for(; iBlockSize; iBlockSize--) {		switch(*iBlockPtr) {		case STX:		case ETX:		case ESC:	// Falls das zu sendende byte einem Steuerzeichen entspricht, ein ESCAPE vorsenden...				*theCmdPtr++ = ESC;		default:*theCmdPtr++ = *iBlockPtr++;				break;		}    }	// Ende der Nutzdaten	*theCmdPtr++ = ETX;	// Checksumme Ÿbertragen	*theCmdPtr++ = theCheckSum >> 8;	*theCmdPtr++ = theCheckSum;	// Ende der †bertragung	*theCmdPtr++ = EOT;	// Daten Ÿber die RS232 schicken	gSd->Write(theCmdBuf, theCmdPtr - theCmdBuf);	// Warte auf antwort; falls keine kommt, dann NAK als Default...	UInt8	bResp;	if(gSd->Read(&bResp, 1) == 0)		return ioErr;	if(bResp != ACK)		return ioErr;	return noErr;}/*** *	Block von der Elmeg erwarten ***/OSErr		Elmeg::ReceiveBlock(UInt8 *oBlockPtr, UInt16 &ioBlockSize){	UInt16	theMaxBlockSize = ioBlockSize;	ioBlockSize = 0;	UInt8	theByte;	do {		if(gSd->Read(&theByte, 1) != 1)			return ioErr;				// Timeout!	} while(theByte != STX);	UInt8	*theBuf = oBlockPtr;	int		theCount = 0;	while(1) {		if(gSd->Read(&theByte, 1) != 1)			return ioErr;			// Timeout!		if(theByte == ETX)			break;		if(theByte == ESC)			// ESC Ÿberlesen			if(gSd->Read(&theByte, 1) != 1)				return ioErr;		// Timeout!		theCount++;		if(theCount > theMaxBlockSize)	// BufferŸberlauf?			return memFullErr;		*theBuf++ = theByte;	}	// PrŸfsumme Ÿber die empfangenen Daten errechnen	UInt16	theCRC = CalcCRC(oBlockPtr, theCount);	UInt8	theCRCHigh;	if(gSd->Read(&theCRCHigh, 1) != 1)		return ioErr;				// Timeout!	UInt8	theCRCLow;	if(gSd->Read(&theCRCLow, 1) != 1)		return ioErr;				// Timeout!	if(gSd->Read(&theByte, 1) != 1)		return ioErr;				// Timeout!	if(UInt8(theCRC >> 8) != theCRCHigh && UInt8(theCRC) != theCRCLow) {		theByte = NAK;		gSd->Write(&theByte, 1);	// Fehler		return ioErr;	}	if(theByte != EOT)		return ioErr;	// alles ok!	theByte = ACK;	gSd->Write(&theByte, 1);	ioBlockSize = theCount;	return noErr;}/*** *	main() ***/void		main(){	SerialDriver	sd("\pModemanschlu§");	gSd = &sd;	gSd->DTR(false);	Elmeg		theIsdn;//	gSd->SetTimeout(120);	do {		UInt8	theBuf[4096];		memset(theBuf, 0, sizeof(theBuf));	    theBuf[0] = ComTask;#if 1//	    theBuf[1] = eEvEinrConfVersionReq;	    theBuf[1] = eEvEinrConfDataReq;//		DebugPrint("MAC", theBuf, 2);	    if(theIsdn.TransmitBlock(theBuf, 2) != noErr)			continue;		UInt16	theCount = sizeof(theBuf);	    if(theIsdn.ReceiveBlock(theBuf, theCount) != noErr)    	    continue;		FILE	*f = fopen("ELMEG.DAT", "wb");		fwrite(theBuf + 2, sizeof(char), theCount - 2, f);		fclose(f);#else	    theBuf[1] = eEvEinrConfData;		theBuf[4] = 3;		FILE	*f = fopen("ELMEG.DAT", "rb");		fread(theBuf + 2, sizeof(char), 918, f);		fclose(f);	    if(theIsdn.TransmitBlock(theBuf, 2 + 918) != noErr)			continue;		UInt16	theCount = sizeof(theBuf);	    if(theIsdn.ReceiveBlock(theBuf, theCount) != noErr)    	    continue;#endif//		DebugPrint("ISDN", theBuf, theCount);#if 0	    if(theBuf[0] == ComTask) {	        switch(theBuf[1]) {			case eEvEinrConfVersion:				//m_eumex_version = (char*) &theBuf[2];				break;			}		}#endif		break;	} while(!Button());}