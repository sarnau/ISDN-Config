#include "SerialComm.h"#include <stdio.h>#include <ctype.h>#include <string.h>SerialDriver	*gSd;#pragma align_array_members offtypedef struct {	char	Anschlussart;	// Anschlussart: 0=Mehrgeraete-,1=Anlagenanschluss	char	Anz_abSchnittstellen;	// Anzahl der a/b-Schnittstellen	char	Protokoll;		// Protokoll: 0=1TR6, 1=E-DSS1	char	SWVersionHigh;	// Software Versionsnummer	char	SWVersionLow;	char	TFEZuordnung;	// TFE-Zuordnung (0x15=21,0x16=22,...)	char	MSN[10][5];		// max. 10 MSNs (E-DSS1)	char	MusicOnHold;	// Music on Hold (00=aus,01=ein)	char	Anz_intS0Bus;	// Anzahl der internen S0-Busse	char	Anz_extS0Bus;	// Anzahl der externen S0-Busse	char	Abfragestelle1;	// Abfragestelle1 (0x15=21,0x16=22,...)	char	Abfragestelle2;	// Abfragestelle2 (0x15=21,0x16=22,...)	char	SizeNumber1;	char	Number1[10];	// max. 2 Telefonnummern (1TR6)	char	SizeNumber2;	char	Number2[10];	char	MSNGroup[10];	// MSN Gruppenbildung: Fuer jede der 10 MSN'sein Byte,							// in dem die einzelnen Bits angeben, 							// welche der 8 Nebenstellen klingeln sollen.	char	MessageOnHold;	// Musik über ein Telefon extern einspeisen (Apparat-Nummer)	char	NationalCode[2];// internationale Vorwahl (0x0031 = 49 für Deutschland, Intel-Format!)	char	TFELocation[4];	// 	char	AlarmTon;		// (momentan keine Bedeutung)	char	SonderRuf[10];	// (0..3) für jede MSN	char	reserved[5];	// für die Zukunft} GrundKonfigStruct;		// 93/106/116 Bytes langtypedef struct {	char	Wahlbewertung;	// Wahlbewertung: 00=keine,01=Inland,...	char	Dienst;			// Dienst: 00=Telefonie,01=G3-FAX,...	char	Rufumleitung;	// Rufumleitung: 00=keine,01=extern,0x15=Nebenstelle 21,0x16=Nebenstelle 22,usw.	char	Gebuehrenimpuls;// Gebuehrenimpuls: 00=nein,01=ja	char	PIN[2];			// PIN (BCD)	char	UmlRufnummer[10];	// Rufnummer fuer externe Rufumleitung (BCD mit $F aufgefüllt)	char	TerminalMode;	// 0x01 = spontane Amtsholung, 0x00 = aus	char	AnklopfenApp;	// Ein Bit pro Sprechstelle: 1 = Anklopfen erlaubt	short	AnklopfenMSN;	// Ein Bit pro MSN: Anklopfen von MSN x erlaubt	char	ZiffLenUml;		// Zusatzinfo über Ziffernlänge der ext. Rufumleitung	char	UmlBesetzt;		// Umleitungsziel bei Besetzt (0 = keine)	char	UmlAnzRufseq;	// Umleitungsziel nach Anzahl Rufsequenzen (0 = keine)	char	AnzRufseq;		// Anzahl Rufe bis Umleitung aktiviert wird} EndgeraetekonfigStruct;	// 16/20/24 Bytes lang#pragma align_array_members reset/*** *	Seriellen Datenstrom als ASCII ausgeben ***/static void		DebugPrint(char* header,StringPtr s,unsigned short len){static FILE	*f = nil;short	i;UInt16	cc;	if (!f) {		f = stdout;//		f = fopen("INPUT","w+");	}	fprintf(f,"%s<%d>:",header, len);	for(i=0; i<len; i++) {		cc = s[i];		if(!isdigit(cc)) {			fprintf(f, "<0x%2.2x>", UInt16(cc));		} else {			fprintf(f, "'%c'", cc);		}	}	fprintf(f, "\n");}class CISTEC {public:	void		GetCommand(StringPtr cmd, short &len, short maxLen, unsigned short timeout);	void		SendCommand(StringPtr cmd, short len);};/*** *	Befehl von der Istec erwarten ***/void		CISTEC::GetCommand(StringPtr cmd, short &len, short maxLen, unsigned short timeout){unsigned long	time = (unsigned long)TickCount() + timeout;	len = 0;		// bisher: 0 Bytes gelesen	do {		unsigned char	buf[4];		int				i = 1;		buf[0] = 0;					// Längenbyte löschen		if(gSd->Read(buf, 4) == 4) {	// immer 4 Byte-Blöcke lesen			// Timeout bei erhaltenem Block verlängern!			time = (unsigned long)TickCount() + timeout;			//printf("«$%2.2x,$%2.2x,$%2.2x,$%2.2x»\n", buf[0], buf[1], buf[2], buf[3]);			for(int j = buf[0] & 0x03; j>0; j--) {	// Länge auswerten				if(maxLen <= len) throw memFullErr;				cmd[len++] = buf[i++];			}			if(buf[0] & 0x80) break;	// letzter Block? => raus		}		if(time < (unsigned long)TickCount()) {			DebugPrint("ISDN", cmd, len);			throw ioErr;	// Timeout!		}	} while(1);	DebugPrint("ISDN", cmd, len);}/*** *	Befehl an die Istec senden ***/void		CISTEC::SendCommand(StringPtr cmd, short len){	DebugPrint("MAC", cmd, len);	while(len > 0) {		unsigned char	buf[4];		buf[0] = len <= 3 ? len : 3;		buf[1] = buf[2] = buf[3] = 0x00;		if(--len >= 0) buf[1] = *cmd++;		if(--len >= 0) buf[2] = *cmd++;		if(--len >= 0) buf[3] = *cmd++;		if(len <= 0) buf[0] |= 0x80;		// Befehlsblock in 1 Byte Länge + 3 Bytes Päckchen übertragen		gSd->Write(buf, 4);		//printf("«$%2.2x,$%2.2x,$%2.2x,$%2.2x»\n", buf[0], buf[1], buf[2], buf[3]);		UInt32	time;		Delay(3, &time);	// min. 40ms Pause	}	UInt32	time;	Delay(4, &time);		// nochmals min. 60ms Pause}/*** *	main() ***/void		main(){	SerialDriver	sd("\pPrinter Port");	gSd = &sd;	gSd->DTR(true);	CISTEC					theIsdn;	GrundKonfigStruct		gks;	EndgeraetekonfigStruct	eks[64];#if 1//	do {		short	theCount;		Str255	theBuf;		Str255	theSendBuf;		theSendBuf[0] = 0x02;		theSendBuf[1] = 0x02;		theSendBuf[2] = 0x00;		theIsdn.SendCommand(theSendBuf, 3);		theCount = sizeof(theBuf);		theIsdn.GetCommand(theBuf, theCount, sizeof(theBuf), 60*2);#if 0		theSendBuf[0] = 0xcc;		theSendBuf[1] = 0x05;		theSendBuf[2] = 0x07;		theSendBuf[3] = 0x00;		theSendBuf[4] = 0xff;		theIsdn.SendCommand(theSendBuf, 5);		theCount = sizeof(theBuf);		theIsdn.GetCommand(theBuf, theCount, sizeof(theBuf), 60*2);		theSendBuf[0] = 0x0a;		theIsdn.SendCommand(theSendBuf, 1);		theCount = sizeof(theBuf);		theIsdn.GetCommand(theBuf, theCount, sizeof(theBuf), 60*2);#endif		for(int i=0; i<3; i++) {			theSendBuf[0] = 0x08;			theSendBuf[1] = i;			theIsdn.SendCommand(theSendBuf, 2);			theCount = sizeof(theBuf);			theIsdn.GetCommand(theBuf, theCount, sizeof(theBuf), 60*2);		}//	} while(!Button());#elseagain:	try {	do {		Str255	theBuf;		Str255	theSendBuf;		short	theCount = sizeof(theBuf);		memset(theBuf, 0xff, theCount);		theIsdn.GetCommand(theBuf, theCount, sizeof(theBuf), 60*2);		if(!theCount) continue;		switch(theBuf[0]) {		case 0x02:	if(theCount > 1) puts("Bereitschaft 2.0");					else puts("Bereitschaft 1.0");					theSendBuf[0] = 0x12;					theIsdn.SendCommand(theSendBuf, 1);					break;		case 0x06:	puts("Gebührenzähler lesen");					theSendBuf[0] = 0x15;					memset(theSendBuf + 1, 0, 64 * 2);					theIsdn.SendCommand(theSendBuf, 8 * 2 + 1);					break;		case 0x07:	printf("Endgerät %d schreiben\n", theBuf[1]);					BlockMoveData(theBuf + 2, &eks[theBuf[1]], sizeof(eks[0]));					theSendBuf[0] = 0x18;					theSendBuf[1] = theBuf[1];					theIsdn.SendCommand(theSendBuf, 2);					break;		case 0x08:	puts("Endgeräte abfragen");					for(int i=0; i<8; i++) {						theSendBuf[0] = 0x16;						theSendBuf[1] = i;						BlockMoveData(&eks[theBuf[1]], theSendBuf + 2, sizeof(eks[0]));						theIsdn.SendCommand(theSendBuf, 2 + sizeof(eks[0]));					}					break;		case 0x09:	puts("Grundkonfiguration schreiben");					BlockMoveData(theBuf + 1, &gks, sizeof(gks));					break;		case 0x0a:	puts("Grundkonfiguration lesen");					theSendBuf[0] = 0x17;					BlockMoveData(&gks, theSendBuf + 1, sizeof(gks));					theIsdn.SendCommand(theSendBuf, 117);					break;		case 0x0b:	puts("RESET!");					break;		case 0x0c:	puts("Write EEPROM");					break;#define CTI_START				0xcc#define CTI_CONF				0x05#define CTI_QUERY				0x06#define CTI_ERROR				0x07#define CTI_ACK					0x08#define CTI_STOP				0xff#define CTI_LOAD_NUMBER			0x03#define CTI_ALARM				0x05#define CTI_DAY_NIGHT			0x07#define CTI_STORE_NUMBER		0x09#define CTI_ERROR_				0x00#define CTI_INVALID_NUMBER		0x01#define CTI_INVALID_SP_STELLE	0x02#define CTI_INVALID_CHANNEL		0x03#define CTI_INVALID_DAY_NIGHT	0x04#define CTI_EEPROM_IN_USE		0x05#define CTI_DAY_NIGHT_CHANGED	0x06#define CTI_DEFAULT_VALUES		0x07#define CTI_DAY_NIGHT_SAME		0x08		case CTI_START:					printf("CTI_START : ");					int	i = 1;					while(i < theCount) {						if(Button()) break;						Boolean	send = false;						int	j = 0;						theSendBuf[j++] = CTI_START;						theSendBuf[j++] = CTI_ACK;						theSendBuf[j++] = theBuf[i+1];						switch(theBuf[i++]) {						case CTI_CONF:									printf("CTI_CONF : ");									switch(theBuf[i++]) {									case CTI_ALARM:												printf("CTI_ALARM(%d)", theBuf[i++]);												theSendBuf[j++] = 0x00;												send = true;												break;									case CTI_DAY_NIGHT:												printf("CTI_DAY_NIGHT(%d)", theBuf[i++]);												theSendBuf[j++] = CTI_DAY_NIGHT_SAME;												send = true;												break;									case CTI_STORE_NUMBER:												printf("CTI_STORE_NUMBER %d", theBuf[i]);												theSendBuf[j - 1] = 0x03;												i += 2 + ((theBuf[i+1] + 1) >> 1) + 4;												send = true;												break;									}									break;						case CTI_QUERY:										printf("CTI_QUERY : ");									switch(theBuf[i++]) {									case CTI_LOAD_NUMBER:												printf("CTI_LOAD_NUMBER");												theSendBuf[j - 1] = CTI_CONF;												theSendBuf[j++] = CTI_LOAD_NUMBER;												theSendBuf[j++] = theBuf[i++];												theSendBuf[j++] = 10;												for(int k=0; k<10; k++)													theSendBuf[j++] = 0x12;												theSendBuf[j++] = 0x00;												theSendBuf[j++] = 0x00;												theSendBuf[j++] = 0x00;												send = true;												break;									case CTI_ALARM:												printf("CTI_ALARM");												theSendBuf[j++] = 0x00;												send = true;												break;									case CTI_DAY_NIGHT:												printf("CTI_DAY_NIGHT");												theSendBuf[j++] = 0x00;												send = true;												break;									}									break;						case CTI_ACK:										printf("CTI_ACK : ");									switch(theBuf[i++]) {									case CTI_ALARM:												printf("CTI_ALARM");												theSendBuf[j++] = 0x00;												send = true;												break;									case CTI_DAY_NIGHT:												printf("CTI_DAY_NIGHT");												theSendBuf[j++] = 0x00;												send = true;												break;									}									break;						case CTI_STOP:									printf("CTI_STOP");									i = 9999;									break;						default:	printf("???");									i = 9999;									break;						}						printf(" - ");						theSendBuf[j++] = 0xff;						if(send) {							theIsdn.SendCommand(theSendBuf, j);						}					}					puts("");					break;		}	} while(!Button());	}	catch(...) {		puts("[Timeout]");		if(!Button())			goto again;	}#endif}