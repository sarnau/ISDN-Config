// ===========================================================================//	CISDNDesktop.cp						©1994 Metrowerks Inc. All rights reserved.// ===========================================================================#include "CISDNDesktop.h"#if INCLUDE_ISTEC#include "CISTEC.h"#endif#if INCLUDE_EURACOM#include "CEuracom.h"#endif#if INCLUDE_ELMEG#include "CElmeg.h"#endif#include "CPreferences.h"#include <PP_Messages.h>const ResIDT	WIND_TextDoc		= 200;const ResIDT	WIND_Gebuehren		= 201;const ResIDT	WIND_Kurzwahlen		= 202;const ResIDT	WIND_Sperrnummern	= 203;const ResIDT	WIND_Nahbereich		= 204;const ResIDT	WIND_ISTECKurzwahlen= 205;const ResIDT	WIND_Frei			= 206;const ResIDT	STRx_Untitled		= 300;// ---------------------------------------------------------------------------//		¥ CISDNAnlage *CISDNDesktop::GetAnlage(const LPane *iPane)// ---------------------------------------------------------------------------// Anlage zu einer Pane in einem Fenster eines Dokuments findenCISDNAnlage		*CISDNDesktop::GetAnlage(const LPane *iPane){	LWindow			*theWind = LWindow::FetchWindowObject(iPane->GetMacPort());	ThrowIfNil_(theWind);	CISDNDesktop	*theDoc = (CISDNDesktop*)theWind->GetSuperCommander();	ThrowIfNil_(theDoc);	return theDoc->mAnlage;}// ---------------------------------------------------------------------------//		¥ CISDNDesktop(LCommander*, FSSpec*)// ---------------------------------------------------------------------------//	Construct a TextDoc associated with the specified file////	If inFileSpec is nil, then create an empty, untitled documentCISDNDesktop::CISDNDesktop(	LCommander	*inSuper,	FSSpec		*inFileSpec)		: LSingleDoc(inSuper){	if(inFileSpec != nil) {	// Dokument aus einem File heraus erstellen?		try {			LFile	theFile(*inFileSpec);			theFile.OpenDataFork(fsRdWrPerm);			Handle	dataH = theFile.ReadDataFork();			ThrowIfNil_(dataH);			ThrowIfNil_(gPrefs);			// zuerst einmal ermitteln, ob wir mit dem File Ÿberhaupt was anfangen kšnnen!#if INCLUDE_EURACOM			if(CEuracom::IsEuracomData(dataH)) {				gPrefs->P.DefHersteller = Anlage_Ackermann;			} else#endif#if INCLUDE_ISTEC				 if(CISTEC::IsISTECData(dataH)) {				gPrefs->P.DefHersteller = Anlage_Emmerich;			} else#endif#if INCLUDE_ELMEG				 if(CElmeg::IsElmegData(dataH)) {				gPrefs->P.DefHersteller = Anlage_Elmeg;			} else#endif				Throw_(ioErr);			::DisposeHandle(dataH);		}		catch(LException inErr) {			delete this;			throw inErr;		} 	}	mGebWindow = nil;		// kein weiteres Fenster ist offen!	mKurzWindow = nil;#if INCLUDE_EURACOM | INCLUDE_ELMEG	mSperrWindow = nil;#endif#if INCLUDE_EURACOM	mNahWindow = nil;#endif#if INCLUDE_ELMEG	mFreiWindow = nil;#endif	// Anlage allozieren#if ISTEC_ONLY	mAnlage = new CISTEC;#endif#if EURACOM_ONLY	mAnlage = new CEuracom;#endif#if ELMEG_ONLY	mAnlage = new CElmeg;#endif#if MORE_VERSIONS	switch(gPrefs->P.DefHersteller) {#if INCLUDE_EURACOM	case Anlage_Ackermann:	mAnlage = new CEuracom; break;#endif#if INCLUDE_ISTEC	case Anlage_Elmeg:		mAnlage = new CElmeg; break;#endif#if INCLUDE_ELMEG	case Anlage_Emmerich:	mAnlage = new CISTEC; break;#endif	}#endif	ThrowIfNil_(mAnlage);	// Iconfenster erzeugen	mWindow = LWindow::CreateWindow(WIND_TextDoc, this);	ThrowIfNil_(mWindow);	if (inFileSpec == nil) {		NameNewDoc();				// Set name of untitled window	} else {		OpenFile(*inFileSpec);		// Display contents of file in window	}	mWindow->Show();}// ---------------------------------------------------------------------------//		¥ NameNewDoc// ---------------------------------------------------------------------------//	Name a new, untitled document window////	Untitled windows start with "untitled", then "untitled 1",//	"untitled 2", etc. Old numbers are reused, so there won't be//	gaps in the numbering.////	This routine uses a STR# resource to store the "untitled" string,//	which can be localized to different languages. The first string//	is "untitled" and the second is "untitled " (trailing space),//	which is used when appending a number to the name.voidCISDNDesktop::NameNewDoc(){		// Start with the default name ("untitled")	Str255	name;	::GetIndString(name, STRx_Untitled, 1);	long	num = 0;	while (UWindows::FindNamedWindow(name) != nil) {			// An existing window has the current name			// Increment counter and try again		::GetIndString(name, STRx_Untitled, 2);		num++;		Str15	numStr;		::NumToString(num, numStr);		LString::AppendPStr(name, numStr);	}	mWindow->SetDescriptor(name);		// Finally, set window title	mAnlage->SetISDNData(nil);}// ---------------------------------------------------------------------------//		¥ OpenFile// ---------------------------------------------------------------------------//	Open a new document for the specified FilevoidCISDNDesktop::OpenFile(	const FSSpec	&inFileSpec){		// Create a new File object, read the entire File contents,		// put the contents into the text view, and set the Window		// title to the name of the File.	try {		mFile = new LFile(inFileSpec);		mFile->OpenDataFork(fsRdWrPerm);		Handle	dataH = mFile->ReadDataFork();		mAnlage->SetISDNData(dataH);		::DisposeHandle(dataH);		LStr255	theName = inFileSpec.name;		theName.SetCompareFunc(LString::CompareIgnoringCase);		if(theName.EndsWith("\p.CFG"))		// Extension vorhanden?			theName.Remove(theName.Length() - 4, 4);	// diese entfernen!		mWindow->SetDescriptor(theName);		mIsSpecified = true;		LStr255	the2Name = theName + "\p.kwz";	// probeweise mal Filename + ".kwz" laden		FSSpec	theKWZSpec = inFileSpec;		LString::CopyPStr(the2Name, theKWZSpec.name);		if(::FSMakeFSSpec(theKWZSpec.vRefNum, theKWZSpec.parID, theKWZSpec.name, &theKWZSpec) == noErr)		{			try {				LFile	theFile(theKWZSpec);				theFile.OpenDataFork(fsRdPerm);				dataH = theFile.ReadDataFork();				mAnlage->SetOptData(dataH);				::DisposeHandle(dataH);			}			catch(LException inErr) {				mAnlage->SetOptData(nil);			} 		} else {			mAnlage->SetOptData(nil);		}	}	catch(LException inErr) {		delete this;		throw inErr;	} }// ---------------------------------------------------------------------------//		¥ IsModified// ---------------------------------------------------------------------------//	Return whether the Document is has changed since the last saveBooleanCISDNDesktop::IsModified(){		// Document has changed if the text view is dirty	mIsModified = mAnlage->IsDirty();	return mIsModified;}// ---------------------------------------------------------------------------//		¥ DoAESave// ---------------------------------------------------------------------------//	Save Document in the specified file with the specified file type////	If file type is fileType_Default, use the normal file type for//	this documentvoidCISDNDesktop::DoAESave(	FSSpec	&inFileSpec,	OSType	inFileType){#pragma unused (inFileType)	delete mFile;						// Kill existing file	mFile = new LFile(inFileSpec);		// Make new file object										// Make new file on disk	mFile->CreateNewDataFile('EPAK', 'EPak', 0);	mFile->OpenDataFork(fsRdWrPerm);	DoSave();							// Write out data										// Change window name	mWindow->SetDescriptor(inFileSpec.name);	mIsSpecified = true;				// Document now has a specified file}// ---------------------------------------------------------------------------//		¥ DoSave// ---------------------------------------------------------------------------//	Save the entire Document to its associated File (which must already exist)voidCISDNDesktop::DoSave(){										// Get text and write to file	Handle	dataH = mAnlage->GetISDNData();	StHandleLocker	theLock(dataH);	mFile->WriteDataFork(*dataH, GetHandleSize(dataH));	::DisposeHandle(dataH);	// optionale Daten (wenn vorhanden) speichern	dataH = mAnlage->GetOptData();	if(dataH) {		FSSpec	inFileSpec;		mFile->GetSpecifier(inFileSpec);		LStr255	theName = inFileSpec.name;		theName.SetCompareFunc(LString::CompareIgnoringCase);		if(theName.EndsWith("\p.CFG"))		// Extension vorhanden?			theName.Remove(theName.Length() - 4, 4);	// diese entfernen!		LStr255	the2Name = theName + "\p.kwz";	// probeweise mal Filename + ".kwz" laden		LString::CopyPStr(the2Name, inFileSpec.name);		try {			LFile	theFile(inFileSpec);		// Make new file object			try {				theFile.CreateNewDataFile('EPAK', 'EPaK', 0);	// Make new file on disk			}			catch(LException inErr) {				if(inErr.GetErrorCode() != dupFNErr) throw inErr;			}			theFile.OpenDataFork(fsWrPerm);			StHandleLocker	theLock(dataH);			theFile.WriteDataFork(*dataH, GetHandleSize(dataH));		}		catch(LException inErr) {			mAnlage->SetOptData(nil);		} 		::DisposeHandle(dataH);	}	mAnlage->SetDirty(false);			// Saving makes doc un-dirty}// ---------------------------------------------------------------------------//		¥ DoRevert// ---------------------------------------------------------------------------//	Revert the Document to the last saved version on diskvoidCISDNDesktop::DoRevert(){	ThrowIfNil_(mAnlage);	Handle	dataH = mFile->ReadDataFork();	mAnlage->SetISDNData(dataH);	::DisposeHandle(dataH);	// optionale Daten erneut laden	FSSpec	inFileSpec;	mFile->GetSpecifier(inFileSpec);	LStr255	theName = inFileSpec.name;	theName.SetCompareFunc(LString::CompareIgnoringCase);	if(theName.EndsWith("\p.CFG"))		// Extension vorhanden?		theName.Remove(theName.Length() - 4, 4);	// diese entfernen!	LStr255	the2Name = theName + "\p.kwz";	// probeweise mal Filename + ".kwz" laden	LString::CopyPStr(the2Name, inFileSpec.name);	try {		LFile	theFile(inFileSpec);		theFile.OpenDataFork(fsRdPerm);		dataH = theFile.ReadDataFork();		mAnlage->SetOptData(dataH);		::DisposeHandle(dataH);	}	catch(LException inErr) {		mAnlage->SetOptData(nil);	} }/*** *	Apple Event Handlers ***/void		CISDNDesktop::HandleAppleEvent(									const AppleEvent	&inAppleEvent,									AppleEvent			&outAEReply,									AEDesc				&outResult,									SInt32				inAENumber){	ThrowIfNil_(mAnlage);	switch (inAENumber) {	case 10000:		mAnlage->Auslesen();		break;	case 10002:		mAnlage->Reset();		break;#if !DEMO_VERSION	case 10001:		mAnlage->Senden();		break;	case 10003:		mAnlage->ReadGeb();		break;#endif	case 10004:		mAnlage->ChangePasswort();		break;	case 10005:		mAnlage->Anrufweiterschaltung();		break;	default:		LSingleDoc::HandleAppleEvent(inAppleEvent, outAEReply, outResult, inAENumber);		break;	}}Boolean		CISDNDesktop::ObeyCommand(CommandT inCommand, void *ioParam){	ThrowIfNil_(mAnlage);	Boolean		cmdHandled = true;	switch (inCommand) {	case cmd_About:#if ELMEG_ONLY		CElmeg::DoAbout();#else		if(mAnlage)			mAnlage->About();#endif		break;	case 3000:		try {			AppleEvent	theAppleEvent;			UAppleEventsMgr::MakeAppleEvent(kISDNEventClass, kAEChangePassword, theAppleEvent);			StAEDescriptor	docSpec;			MakeSpecifier(docSpec.mDesc);			OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject, &docSpec.mDesc);			ThrowIfOSErr_(err);			UAppleEventsMgr::SendAppleEvent(theAppleEvent);		}		catch(LException inErr) {			mAnlage->ChangePasswort();		} 		break;	case 3001:		try {			AppleEvent	theAppleEvent;			UAppleEventsMgr::MakeAppleEvent(kISDNEventClass, kAEAnrufweiterschaltung, theAppleEvent);			StAEDescriptor	docSpec;			MakeSpecifier(docSpec.mDesc);			OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject, &docSpec.mDesc);			ThrowIfOSErr_(err);			UAppleEventsMgr::SendAppleEvent(theAppleEvent);		}		catch(LException inErr) {			mAnlage->Anrufweiterschaltung();		} 		break;	case 2000:		try {			AppleEvent	theAppleEvent;			UAppleEventsMgr::MakeAppleEvent(kISDNEventClass, kAEReadAnlage, theAppleEvent);			StAEDescriptor	docSpec;			MakeSpecifier(docSpec.mDesc);			OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject, &docSpec.mDesc);			ThrowIfOSErr_(err);			UAppleEventsMgr::SendAppleEvent(theAppleEvent);		}		catch(LException inErr) {			mAnlage->Auslesen();		} 		break;	case 2002:		if(CautionAlert(131, 0L) == 2) {			try {				AppleEvent	theAppleEvent;				UAppleEventsMgr::MakeAppleEvent(kISDNEventClass, kAEResetAnlage, theAppleEvent);				StAEDescriptor	docSpec;				MakeSpecifier(docSpec.mDesc);				OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject, &docSpec.mDesc);				ThrowIfOSErr_(err);				UAppleEventsMgr::SendAppleEvent(theAppleEvent);			}			catch(LException inErr) {				mAnlage->Reset();			} 		}		break;#if !DEMO_VERSION	case 2001:		try {			AppleEvent	theAppleEvent;			UAppleEventsMgr::MakeAppleEvent(kISDNEventClass, kAESendAnlage, theAppleEvent);			StAEDescriptor	docSpec;			MakeSpecifier(docSpec.mDesc);			OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject, &docSpec.mDesc);			ThrowIfOSErr_(err);			UAppleEventsMgr::SendAppleEvent(theAppleEvent);		}		catch(LException inErr) {			mAnlage->Senden();		} 		break;	case 2003:		try {			AppleEvent	theAppleEvent;			UAppleEventsMgr::MakeAppleEvent(kISDNEventClass, kAEReadGeb, theAppleEvent);			StAEDescriptor	docSpec;			MakeSpecifier(docSpec.mDesc);			OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject, &docSpec.mDesc);			ThrowIfOSErr_(err);			UAppleEventsMgr::SendAppleEvent(theAppleEvent);		}		catch(LException inErr) {			SysBeep(30);			mAnlage->ReadGeb();		} 		break;#endif	case 2004:		// GebŸhrenfenster erzeugen		if(mGebWindow) {			delete mGebWindow;			mGebWindow = nil;		} else {			mGebWindow = LWindow::CreateWindow(WIND_Gebuehren, this);			mGebWindow->Show();		}		break;	case 2005:		// GebŸhrenfenster erzeugen		if(mKurzWindow) {			delete mKurzWindow;			mKurzWindow = nil;		} else {			mKurzWindow = LWindow::CreateWindow((mAnlage->GetAnlagenHersteller() == Anlage_Emmerich) ? WIND_ISTECKurzwahlen : WIND_Kurzwahlen, this);			mKurzWindow->Show();		}		break;#if INCLUDE_EURACOM | INCLUDE_ELMEG	case 2006:		// Sperrbereich erzeugen		if(mSperrWindow) {			delete mSperrWindow;			mSperrWindow = nil;		} else {			mSperrWindow = LWindow::CreateWindow(WIND_Sperrnummern, this);			mSperrWindow->Show();		}		break;#endif#if INCLUDE_EURACOM	case 2007:		// Nachbereichswindow erzeugen		if(mNahWindow) {			delete mNahWindow;			mNahWindow = nil;		} else {			mNahWindow = LWindow::CreateWindow(WIND_Nahbereich, this);			mNahWindow->Show();		}		break;#endif#if INCLUDE_ELMEG	case 2008:		// Nachbereichswindow erzeugen		if(mFreiWindow) {			delete mFreiWindow;			mFreiWindow = nil;		} else {			mFreiWindow = LWindow::CreateWindow(WIND_Frei, this);			mFreiWindow->Show();		}		break;#endif		// Tag/Nacht Varianten	case 2200: case 2201: case 2202: case 2203: case 2204: case 2205: case 2206: case 2207:		// Anlage kennt nur eine Variante		if(mAnlage->GetConfigCount() < 2) break;		mAnlage->SetConfig(inCommand - 2200);		mAnlage->SetDirty();		mAnlage->ExecuteAttachments(msg_AnlageDirty, nil);		break;	default:		cmdHandled = LSingleDoc::ObeyCommand(inCommand, ioParam);		break;	}	return cmdHandled;}// GebŸhrenfenster schlie§en? Dann die dazugehšrige Member-Variable lšschen...Boolean		CISDNDesktop::AllowSubRemoval(LCommander* inSub){	if(inSub == mGebWindow) {		mGebWindow = nil;		return true;	}	if(inSub == mKurzWindow) {		mKurzWindow = nil;		return true;	}#if INCLUDE_EURACOM | INCLUDE_ELMEG	if(inSub == mSperrWindow) {		mSperrWindow = nil;		return true;	}#endif#if INCLUDE_EURACOM	if(inSub == mNahWindow) {		mNahWindow = nil;		return true;	}#endif#if INCLUDE_ELMEG	if(inSub == mFreiWindow) {		mFreiWindow = nil;		return true;	}#endif	return LSingleDoc::AllowSubRemoval(inSub);}void		CISDNDesktop::FindCommandStatus(CommandT inCommand, Boolean &outEnabled, Boolean &outUsesMark, UInt16 &outMark, Str255 outName){	ThrowIfNil_(mAnlage);	outUsesMark = false;	switch (inCommand) {	case cmd_About:#if ELMEG_ONLY		if(mAnlage)#endif			outEnabled = true;		break;	case 3000:		if(mAnlage->HasChangePasswort())			outEnabled = true;		break;	case 3001:		if(mAnlage->HasAnrufweiterschaltung())			outEnabled = true;		break;#if INCLUDE_ELMEG	case 2008:		GetIndString(outName, 1000, mFreiWindow == nil ? 30 : 31);		if(mAnlage->GetFreinummerCount() > 0)			outEnabled = true;		break;#endif#if INCLUDE_EURACOM	case 2007:		GetIndString(outName, 1000, mNahWindow == nil ? 21 : 22);		if(mAnlage->GetNahbereichsnummerCount() > 0)			outEnabled = true;		break;#endif#if INCLUDE_EURACOM | INCLUDE_ELMEG	case 2006:		GetIndString(outName, 1000, mSperrWindow == nil ? 19 : 20);		if(mAnlage->GetSperrnummerCount() > 0)			outEnabled = true;		break;#endif	case 2005:		GetIndString(outName, 1000, mKurzWindow == nil ? 14 : 15);		if(mAnlage->GetKurzwahlCount() > 0)			outEnabled = true;		break;	case 2004:		GetIndString(outName, 1000, mGebWindow == nil ? 11 : 12);		if(mAnlage->GetAppGebCount() > 0)			outEnabled = true;		break;#if !DEMO_VERSION	case 2003:		if(mAnlage->GetAppGebCount() == 0)			break;	case 2001:#endif	case 2000:	case 2002:		outEnabled = true;		break;		// Tag/Nacht Varianten	case 2200: case 2201: case 2202: case 2203: case 2204: case 2205: case 2206: case 2207:		outUsesMark = true;		outMark = noMark;		// eine alte Anlage		if(mAnlage->GetVersion() < 200) break;		// Anlage kennt nur eine Variante		if(mAnlage->GetConfigCount() < 2) break;		SInt32	theIndex = inCommand - 2200;		if(mAnlage->GetConfigCount() < theIndex) break;		outEnabled = true;		if(theIndex == mAnlage->GetConfig())			outMark = checkMark;		break;	default:		LSingleDoc::FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName);		break;	}}