/*** *	Library für die serielle Schnittstelle ***/#define SERDEBUG		0#include "SerialComm.h"#if SERDEBUG#include <stdio.h>#endif#include <CommResources.h>#include <CRMSerialDevices.h>#include <UMemoryMgr.h>#include "CPreferences.h"LArray			*gSerialPortnames;/*** *	alle seriellen Ports ermitteln ***/void	SerialDriver::Lookup(Boolean (SerialDriver::*lookup)(short index,LStr255 portname,LStr255 indriver,LStr255 outdriver)){	SInt16		old = 0;				// ID des Ports	CRMRecPtr	theCRM;	for(int index = 1; ; old = theCRM->crmDeviceID, index++) {		CRMRec	theCRMRec;		theCRMRec.crmDeviceType = crmSerialDevice;		theCRMRec.crmDeviceID = old;		theCRM = &theCRMRec;		theCRM = CRMSearch(theCRM);				// Port suchen		if(!theCRM) break;						// keinen weiteren Port gefunden => raus		CRMSerialPtr	theSerial = CRMSerialPtr(theCRM->crmAttributes);		ThrowIfNil_(theSerial);		StHandleLocker	th1(Handle(theSerial->name));		StHandleLocker	th2(Handle(theSerial->inputDriverName));		StHandleLocker	th3(Handle(theSerial->outputDriverName));		if((this->*lookup)(index,*(theSerial->name),*(theSerial->inputDriverName),						*(theSerial->outputDriverName))) break;	// Treiber gefunden => raus	}}/*** *	gefundenen Treiber öffnen ***/Boolean	SerialDriver::CBOpen(short index, LStr255 portname, LStr255 indriver, LStr255 outdriver){OSErr	err;	if(portname != SDName)		return false;					// Port gefunden?	err = ::OpenDriver(indriver, &SDIn);	if(err) {		SDIn = 0;						// Ports löschen		SDCBOpenErr = err;		return true;					// Fehler beim Öffnen => Abbruch	}	err = ::OpenDriver(outdriver, &SDOut);	if(err) {		::CloseDriver(SDIn);			// Eingangstreiber schließen		SDIn = SDOut = 0;				// Ports löschen		SDCBOpenErr = err;		return true;					// Fehler beim Öffnen => Abbruch	}	SDPort = index;						// aktiver Port	SDCBOpenErr = noErr;	return true;}void	SerialDriver::BuildMenu(){	// Liste der installieren seriellen Ports löschen und eine leere Liste anlegen	if(gSerialPortnames) delete gSerialPortnames;	gSerialPortnames = new LArray(sizeof(Str255));	ThrowIfNil_(gSerialPortnames);	SDCBOpenErr = fnfErr;					// noch nicht wiedergefunden!	ThrowIfNil_(gPrefs);	SDName = gPrefs->P.Port;	Lookup(&SerialDriver::CBAppendMenu);	if(SDCBOpenErr == fnfErr)				// Port nicht wiedergefunden?		gPrefs->P.Port = "\p";				// dann den aktuellen Port wählen}Boolean	SerialDriver::CBAppendMenu(short index,LStr255 portname,LStr255 indriver,LStr255 outdriver){#pragma unused (index, indriver, outdriver)	// gesuchten Port gefunden?	if(portname == SDName)		SDCBOpenErr = noErr;		// dann Fehlercode löschen	// Namen an die Portliste anhängen	ThrowIfNil_(gSerialPortnames);	gSerialPortnames->AddItem(portname);	// Port nicht gefunden => weitersuchen	return false;}/*** *	seriellen Port wieder abmelden ***/void	SerialDriver::Close(){OSErr	err = noErr;#if SERIALBUF	if(SDInBuf) {			// seriellen Buffer freigeben		SerSetBuf(SDIn,nil,(short)nil);		DisposePtr((Ptr)SDInBuf);		SDInBuf = nil;	}#endif	if(SDIn) {				// seriellen Port schließen		::KillIO(SDIn);		err = CloseDriver(SDIn);		SDIn = 0;	}	if(SDOut) {		::KillIO(SDOut);		if (err)			CloseDriver(SDOut);		else			err = CloseDriver(SDOut);		SDOut = 0;	}	SDPort = 0;	if(err) Throw_(err);}/*** *	seriellen Port mit 9600 Baud 8N1 XON/XOFF anmelden ***/void	SerialDriver::Open(UInt16 iSerialInit, Boolean iHWHandshake){OSErr		err;	SDInBuf = 0;	if(SDPort > 0) Close();	Lookup(&SerialDriver::CBOpen);		// Treiber suchen und öffnen	if(SDCBOpenErr) Throw_(SDCBOpenErr);// kein Treiber gefunden!	SDTimeout = 60;						// Timeout = 1s	err = SerReset(SDOut, iSerialInit);	if(err) {		Close();		Throw_(err);	}	err = SerReset(SDIn, iSerialInit);	if(err) {		Close();		Throw_(err);	}	SerShk		s;	s.fXOn = false;			// XOn flow control enabled flag	s.fCTS = iHWHandshake;	// CTS flow control enabled flag	s.xOn = XOn;			// XOn character	s.xOff = XOff;			// XOff character	s.errs = parityErr + hwOverrunErr + framingErr;	// errors mask bits	s.evts = 0;				// event enable mask bits	s.fInX = false;			// Input flow control enabled flag	s.fDTR = iHWHandshake;	// DTR input flow control flag	err = ::SerHShake(SDOut,&s);	if(err) {		Close();		Throw_(err);	}	if(!iHWHandshake)		DTR(true);#if SERIALBUF	SDInBuf = (StringPtr)::NewPtr(SERIALBUF);	if(SDInBuf)			// größeren Buffer für den Eingang		::SerSetBuf(SDIn, Ptr(SDInBuf), SERIALBUF);	ThrowIfNil_(SDInBuf);#endif}/*** *	DTR-Flag setzen oder löschen ***/void	SerialDriver::DTR(Boolean flag){	CntrlParam	pb;	pb.ioCRefNum = SDOut;	pb.csCode = flag ? kSERDAssertDTR : kSERDNegateDTR;	::PBControlSync((ParmBlkPtr)&pb);}/*** *	Eingangsbuffer flushen ***/void	SerialDriver::FlushIO(){	::KillIO(SDIn);	::KillIO(SDOut);	do {		long	theCount;		Wait(15, &theCount);		if(theCount == 0L) break;		char	buf[256];		if(theCount > 256) theCount = 256;		::FSRead(SDIn, &theCount, buf);	} while(1);}/*** *	String der Länge “len” im Stdio-Window mit Steuerzeichen ausgeben ***/#if SERDEBUGvoid		SerialDriver::DebugPrint(const char* header,const StringPtr s,unsigned short len){static FILE	*f = nil;	if (!f) {//		f = stdout;		f = fopen("INPUT","w+");	}	fprintf(f,"%s[%c]:",header, SDName[1]);	for(int i=0;i<len;i++) {		char	cc = s[i];		if(cc == 32) cc = '…';		if(cc < 32) {			cc *= 3;			static char tab[] = {					"NULSOHSTXETXEOTENQACKBELBS TABLF VT FF CR SO SI "					"DLEDC1DC2DC3DC4NAKSYNETBCANEM SUBESCFS GS RS US " };			if (tab[cc+2] == ' ')				fprintf(f,"<%c%c:%d>",tab[cc],tab[cc+1],s[i]);			else				fprintf(f,"<%c%c%c:%d>",tab[cc],tab[cc+1],tab[cc+2],s[i]);		} else if(cc >= 0x80) {			fprintf(f,"<0x%2.2x>",cc);		} else {#if 1			putc(cc, f);#else			int	j = i;			while(s[i]>=32 && s[i]<0x80 && i<len) {				if(s[i] == 32) s[i] = '…';				i++;			}			UInt8	temp = s[i]; s[i] = 0;			fprintf(f,"%s",&s[j]);			s[i--] = temp;#endif		}	}	fprintf(f,"\n");}#endif/*** *	auf Bytes an der Seriellen warten ***/OSErr	SerialDriver::Wait(unsigned short timeout,long *count){OSErr			err;unsigned long	time = (unsigned long)TickCount() + timeout;Boolean			flag = false;	while(true) {		if(time < (unsigned long)TickCount()) flag = true;	// Timeout?		err = SerGetBuf(SDIn,(long*)count);	// Bytes im In-Buffer abfragen		if(err) return err;					// OS-Error		if(*count > 0) return noErr;		// es sind Bytes da		if(flag) return 1;					// Timeout	}}/*** *	einen String über die serielle Schnittstelle senden ***/void	SerialDriver::Write(StringPtr s,unsigned short count){OSErr	err;long	c = count;#if SERDEBUG	DebugPrint("MAC",s,count);#endif	err = FSWrite(SDOut,&c,s);			// String senden	if(count != c && err == noErr)		Throw_(ioErr);					// Bytes nicht gesendet}/*** *	count Bytes über die serielle Schnittstelle einlesen ***/short	SerialDriver::Read(StringPtr buf,unsigned short maxbytes){OSErr		err;		// Fehlercode, der letzten Operationlong		count;		// Anzahl der vorhandenen/gelesenen Bytesshort		sum = 0;	// Anzahl der gelesenen Bytes#if SERDEBUGStringPtr	bufstart = buf;	// Anfangsadresse vom Empfangsbuffer#endif	do {		err = Wait(SDTimeout,&count);	// 1s Timeout		if(err || !count) break;		// Abbruch, wenn Fehler, oder alles gelesen		count = 1;		err = FSRead(SDIn,&count,buf);	// ein Byte aus dem Buffer einlesen		if(err) break;					// Abbruch, wenn Fehler		sum++;							// Zeichen zählen		buf++;							// zum nächsten Zeichen	} while(sum < maxbytes);			// alle Bytes gelesen?#if SERDEBUG	DebugPrint("ELMEG",bufstart,sum);#endif	return sum;							// Anzahl der gelesenen Bytes}