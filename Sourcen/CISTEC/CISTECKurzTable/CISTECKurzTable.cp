// ===========================================================================//	CISTECKurzTable.cp					© 1996, Markus Fritze. All rights reserved.// ===========================================================================#include "SharewareFlags.h"#if INCLUDE_ISTEC#include "CISTECKurzTable.h"#include <LTableMultiGeometry.h>#include <LTableSingleSelector.h>#include <UModalDialogs.h>#include <UTextTraits.h>#include <LStdControl.h>#include <LEditField.h>#include "CISDNDesktop.h"#include "CISTEC.h"bool    CISTECKurzTable::sRegisterClass = PPFactory<CISTECKurzTable>::RegisterClass();bool    CISTECKurzTableView::sRegisterClass = PPFactory<CISTECKurzTableView>::RegisterClass();// ---------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------//	Finish Creating a Pane////	This function gets called after creating a Pane from a data stream.//	Override to perform finishing touches that depend on the entire//	Pane hierarchy being constructed.////	For example, if a View wants to store a pointer to a SubPane,//	it should override this function to call FindPaneByID for that//	Pane. This saves the overhead of repeatedly calling FindPaneByID//	when the View wants to access that SubPane. You can't do this from//	a Constructor because SubPanes are created after their SuperView.const SInt16	KT_Spalte_1 = 25;const SInt16	KT_Spalte_2 = 150;const SInt16	KT_Spalte_3 = 235;const SInt16	KT_Spalte_4 = 100;voidCISTECKurzTable::FinishCreateSelf(){	CISTECKurzTableView	*table = (CISTECKurzTableView*)FindPaneByID('KuTA');	mAnlage = CISDNDesktop::GetAnlage(this);	mAnlage->AddAttachment(this);	table->SetTableGeometry(new LTableMultiGeometry(table, KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3 + KT_Spalte_4, 16));	table->SetTableSelector(new LTableSingleSelector(table));	SInt16		theItemCount = mAnlage->GetKurzwahlCount() + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_No);	table->InsertCols(4, 0, nil, 0, Refresh_No);	table->SetColWidth(KT_Spalte_1, 1, 1);	table->SetColWidth(KT_Spalte_2, 2, 2);	table->SetColWidth(KT_Spalte_3, 3, 3);	table->SetColWidth(KT_Spalte_4, 4, 4);	// Fenstergrš§e, Minimum + Maximum setzen (dazu mu§ das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort());	theWind->Show();	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	theRect.right = theRect.left + (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3 + KT_Spalte_4)  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3 + KT_Spalte_4)  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(theItemCount > 10) theItemCount = 10;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		¥ ExecuteSelf(MessageT inMessage, void *ioParam)// ---------------------------------------------------------------------------//	Draw the contents of the specified Cellvoid		CISTECKurzTable::ExecuteSelf(MessageT inMessage, void *ioParam){#pragma unused (inMessage, ioParam)	CISTECKurzTableView	*table = (CISTECKurzTableView*)FindPaneByID('KuTA');	TableIndexT	theRows, theColumns;	table->GetTableSize(theRows, theColumns);	table->RemoveRows(theRows, 1, Refresh_No);	int		theItemCount = mAnlage->GetKurzwahlCount() + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_Yes);	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	int	aktCount = (theRect.bottom - theRect.top - (ScrollBar_Size - 1)) / 16;	theRect.right = theRect.left + (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3 + KT_Spalte_4)  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	// Fenstergrš§e, Minimum + Maximum setzen (dazu mu§ das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort());	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3 + KT_Spalte_4)  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(aktCount > theItemCount) aktCount = theItemCount;	theRect.bottom = theRect.top + 16  * aktCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		¥ CISTECKurzTableView// ---------------------------------------------------------------------------//	Return a new TableView object initialized using data from a StreamCISTECKurzTableView::CISTECKurzTableView(LStream *inStream) : LTableView(inStream){	mAnlage = CISDNDesktop::GetAnlage(this);}// ---------------------------------------------------------------------------//		¥ ClickSelect// ---------------------------------------------------------------------------//	Adjust selection in response to a click in the specified cell////	Return whether or not to process the click as a normal clickBooleanCISTECKurzTableView::ClickSelect(	const STableCell		&inCell,	const SMouseDownEvent	&inMouseDown){	if(inCell.col == 1 || inCell.row == 1) return false;	// Klick in die erste Spalte/Reihe ist nicht mšglich!	if(mTableSelector != nil)		mTableSelector->ClickSelect(inCell, inMouseDown);	return true;}// ---------------------------------------------------------------------------//		¥ DrawCell// ---------------------------------------------------------------------------//	Draw the contents of the specified CellvoidCISTECKurzTableView::DrawCell(	const STableCell	&inCell,	const Rect			&inLocalRect){	UTextTraits::SetPortTextTraits(129);	LStr255	theAppKurzNoStr;	LStr255	theAppNummer;	LStr255	theAppName;	LStr255	theAppDescription;	if(inCell.row == 1) {		::MoveTo(inLocalRect.left, inLocalRect.bottom - 1);		::LineTo(inLocalRect.right, inLocalRect.bottom - 1);		theAppKurzNoStr.Assign(1000, 16);		theAppNummer.Assign(1000, 17);		theAppName.Assign(1000, 18);		theAppDescription.Assign(1000, 28);	} else {		SInt16	theAppKurzNo;		mAnlage->GetKurzwahl(inCell.row - 1, theAppKurzNo, theAppNummer, theAppName);		theAppKurzNoStr = LStr255(SInt32(theAppKurzNo));	}	switch(inCell.col) {	case 1:	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);			::DrawString(theAppKurzNoStr);			::MoveTo(inLocalRect.right - 1, inLocalRect.top);			::LineTo(inLocalRect.right - 1, inLocalRect.bottom);			break;	case 2:	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);			::DrawString(theAppNummer);			::MoveTo(inLocalRect.right - 1, inLocalRect.top);			::LineTo(inLocalRect.right - 1, inLocalRect.bottom);			break;	case 3:	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);			::DrawString(theAppName);			::MoveTo(inLocalRect.right - 1, inLocalRect.top);			::LineTo(inLocalRect.right - 1, inLocalRect.bottom);			break;	case 4:	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);			if(inCell.row == 1) {				::DrawString(theAppDescription);			} else {				int	saveconfig = mAnlage->GetConfig();				mAnlage->SetConfig(0);				const CISTEC::KurzwahlKonfigStruct	*kks = &((CISTEC*)mAnlage)->mK->mKurz[inCell.row - 2];				LStr255	theDescStr = "\p";				theDescStr += kks->Sperre ? 'S' : ' ';				theDescStr += kks->Babyruf ? 'B' : ' ';				char	appChar = ' ';				switch(kks->Sonderruf) {				case 1:	appChar = '1'; break;				case 2:	appChar = '2'; break;				case 3:	appChar = '-'; break;				case 4:	appChar = '3'; break;				}				theDescStr += appChar;				::DrawString(theDescStr);				::MoveTo(inLocalRect.left + 30, inLocalRect.bottom - 4);				theDescStr = "\p#";				bool	found = false;				for(int i=0; i<8; i++) {					if(kks->Tin & (1 << i)) {						theDescStr += char(i + '1');						found = true;					}				}				if(!found)					theDescStr += '?';				::DrawString(theDescStr);				mAnlage->SetConfig(saveconfig);			}			break;	}}// ---------------------------------------------------------------------------//		¥ ClickCell// ---------------------------------------------------------------------------//	Handle a mouse click within the specified CellvoidCISTECKurzTableView::ClickCell(	const STableCell&		inCell,	const SMouseDownEvent&	/* inMouseDown */){	if(sClickCount < 2) return;	int	saveconfig = mAnlage->GetConfig();	mAnlage->SetConfig(0);	StDialogHandler	theSubHandler(303, this);	LWindow		*theSubDialog = theSubHandler.GetDialog();	SInt16	theAppKurzNo;	LStr255	theAppNummer;	LStr255	theAppName;	mAnlage->GetKurzwahl(inCell.row - 1, theAppKurzNo, theAppNummer, theAppName);	CISTEC::KurzwahlKonfigStruct	*kks = &((CISTEC*)mAnlage)->mK->mKurz[inCell.row - 2];	LStdCheckBox	*schk1 = (LStdCheckBox*)theSubDialog->FindPaneByID('Sper');	schk1->SetValue(kks->Sperre != 0);	LStdPopupMenu	*spop = (LStdPopupMenu*)theSubDialog->FindPaneByID('Sond');	int	val = kks->Sonderruf;	switch(val) {	case 3:	val = 4; break;	case 4:	val = 3; break;	}	spop->SetValue(++val);	for(int i=0; i<8; i++) {		LStdCheckBox	*schk = (LStdCheckBox*)theSubDialog->FindPaneByID('Ap21' + i);		if(kks->Tin & (1 << i))			schk->SetValue(1);	}	for(int i=0; i<8; i++) {		LStdCheckBox	*schk = (LStdCheckBox*)theSubDialog->FindPaneByID('Bp21' + i);		if(kks->Babyruf & (1 << i))			schk->SetValue(1);	}	LEditField	*theTelNumber = (LEditField*)theSubDialog->FindPaneByID('TeNr');	theTelNumber->SetDescriptor(theAppNummer);	LEditField	*theName = (LEditField*)theSubDialog->FindPaneByID('Name');	theName->SetDescriptor(theAppName);	theName->SetKeyFilter(AllInputField);	if(inCell.col == 3) {	// Doppelklick auf den Namen?		LCommander::SwitchTarget(theName);	// Cursor ins Feld setzen		theName->SelectAll();				// und alles selektieren	}	theSubDialog->Show();	while (true) {					// Let DialogHandler process events		MessageT	hitMessage = theSubHandler.DoDialog();		if (hitMessage == msg_Cancel) {			break;		} else if(hitMessage == msg_OK) {			bool	doUpdate = false;			if(schk1->GetValue() != (kks->Sperre != 0)) {				kks->Sperre = schk1->GetValue() ? 0xFF : 0x00;				doUpdate = true;			}			if(spop->GetValue() != val) {				val = spop->GetValue() - 1;				switch(val) {				case 3:	val = 4; break;				case 4:	val = 3; break;				}				kks->Sonderruf = val;				doUpdate = true;			}			for(int i=0; i<8; i++) {				LStdCheckBox	*schk = (LStdCheckBox*)theSubDialog->FindPaneByID('Bp21' + i);				bool		isSet = (kks->Babyruf & (1 << i)) != 0;				if(isSet != schk->GetValue()) {					kks->Babyruf &= ~(1 << i);				// Bit lšschen					if(!isSet) kks->Babyruf |= (1 << i);	// ggf. setzen					doUpdate = true;				}			}			for(int i=0; i<8; i++) {				LStdCheckBox	*schk = (LStdCheckBox*)theSubDialog->FindPaneByID('Ap21' + i);				bool		isSet = (kks->Tin & (1 << i)) != 0;				if(isSet != schk->GetValue()) {					kks->Tin &= ~(1 << i);				// Bit lšschen					if(!isSet) kks->Tin |= (1 << i);	// ggf. setzen					doUpdate = true;				}			}			LStr255	theNumTemp, theNameTemp;			theTelNumber->GetDescriptor(theNumTemp);			theName->GetDescriptor(theNameTemp);			if(theNumTemp != theAppNummer || theNameTemp != theAppName) {				mAnlage->SetKurzwahl(inCell.row - 1, theNumTemp, theNameTemp);				doUpdate = true;			}			if(doUpdate) {				mAnlage->SetDirty();				STableCell	theCell = inCell;				STableCell	theEndCell = inCell;				theCell.col = 1;				theEndCell.col = 4;				RefreshCellRange(theCell, theEndCell);			}			break;		}	}	mAnlage->SetConfig(saveconfig);}// ---------------------------------------------------------------------------//		¥ AllInputField// ---------------------------------------------------------------------------//	Key Filter for all charactersEKeyStatus	CISTECKurzTableView::AllInputField(TEHandle	inMacTEH,									   UInt16	inKeyCode,									   UInt16	&ioCharCode,									   UInt16	inModifiers){#pragma unused(inMacTEH, inModifiers)	EKeyStatus	theKeyStatus = keyStatus_PassUp;	UInt16		theKey = inKeyCode;	UInt16		theChar = ioCharCode;	if (UKeyFilters::IsTEDeleteKey(theKey)) {		theKeyStatus = keyStatus_TEDelete;	} else if (UKeyFilters::IsTECursorKey(theKey)) {		theKeyStatus = keyStatus_TECursor;	} else if (UKeyFilters::IsExtraEditKey(theKey)) {		theKeyStatus = keyStatus_ExtraEdit;	} else if (UKeyFilters::IsActionKey(theKey)) {		theKeyStatus = keyStatus_PassUp;	} else {		theKeyStatus = keyStatus_Input;	}	return theKeyStatus;}#endif