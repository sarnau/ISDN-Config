// ===========================================================================//	CISTEC.cp						©1994 Metrowerks Inc. All rights reserved.// ===========================================================================#include "SharewareFlags.h"#if INCLUDE_ISTEC#include "CISTEC.h"#include <LGroupBox.h>#include <UModalDialogs.h>#include <UMemoryMgr.h>#include <LEditField.h>#include <LStdControl.h>#include <PP_Messages.h>#include <fp.h>#include "ProgressBar.h"#include "MRFUtilities.h"#include "CPreferences.h"// Versionnummer als String zurückgebenvoid	CISTEC::GetVersionStr(LStr255 &oVersionStr) const{	oVersionStr = LStr255(GetVersion() / 100);	oVersionStr += '.';	oVersionStr += LStr255(GetVersion() % 100);}// Namen der Telefonanlage zurückgebenvoid	CISTEC::GetAnlagenName(LStr255 &oAnlageName) const{	oAnlageName = "\pISTEC ";	oAnlageName += LStr255(SInt32(GetAnlagenTyp()));}// Durchwahlnummer eines Apparates ermittelnSInt16	CISTEC::GetAppNo(SInt16 iAppIndex) const{	if(iAppIndex < 0 || iAppIndex >= GetAppCount())		return -1;	SInt16	theAppNo = mIndexTab[iAppIndex];		if(theAppNo < GetAB()) {		// Analoge Apparate 21…		theAppNo += 21;	} else {		theAppNo -= GetAB();		// Digitale Apparate 51…		theAppNo += 51;	}	return theAppNo;}Endgeraetedienst	CISTEC::GetAppDienst(SInt16 iAppIndex) const{	if(mIndexTab[iAppIndex] >= GetAB())		return Endgeraetedienst_Digital;	switch(mK->mEndg[mIndexTab[iAppIndex]].Dienst) {	default:return Endgeraetedienst_Unbekannt;	case 0:	return Endgeraetedienst_Fernsprechen;	case 1:	return Endgeraetedienst_Fax;	case 2:	return Endgeraetedienst_Modem;	case 3:	return Endgeraetedienst_DatexJ;	case 4:	return Endgeraetedienst_Anrufbeantworter;	case 5:	return Endgeraetedienst_Kombi;	}}Endgeraeteberechtigung	CISTEC::GetAppBerechtigung(SInt16 iAppIndex) const{	switch(mK->mEndg[mIndexTab[iAppIndex]].Wahlbewertung) {	default:return EB_unbekannt;	case 0:	return EB_Vollamt;	case 1:	return EB_Inland;	case 2:	return EB_Ort;	case 3:	return EB_Halbamt;	case 4:	return EB_keine;	}}// Apparat aktiv? (d.h. es ist ihm mindestens eine MSN zugeteilt)Boolean	CISTEC::IsAppActive(SInt16 iAppIndex) const{bool	isActive = true;	if(GetAnlageProtokoll() == 1 && GetAnlageAnschlussart() == 0) {	// E-DSS1 am Mehrgeräteanschluß		char	msnMask = 0x00;		for(int j=0; j<10; j++)			msnMask |= mK->mKonfig.MSNGroup[j];		if(((msnMask >> mIndexTab[iAppIndex]) & 1) == 0)			isActive = false;	// der Apparat ist offline	}	return isActive;}// Namen eines Apparates ermittelnvoid	CISTEC::GetAppName(SInt16 iAppIndex, LStr255 &oAppName) const{	oAppName = mK->mEndgName[mIndexTab[iAppIndex]];}// Namen eines Apparates ermittelnvoid	CISTEC::SetAppName(SInt16 iAppIndex, const LStr255 &iAppName){	BlockFill(mK->mEndgName[mIndexTab[iAppIndex]], 0, sizeof(Str31));	LString::CopyPStr(iAppName, mK->mEndgName[mIndexTab[iAppIndex]], sizeof(Str31));}// Gebührenzähler (Einheiten) eines Apparates ermittelnUInt16	CISTEC::GetAppGeb(SInt16 iAppIndex) const{	return mK->mGeb[mIndexTab[iAppIndex]];}// Gebührenzähler (Einheiten) eines Apparates setzenvoid	CISTEC::SetAppGeb(SInt16 iAppIndex, UInt16 theGebcount){	if(GetAppGeb(iAppIndex) == theGebcount) return;	// Wert nicht geändert!	mK->mGeb[mIndexTab[iAppIndex]] = theGebcount;	SetDirty();}void	CISTEC::GetKurzwahl(SInt16 iKurzIndex, SInt16 &oAppKurzNo, LStr255 &oAppNummer, LStr255 &oAppName) const{	if(iKurzIndex < 1 || iKurzIndex > ISTEC_ANZ_KW_NR) {		oAppKurzNo = -1;		return;	}	int	ii = GetConfig();	((CISTEC*)this)->SetConfig(0);	oAppKurzNo = 301 + iKurzIndex - 1;	oAppNummer.Assign(mK->mKurz[iKurzIndex - 1].RufNr);	oAppName.Assign(mK->mKurz[iKurzIndex - 1].Namen);	((CISTEC*)this)->SetConfig(ii);}void	CISTEC::SetKurzwahl(SInt16 iKurzIndex, const LStr255 oAppNummer, const LStr255 oAppName){	if(iKurzIndex < 1 || iKurzIndex > ISTEC_ANZ_KW_NR) return;	int	ii = GetConfig();	((CISTEC*)this)->SetConfig(0);	LString::CopyPStr(oAppNummer, mK->mKurz[iKurzIndex - 1].RufNr);	LString::CopyPStr(oAppName, mK->mKurz[iKurzIndex - 1].Namen);	((CISTEC*)this)->SetConfig(ii);}// Index-Umrechnungstabelle aufbauen:// linearer Index => ISTEC-Strukturen-Index// der ISTEC-Index hat bei 1TR6 Anlagen mit internem S0 Bus Lücken (nur 8, anstatt 10// Apparate an einem S0 Bus), die Strukturen aber nicht. Dazu diese Tabelle!void	CISTEC::BuildIndexTable(){	int	j = 0;	for(int i=0; i<64; i++) {		mIndexTab[i] = (j > 63) ? 63 : j++;		if(mK->mKonfig.Protokoll)		// E-DSS1?			continue;				// Ja =>		if(i != 31 && i != 39 && i != 47 & i != 55)			continue;				// bei 1TR6		j += 2;	}}void	CISTEC::SetDefault(Boolean iOptionalFlag){#pragma unused(iOptionalFlag)	GrundKonfigStruct	iKonfig;	if(GetConfig() == 0) {		BlockFill(&iKonfig, 0x00, sizeof(iKonfig));		if(gPrefs->P.DefAnlage <= AT_I1008)			iKonfig.Anschlussart = 0;	// Mehrgeräteanschluß		else			iKonfig.Anschlussart = 1;	// Anlagenanschluß		iKonfig.Protokoll = 1;			// E-DSS1		switch(gPrefs->P.DefAnlage) {		case AT_I1003:				iKonfig.Anz_abSchnittstellen = 3;				iKonfig.Anz_intS0Bus = 0;	// ISTEC 1003				iKonfig.Anz_extS0Bus = 1;				break;		case AT_I1008:				iKonfig.Anz_abSchnittstellen = 8;				iKonfig.Anz_intS0Bus = 0;	// ISTEC 1003				iKonfig.Anz_extS0Bus = 1;				break;		case AT_I1016:				iKonfig.Anz_abSchnittstellen = 16;				iKonfig.Anz_intS0Bus = 0;	// ISTEC 1016				iKonfig.Anz_extS0Bus = 1;				break;		case AT_I1024:				iKonfig.Anz_abSchnittstellen = 24;				iKonfig.Anz_intS0Bus = 0;	// ISTEC 1024				iKonfig.Anz_extS0Bus = 1;				break;		case AT_I2016:				iKonfig.Anz_abSchnittstellen = 16;				iKonfig.Anz_intS0Bus = 0;	// ISTEC 2016				iKonfig.Anz_extS0Bus = 2;				break;		case AT_I2024:				iKonfig.Anz_abSchnittstellen = 24;				iKonfig.Anz_intS0Bus = 0;	// ISTEC 2024				iKonfig.Anz_extS0Bus = 2;				break;		case AT_I2400:				iKonfig.Anz_abSchnittstellen = 0;				iKonfig.Anz_intS0Bus = 4;	// ISTEC 2400				iKonfig.Anz_extS0Bus = 2;				break;		case AT_I2416:				iKonfig.Anz_abSchnittstellen = 16;				iKonfig.Anz_intS0Bus = 4;	// ISTEC 2416				iKonfig.Anz_extS0Bus = 2;				break;		case AT_I2424:				iKonfig.Anz_abSchnittstellen = 24;				iKonfig.Anz_intS0Bus = 4;	// ISTEC 2424				iKonfig.Anz_extS0Bus = 2;				break;		}		iKonfig.SWVersionHigh = gPrefs->P.DefSoftware / 100;		iKonfig.SWVersionLow = gPrefs->P.DefSoftware % 100;		// Default-Apparat		// bei der ISTEC 2400 ist es 51, da es keine analogen Anschlüsse gibt!		mDefaultApp = (gPrefs->P.DefAnlage == AT_I2400) ? 51 : 21;		BlockFill(iKonfig.MSN, 0xFF, sizeof(iKonfig.MSN));		iKonfig.MusicOnHold = 1;			// Musik ist an		iKonfig.Abfragestelle1 = mDefaultApp;		iKonfig.Abfragestelle2 = mDefaultApp;		iKonfig.TFEZuordnung = mDefaultApp;		iKonfig.TFELocation[0] = 0xFF;	// Knopf 1: alle Apparate		iKonfig.TFELocation[1] = 0x01;	// Knopf 2…4: nur Apparat 1		iKonfig.TFELocation[2] = 0x01;		iKonfig.TFELocation[3] = 0x01;		{		LStr255		s(250,1);		iKonfig.NationalCode[0] = SInt32(s);	// Default-Ländervorwahl		}		SetKonfig(&iKonfig);		CheckData();		BlockFill(&mK->mEndg, 0, sizeof(mK->mEndg));		BlockFill(&mK->mEndgName, 0, sizeof(mK->mEndgName));		for(int i=0; i<64; i++) {			BlockFill(&mK->mEndg[i].UmlRufnummer, 0xFF, sizeof(mK->mEndg[0].UmlRufnummer));			mK->mEndg[i].AnzRufseq = 3;			LStr255	theAppName(1000, 13);			LString::CopyPStr(theAppName, mK->mEndgName[i]);		}		BlockFill(&mK->mGeb, 0, sizeof(mK->mGeb));		BlockFill(&mK->mKurz, 0, sizeof(mK->mKurz));		for(int i=0; i<ISTEC_ANZ_KW_NR; i++) {			mK->mKurz[i].Tin = 0xFF;		}		BuildIndexTable();	} else {		mKData[GetConfig()] = mKData[0];	}}CISTEC::CISTEC(){	for(int i=0; i<GetConfigCount(); ++i)	{		SetConfig(i);		SetDefault();	}	SetConfig(0);	SetDirty(false);}// Apparat möglich? Nein => Default-Apparat liefernchar		CISTEC::CheckGoodApp(char inApp, Boolean retNull){char	retVal = retNull ? 0 : mDefaultApp;	// gültiger ab-Apparat?	if(inApp < 21) return retVal;	if(inApp <= 20 + GetAB())		return inApp;	// gültiger S0-Apparat?	if(inApp < 51) return retVal;	if(inApp >= 51 + GetIntS0() * 10) return retVal;	if(mK->mKonfig.Protokoll) return inApp;			// E-DSS1 erlaubt 10 Apparate pro S0-Strang	int	theApp = inApp % 10;					// bei 1TR6 sind die Endziffer 9 und 0 nicht erlaubt!	if(theApp == 9 || theApp == 0) return retVal;	return inApp;}// interne Struktur überprüfen und ggf. korrigierenvoid		CISTEC::CheckData(){	if(GetVersion() < 100) {		mK->mKonfig.SWVersionHigh = 2;		mK->mKonfig.SWVersionLow = 0;	}	// ab 1.93 wird nur noch die ISTEC 1003/1008 unterstützt	if(GetVersion() >= 193) {		BlockFill(&mK->mGeb[8], 0, sizeof(mK->mGeb) - 8 * sizeof(mK->mGeb[0]));		BlockFill(&mK->mEndg[8], 0, sizeof(mK->mEndg) - 8 * sizeof(mK->mEndg[0]));	}	if(GetAppCount() > 8) mK->mKonfig.Anschlussart = 1;	// Anlagenanschluß zwangsweise ab der 1016	mK->mKonfig.TFEZuordnung = CheckGoodApp(mK->mKonfig.TFEZuordnung, GetVersion() >= 193 ? true : false);	mK->mKonfig.Abfragestelle1 = CheckGoodApp(mK->mKonfig.Abfragestelle1);	mK->mKonfig.Abfragestelle2 = CheckGoodApp(mK->mKonfig.Abfragestelle2);	if((mK->mKonfig.TFELocation[0] | mK->mKonfig.TFELocation[1] | mK->mKonfig.TFELocation[2] | mK->mKonfig.TFELocation[3]) == 0x00) {		mK->mKonfig.TFELocation[0] = 0xFF;	// Knopf 1: alle Apparate		mK->mKonfig.TFELocation[1] = 0x01;	// Knopf 2…4: nur Apparat 1		mK->mKonfig.TFELocation[2] = 0x01;		mK->mKonfig.TFELocation[3] = 0x01;	}	SInt32		Vorw = mK->mKonfig.NationalCode[0] + mK->mKonfig.NationalCode[1] * 256;	if(Vorw == 0)		mK->mKonfig.NationalCode[0] = SInt32(LStr255(250, 1));	// Default-Ländervorwahl	if(mK->mKonfig.MessageOnHold > 8)		mK->mKonfig.MessageOnHold = 0;	mAlarmApp = CheckGoodApp(mAlarmApp, true);	for(int i=0; i<64; i++) {		if(mK->mEndg[i].Dienst >= 5 && GetVersion() < 192)	// Kombidienst existiert erst ab Version 1.92			mK->mEndg[i].Dienst = 0;	// auf Fernsprechen zurücksetzen!		if(mK->mEndg[i].Rufumleitung > 20) {			mK->mEndg[i].Rufumleitung = CheckGoodApp(mK->mEndg[i].Rufumleitung, true);		}	}	BuildIndexTable();}Boolean		CISTEC::IsISTECData(Handle inH){	StHandleLocker	lock(inH);	UInt32			theSize = GetHandleSize(inH);	switch(theSize) {	case 1450 + 64 * 2:	// 1.93 mit Gebühren	case 1450:	// 1.93 ohne Gebühren	case 1181 + 64 * 2:	// 1.92 oder älter mit Gebühren	case 1184 + 64 * 2:	case 1181:	// 1.92 oder älter ohne Gebühren	case 1184:		return true;	default:				static const char idStr[] = { 'M', 'M', 'M', '!' };				for(int i=0; i<sizeof(idStr); i++) {					if(!idStr[i]) continue;		// Anschlußart & Protokoll nicht vergleichen!					if(idStr[i] != ((char*)*inH)[i])						return false;				}				return true;	}	return false;}void		CISTEC::SetISDNData(Handle inH){	bool			doCopy = true;	if(inH == nil) {		SetDefault();	} else {		StHandleLocker	lock(inH);		UInt32			theSize = GetHandleSize(inH);		UInt16			gebOffset = 0L;		switch(theSize) {		default:				Ptr	thePtr = 4 + *inH;	// Magic skippen				UInt8	theDayNightFlag = thePtr[1023];				mAlarmApp = thePtr[1022];				for(int kk=0; kk<GetConfigCount(); kk++) {					SetConfig(kk);					SetKonfig((const GrundKonfigStruct*)thePtr);					thePtr += 1024;					for(int i=0; i<64; i++) {						::BlockMoveData(thePtr, &mK->mEndg[i], sizeof(EndgeraetekonfigStruct));						thePtr += 512;					}					::BlockMoveData(thePtr, &mK->mGeb, 64 * sizeof(short));					thePtr += 64 * sizeof(short);					// Gebührenwerte anhängen					::BlockMoveData(thePtr, &mK->mKurz, sizeof(mK->mKurz));					thePtr += sizeof(mK->mKurz);					// Endgerätenamen anhängen					::BlockMoveData(thePtr, &mK->mEndgName, sizeof(mK->mEndgName));					thePtr += sizeof(mK->mEndgName);				}				SetConfig(theDayNightFlag);				doCopy = false;				break;		case 1450 + 64 * 2:	// 1.93 mit Gebühren				gebOffset = 1450;		case 1450:	// 1.93 ohne Gebühren				SetKonfig((const GrundKonfigStruct*)*inH);				if(GetVersion() < 100) {					mK->mKonfig.SWVersionHigh = 1;					mK->mKonfig.SWVersionLow = 93;				}				for(int i=0; i<64; i++)					::BlockMoveData(*inH + 106 + 1 + 21 * i, &mK->mEndg[i], 20);				break;		case 1181 + 64 * 2:	// 1.92 oder älter mit Gebühren		case 1184 + 64 * 2:				gebOffset = 1181;		case 1181:	// 1.92 oder älter ohne Gebühren		case 1184:				SetKonfig((const GrundKonfigStruct*)*inH);				for(int i=0; i<64; i++)					::BlockMoveData(*inH + 93 + 1 + 17 * i, &mK->mEndg[i], 16);		}		if(gebOffset > 0L) {			UInt16		iGeb[64];			::BlockMoveData(*inH + gebOffset, &iGeb, 64 * sizeof(short));			// Worte drehen!			for(int i=0; i<64; i++)				mK->mGeb[i] = ((iGeb[i] >> 8) & 0xFF) | (iGeb[i] << 8);		}	}	CheckData();	ExecuteAttachments(msg_AnlageDirty, nil);	if(doCopy)		mKData[1] = mKData[0];}// wir schreiben für die Anlage stets 1kb, für jeden der max. 64 Apparate 1/2kb an Daten.// dazu kommen noch 64 Shorts (die Gebühren)Handle		CISTEC::GetISDNData(){	Handle		h = NewHandleClear((1024L + 512L * 64 + 32 * 64 + 64 * sizeof(short) + sizeof(long) + sizeof(mK->mKurz)) * MAX_CONFIG_COUNT);	ThrowIfMemError_(); ThrowIfNil_(h);	StHandleLocker	lock(h);	Ptr		pp = *h;	// Magic	*((long*)pp)++ = 'MMM!';	pp[1023] = GetConfig();	pp[1022] = mAlarmApp;	for(int kk=0; kk<GetConfigCount(); kk++) {		SetConfig(kk);		// Anlagenkonfiguration		::BlockMoveData(&mK->mKonfig, pp, sizeof(GrundKonfigStruct));		pp += 1024;		// 64 Apparate wegschreiben		for(int j=0; j<64; j++) {			::BlockMoveData(&mK->mEndg[j], pp, sizeof(EndgeraetekonfigStruct));			pp += 512;		}		// Gebührenwerte anhängen		::BlockMoveData(&mK->mGeb, pp, 64 * sizeof(short));		pp += 64 * sizeof(short);		// Kurzwahlen anhängen		::BlockMoveData(&mK->mKurz, pp, sizeof(mK->mKurz));		pp += sizeof(mK->mKurz);		// Endgerätenamen anhängen		::BlockMoveData(&mK->mEndgName, pp, sizeof(mK->mEndgName));		pp += sizeof(mK->mEndgName);	}	SetConfig((*h)[1023]);	return h;}void		CISTEC::GetBCD(char *bcdPtr, short bcdSize, LStr255 &outString){	outString = "";	for(int i=0; i< bcdSize; i++) {		char	c = bcdPtr[i >> 1];		if(i & 1) c >>= 4;		// BCD drehen (Intel-Format!)		c &= 0x0F;		if(c == 0x0F) break;	// Ende der Nummer erkannt		outString += char(c + '0');	}}void		CISTEC::SetBCD(char *bcdPtr, short bcdSize, LStr255 inString){	for(int i=0; i < bcdSize; i++) {		char	c = (i < inString[0]) ? inString[i + 1] : 0x0F;		c &= 0x0F;		char	mask = 0xF0;		if(i & 1) {			mask = ~mask;			c <<= 4;		}		bcdPtr[i >> 1] &= mask;		bcdPtr[i >> 1] |= c;	}}// ---------------------------------------------------------------------------//		• Anlangeinformationen// ---------------------------------------------------------------------------void		CISTEC::UpdateNummern(int anschluss, int protokoll, LWindow *theDialog){	LStr255	s;	if(protokoll == 0 || anschluss == 1) {	// nationales ISDN oder ein Anlagenanschluß		for(int i=9; i>=0; i--) {			LEditField *editNumber = (LEditField*) theDialog->FindPaneByID('MSN0' + i);			FailNIL_(editNumber);			LStdPopupMenu *rufPopup = (LStdPopupMenu*) theDialog->FindPaneByID('MSP0' + i);			FailNIL_(rufPopup);			rufPopup->Disable();			rufPopup->Hide();			if(i == 0 || (GetExtS0() > 1 && i == 1)) {				Str255	s;				switch(i) {				case 0:	s[0] = mK->mKonfig.SizeNumber1;						::BlockMoveData(mK->mKonfig.Number1, &s[1], s[0]);						break;				case 1:	s[0] = mK->mKonfig.SizeNumber2;						::BlockMoveData(mK->mKonfig.Number2, &s[1], s[0]);						break;				}				editNumber->SetDescriptor(s);				LCommander::SwitchTarget(editNumber);	// Cursor ins Feld setzen				editNumber->SelectAll();				// und alles selektieren			} else {				if((i == 4 || i == 5) && anschluss == 1) {					LStr255	s = SInt32(i == 4 ? mK->mKonfig.Abfragestelle1 : mK->mKonfig.Abfragestelle2);					editNumber->Show();					editNumber->Enable();					editNumber->SetDescriptor(s);				} else {					if(i != 1) {						editNumber->Hide();					}					editNumber->Disable();					editNumber->SetDescriptor("\p");				}			}		}		LGroupBox *gbx;		gbx = (LGroupBox*) theDialog->FindPaneByID('GBx0');		FailNIL_(gbx);		gbx->Hide();		gbx = (LGroupBox*) theDialog->FindPaneByID('GBx1');		FailNIL_(gbx);		gbx->Show();		gbx = (LGroupBox*) theDialog->FindPaneByID('GBx2');		FailNIL_(gbx);		if(anschluss == 1) {			gbx->Show();		} else {			gbx->Hide();		}	} else {		LGroupBox *gbx;		gbx = (LGroupBox*) theDialog->FindPaneByID('GBx0');		FailNIL_(gbx);		gbx->Show();		gbx = (LGroupBox*) theDialog->FindPaneByID('GBx1');		FailNIL_(gbx);		gbx->Hide();		gbx = (LGroupBox*) theDialog->FindPaneByID('GBx2');		FailNIL_(gbx);		gbx->Hide();		for(int i=0; i<10; i++) {			LEditField *editNumber = (LEditField*) theDialog->FindPaneByID('MSN0' + i);			FailNIL_(editNumber);			LStdPopupMenu *rufPopup = (LStdPopupMenu*) theDialog->FindPaneByID('MSP0' + i);			FailNIL_(rufPopup);			GetBCD(mK->mKonfig.MSN[i], 10, s);			editNumber->Enable();			editNumber->SetDescriptor(s);			editNumber->Show();			if(i == 0) {				LCommander::SwitchTarget(editNumber);	// Cursor ins Feld setzen				editNumber->SelectAll();				// und alles selektieren			}			if(GetVersion() >= 200)				rufPopup->Enable();			else				rufPopup->Disable();			int	menuVal = 1;			switch(mK->mKonfig.SonderRuf[i]) {			case 1:	menuVal = 2; break;			case 2:	menuVal = 3; break;			case 3:	menuVal = 5; break;			case 4:	menuVal = 4; break;			}			rufPopup->SetValue(menuVal);			rufPopup->Show();		}	}}void		CISTEC::AnlageInfoDialog(){	StDialogHandler	theHandler(1000, this);	LWindow		*theDialog = theHandler.GetDialog();	FailNIL_(theDialog);	LCaption *str = (LCaption*) theDialog->FindPaneByID('Anla');	FailNIL_(str);	LStr255	s;	GetAnlagenName(s);	str->SetDescriptor(s);	str = (LCaption*) theDialog->FindPaneByID('SWVe');	FailNIL_(str);	GetVersionStr(s);	str->SetDescriptor(s);	str = (LCaption*) theDialog->FindPaneByID('S0ex');	FailNIL_(str);	str->SetDescriptor((LStr255)(GetExtS0()));	str = (LCaption*) theDialog->FindPaneByID('S0in');	FailNIL_(str);	str->SetDescriptor((LStr255)(GetIntS0()));	str = (LCaption*) theDialog->FindPaneByID('abSc');	FailNIL_(str);	str->SetDescriptor((LStr255)(GetAB()));	LStdPopupMenu	*spop1 = (LStdPopupMenu*) theDialog->FindPaneByID('Ansc');	FailNIL_(spop1);	if(GetAppCount() > 8)		spop1->Disable();	int		anschluss = mK->mKonfig.Anschlussart;	spop1->SetValue(anschluss + 1);	int		protokoll = mK->mKonfig.Protokoll;	LStdPopupMenu	*spop2 = (LStdPopupMenu*) theDialog->FindPaneByID('Prot');	FailNIL_(spop2);	spop2->SetValue(protokoll + 1);	SInt32	abfr1 = mK->mKonfig.Abfragestelle1;	SInt32	abfr2 = mK->mKonfig.Abfragestelle2;	UpdateNummern(anschluss, protokoll, theDialog);	LEditField *VorwNumber = (LEditField*) theDialog->FindPaneByID('Vorw');	FailNIL_(VorwNumber);	// Landesvorwahl	LStdPopupMenu	*theLandPopup = (LStdPopupMenu*) theDialog->FindPaneByID('VorM');	FailNIL_(theLandPopup);	SInt32		Vorw = mK->mKonfig.NationalCode[0] + mK->mKonfig.NationalCode[1] * 256;	VorwNumber->SetDescriptor(LStr255(Vorw));	if(GetVersion() < 193) {		VorwNumber->Disable();		theLandPopup->Disable();	}	LStdPopupMenu	*spop3 = (LStdPopupMenu*) theDialog->FindPaneByID('Musi');	FailNIL_(spop3);	SInt32	spop3Val = 1;	if(mK->mKonfig.MusicOnHold)		spop3Val = 2;	if(GetVersion() < 193) {		MenuRef		mref = spop3->GetMacMenuH();		for(int i=4; i<100; i++)			::DisableItem(mref, i);	} else if(mK->mKonfig.MessageOnHold >= 1 && mK->mKonfig.MessageOnHold <= 8)		spop3Val = mK->mKonfig.MessageOnHold - 1 + 4;	spop3->SetValue(spop3Val);	LStdPopupMenu *TFEType = (LStdPopupMenu*) theDialog->FindPaneByID('TFE ');	FailNIL_(TFEType);	if(GetVersion() < 200) {		DisableItem(TFEType->GetMacMenuH(), 3);	}	if(GetVersion() < 193) {		if(mK->mKonfig.TFEZuordnung == 0) mK->mKonfig.TFEZuordnung = 21;		DisableItem(TFEType->GetMacMenuH(), 2);	}	TFEType->SetValue(mK->mKonfig.TFEZuordnung != 0 ? 1 : 2);	if(mAlarmApp) TFEType->SetValue(3);	theDialog->Show();	while (true) {					// Let DialogHandler process events		// diese längere Routine sucht in den Popupmenüs nach einer passenden Vorwahl		// und wählt entsprechend den richtigen Menüpunkt		VorwNumber->GetDescriptor(s);		LStr255	theTempStr;		::GetMenuItemText(theLandPopup->GetMacMenuH(), theLandPopup->GetValue(), theTempStr);		UInt8	theStartPos = theTempStr.Find('(');		UInt8	theEndPos = theTempStr.Find(')');		if(theStartPos == 0 || s != theTempStr(theStartPos + 1, theEndPos - theStartPos - 1)) {			bool	theFoundFlag = false;			for(SInt32 theIndex=1; theIndex<9999; theIndex++) {				if(theIndex == 1) ::DisableItem(theLandPopup->GetMacMenuH(), 1);				LStr255	theItemStr = "\p";				::GetMenuItemText(theLandPopup->GetMacMenuH(), theIndex, theItemStr);				if(theItemStr.Length() == 0) break;		// Ende der Liste				UInt8	theStartPos = theItemStr.Find('(');				UInt8	theEndPos = theItemStr.Find(')');				if(s != theItemStr(theStartPos + 1, theEndPos - theStartPos - 1))					continue;				theLandPopup->SetValue(theIndex);				theFoundFlag = true;				break;			}			if(!theFoundFlag)				theLandPopup->SetValue(1);	// auf unbekannt setzen		}		MessageT	hitMessage = theHandler.DoDialog();		// Orts- bzw. Landesvorwahl-Popup verändert		if(hitMessage == 'VorM') {			LStr255	theItemStr;			::GetMenuItemText(theLandPopup->GetMacMenuH(), theLandPopup->GetValue(), theItemStr);			UInt8	theStartPos = theItemStr.Find('(');			if(theStartPos > 0) {				UInt8	theEndPos = theItemStr.Find(')');				VorwNumber->SetDescriptor(theItemStr(theStartPos + 1, theEndPos - theStartPos - 1));				LCommander::SwitchTarget(VorwNumber);	// Cursor ins Feld setzen				VorwNumber->SelectAll();				// und alles selektieren			}		}		if((spop2->GetValue() - 1) != protokoll) {			protokoll = spop2->GetValue() - 1;			UpdateNummern(anschluss, protokoll, theDialog);			continue;		} else if((spop1->GetValue() - 1) != anschluss) {			anschluss = spop1->GetValue() - 1;			UpdateNummern(anschluss, protokoll, theDialog);			continue;		} else if (hitMessage == 'TFES') {			static SInt16	theDialogIDs[] = { 0, 1002, 1001, 1003 };			SInt32		theId = theDialogIDs[TFEType->GetValue()];			StDialogHandler	theSubHandler(theId, this);			LWindow		*theSubDialog = theSubHandler.GetDialog();			FailNIL_(theSubDialog);			LEditField		*TFENumber;			LStdPopupMenu	*TPopup;			switch(theId) {			case 1001:	// 1.93				for(SInt32 k=0; k<4; k++) {	// 4 Knöpfe					for(SInt32 i=0; i<8; i++) {	// 8 Apparate						LStdCheckBox	*chk = (LStdCheckBox*)theSubDialog->FindPaneByID('K121' + (k << 16) + i);						FailNIL_(chk);						chk->SetValue((mK->mKonfig.TFELocation[k] & (1 << i)) ? 1 : 0);					}				}				break;			case 1002:	// <1.93				TFENumber = (LEditField*)theSubDialog->FindPaneByID('TFEv');				FailNIL_(TFENumber);				TFENumber->SetDescriptor(LStr255(SInt32(CheckGoodApp(mK->mKonfig.TFEZuordnung))));				break;			case 1003:	// 2.0				TPopup = (LStdPopupMenu*)theSubDialog->FindPaneByID('Alrm');				FailNIL_(TFENumber);				if(mAlarmApp == 0) mAlarmApp = 21;				TPopup->SetValue(mAlarmApp - 20);				break;			}			theSubDialog->Show();			while (true) {					// Let DialogHandler process events				MessageT	hitMessage = theSubHandler.DoDialog();				if (hitMessage == msg_Cancel) {					break;				} else if(hitMessage == msg_OK) {					switch(theId) {					case 1001:	// 1.93						mK->mKonfig.TFEZuordnung = 0;						for(SInt32 k=0; k<4; k++) {	// 4 Knöpfe							mK->mKonfig.TFELocation[k] = 0;							for(SInt32 i=0; i<8; i++) {	// 8 Apparate								LStdCheckBox	*chk = (LStdCheckBox*)theSubDialog->FindPaneByID('K121' + (k << 16) + i);								FailNIL_(chk);								if(chk->GetValue())									mK->mKonfig.TFELocation[k] |= 1 << i;							}						}						mAlarmApp = 0;						SetDirty();						break;					case 1002:	// <1.93						TFENumber->GetDescriptor(s);						SInt32		newTFE = SInt32(s);						if(mK->mKonfig.TFEZuordnung != newTFE) {							mK->mKonfig.TFEZuordnung = CheckGoodApp(newTFE);							SetDirty();						}						mAlarmApp = 0;						break;					case 1003:	// 2.0						if(TPopup->GetValue() != (mAlarmApp - 20)) {							mAlarmApp = TPopup->GetValue() + 20;							SetDirty();						}						break;					}					break;				}			}		} else if (hitMessage == msg_Cancel) {			break;		} else if (hitMessage == msg_OK) {			bool	theDoUpdate = false;			switch(TFEType->GetValue()) {			case 1:	// Emmerich					if(mK->mKonfig.TFEZuordnung == 0) {						mK->mKonfig.TFEZuordnung = CheckGoodApp(mK->mKonfig.TFEZuordnung);						SetDirty();					}					break;			case 2:	// Telekom					if(mK->mKonfig.TFEZuordnung) {						mK->mKonfig.TFEZuordnung = 0;						SetDirty();					}					break;			}			VorwNumber->GetDescriptor(s);			SInt32		newVorw = SInt32(s);			if(GetVersion() >= 193 && Vorw != newVorw) {				Vorw = newVorw;				SetDirty();				mK->mKonfig.NationalCode[0] = Vorw & 0xFF;				mK->mKonfig.NationalCode[1] = Vorw >> 8;			}			if(mK->mKonfig.Anschlussart != (spop1->GetValue() - 1)) {				SetDirty();				mK->mKonfig.Anschlussart = spop1->GetValue() - 1;				theDoUpdate = true;			}			if(mK->mKonfig.Protokoll != (spop2->GetValue() - 1)) {				SetDirty();				mK->mKonfig.Protokoll = spop2->GetValue() - 1;				if(GetIntS0() > 0)					theDoUpdate = true;			}			if(spop3Val != spop3->GetValue()) {				spop3Val = spop3->GetValue();				SetDirty();				switch(spop3Val) {				case 1:	mK->mKonfig.MusicOnHold = 0;						mK->mKonfig.MessageOnHold = 0;						break;				case 2:	mK->mKonfig.MessageOnHold = 0;						mK->mKonfig.MusicOnHold = 1;						break;				case 3:	break;				default:mK->mKonfig.MessageOnHold = spop3Val - 4 + 1;						mK->mKonfig.MusicOnHold = 0;						break;				}				theDoUpdate = true;			}			if(protokoll == 0 || anschluss == 1) {	// nationales ISDN oder ein Anlagenanschluß				LEditField *editNumber = (LEditField*) theDialog->FindPaneByID('MSN0');				FailNIL_(editNumber);				editNumber->GetDescriptor(s);				if(!BlocksAreEqual(&mK->mKonfig.SizeNumber1, s, s[0])) {					mK->mKonfig.SizeNumber1 = s.Length();					BlockFill(mK->mKonfig.Number1, 0, 10);					::BlockMoveData(&s[1], mK->mKonfig.Number1, s.Length());					SetDirty();				}				if(GetExtS0() > 1) {					LEditField *editNumber = (LEditField*) theDialog->FindPaneByID('MSN1');					FailNIL_(editNumber);					editNumber->GetDescriptor(s);					if(!BlocksAreEqual(&mK->mKonfig.SizeNumber2, s, s[0])) {						mK->mKonfig.SizeNumber2 = s.Length();						BlockFill(mK->mKonfig.Number2, 0, 10);						::BlockMoveData(&s[1], mK->mKonfig.Number2, s.Length());						SetDirty();					}				}				editNumber = (LEditField*) theDialog->FindPaneByID('MSN4');				FailNIL_(editNumber);				editNumber->GetDescriptor(s);				SInt32	abfrNeu = SInt32(s);				if(abfr1 != abfrNeu) {					mK->mKonfig.Abfragestelle1 = CheckGoodApp(abfrNeu);					SetDirty();				}				editNumber = (LEditField*) theDialog->FindPaneByID('MSN5');				FailNIL_(editNumber);				editNumber->GetDescriptor(s);				abfrNeu = SInt32(s);				if(abfr2 != abfrNeu) {					mK->mKonfig.Abfragestelle2 = CheckGoodApp(abfrNeu);					SetDirty();				}			} else {				for(int i=0; i<10; i++) {					LEditField *editNumber = (LEditField*) theDialog->FindPaneByID('MSN0' + i);					FailNIL_(editNumber);					editNumber->GetDescriptor(s);					LStr255	stemp;					GetBCD(mK->mKonfig.MSN[i], 10, stemp);					if(s != stemp) {						SetBCD(mK->mKonfig.MSN[i], 10, s);						SetDirty();					}					LStdPopupMenu *rufPopup = (LStdPopupMenu*) theDialog->FindPaneByID('MSP0' + i);					FailNIL_(rufPopup);					int	menuVal = 0;					switch(rufPopup->GetValue()) {					case 1: menuVal = 0; break;					case 2:	menuVal = 1; break;					case 3:	menuVal = 2; break;					case 4:	menuVal = 4; break;					case 5:	menuVal = 3; break;					}					if(mK->mKonfig.SonderRuf[i] != menuVal) {						mK->mKonfig.SonderRuf[i] = menuVal;						SetDirty();					}				}			}			CheckData();			if(theDoUpdate)				ExecuteAttachments(msg_AnlageDirty, nil);			break;		}	}}// ---------------------------------------------------------------------------//		• Endgeräteinformationen// ---------------------------------------------------------------------------void		CISTEC::GeraetInfoDialog(short geraet){	geraet = GetAppNo(geraet);	bool	digital = (geraet >= 51);	int	index;	if(geraet >= 21 && geraet < 51) index = geraet - 21;	else if(geraet >= 51 && geraet < 91) index = geraet - 51 + 24;	EndgeraetekonfigStruct	*eks = &mK->mEndg[index];	StDialogHandler	theHandler(1500, this);	LWindow		*theDialog = theHandler.GetDialog();	// Gerätenummer an den Fenstertitel hängen	LStr255	titel;	theDialog->GetDescriptor(titel);	titel += LStr255(SInt32(geraet));	LStr255	s;	GetIndString(s, 1000, !digital ? 5 : 6);	titel += s;	theDialog->SetDescriptor(titel);	LEditField		*editName = (LEditField*)theDialog->FindPaneByID('Enam');	FailNIL_(editName);	LStr255	theGName;	GetAppName(index, theGName);	editName->SetDescriptor(theGName);	theDialog->SetLatentSub(editName);	editName->SelectAll();	for(int i=0; i<10; i++) {		LStdCheckBox	*schk = (LStdCheckBox*)theDialog->FindPaneByID('msn0' + i);		FailNIL_(schk);		LStr255		s;		if(mK->mKonfig.Protokoll == 0) {	// nationales ISDN			GetIndString(s, 1000, 4);			s += LStr255(SInt32(i));		} else {			GetBCD(mK->mKonfig.MSN[i], 10, s);			if(s.Length() == 0) {				GetIndString(s, 1000, 3);				schk->Disable();			}		}		if(mK->mKonfig.Anschlussart == 0) {			schk->SetValue((mK->mKonfig.MSNGroup[i] >> index) & 1);		} else {			GetIndString(s, 1000, 3);			schk->Disable();		}		schk->SetDescriptor(s);	}	LStdPopupMenu	*spop1 = (LStdPopupMenu*)theDialog->FindPaneByID('Wahl');	FailNIL_(spop1);	LStdPopupMenu	*spop2 = (LStdPopupMenu*)theDialog->FindPaneByID('Dien');	FailNIL_(spop2);	LStdCheckBox	*schk1 = (LStdCheckBox*)theDialog->FindPaneByID('GebI');	FailNIL_(schk1);	if(!digital) {		spop1->SetValue(eks->Wahlbewertung + 1);		spop2->SetValue(eks->Dienst + 1);		// Erst Version 1.92 kennt den Kombidienst		if(GetVersion() < 192) {			MenuRef		mref = spop2->GetMacMenuH();			DisableItem(mref, 6);		}		schk1->SetValue(eks->Gebuehrenimpuls);	} else {		spop1->Disable();		spop2->Disable();		schk1->SetValue(1);		schk1->Disable();	}	LStdCheckBox	*schk2 = (LStdCheckBox*)theDialog->FindPaneByID('Spon');	FailNIL_(schk2);	if(GetVersion() >= 193 && mK->mKonfig.Anschlussart == 0) {		schk2->SetValue(eks->TerminalMode);	} else {		schk2->SetValue(0);		schk2->Disable();	}	LStdCheckBox	*schk3 = (LStdCheckBox*)theDialog->FindPaneByID('AInt');	FailNIL_(schk3);	LStdCheckBox	*schk4 = (LStdCheckBox*)theDialog->FindPaneByID('AExt');	FailNIL_(schk4);	// nur bei ROM 1.95 und Dienstkennung = Fernsprechen, Anrufbeantworter oder Kombidienst	if(GetVersion() >= 200 && eks->Dienst == 0 || eks->Dienst == 4 || eks->Dienst == 5) {		schk3->SetValue(eks->AnklopfenApp != 0);		schk4->SetValue(eks->AnklopfenMSN1 != 0 || eks->AnklopfenMSN2 != 0);	} else {		schk3->Disable();		schk4->Disable();	}	LEditField		*rufzielNumber = (LEditField*)theDialog->FindPaneByID('RufN');	FailNIL_(rufzielNumber);	LStdRadioButton	*radio0 = (LStdRadioButton*)theDialog->FindPaneByID('Rum0');	FailNIL_(radio0);	LStdRadioButton	*radio1 = (LStdRadioButton*)theDialog->FindPaneByID('Rum1');	FailNIL_(radio1);	LStdRadioButton	*radio2 = (LStdRadioButton*)theDialog->FindPaneByID('Rum2');	FailNIL_(radio2);	LStdRadioButton	*radio3 = (LStdRadioButton*)theDialog->FindPaneByID('Rum3');	FailNIL_(radio3);	LEditField		*rufcountNumber = (LEditField*)theDialog->FindPaneByID('RufX');	FailNIL_(rufcountNumber);	LStr255	nummer;	GetBCD(eks->UmlRufnummer, sizeof(eks->UmlRufnummer) << 1, nummer);	int			rufUmlInitValue = 0;	switch(eks->Rufumleitung) {	case 0:		// aus				radio0->SetValue(1);				break;	case 1:		// extern				radio1->SetValue(1);				rufUmlInitValue = 1;				break;	default:	// intern				nummer = SInt32(eks->Rufumleitung);				radio1->SetValue(1);				rufUmlInitValue = 1;				break;	}	if(GetVersion() < 200) {		radio2->Disable();		radio3->Disable();		rufcountNumber->Disable();	} else {		if(eks->UmlBesetzt) {			radio2->SetValue(1);			nummer = SInt32(eks->UmlBesetzt) + 20;			rufUmlInitValue = 2;		} else if(eks->UmlAnzRufseq) {			radio3->SetValue(1);			nummer = SInt32(eks->UmlAnzRufseq) + 20;			rufUmlInitValue = 3;		}	}	rufzielNumber->SetDescriptor(nummer);	rufcountNumber->SetValue(eks->AnzRufseq);	LEditField		*editPIN = (LEditField*)theDialog->FindPaneByID('PINn');	FailNIL_(editPIN);	LStr255			pin;	GetBCD(eks->PIN, sizeof(eks->PIN) << 1, pin);	editPIN->SetDescriptor(pin);	theDialog->Show();	while (true) {					// Let DialogHandler process events		MessageT	hitMessage = theHandler.DoDialog();		if (hitMessage == msg_Cancel) {			break;		} else if (hitMessage == msg_OK) {			bool	theDoUpdate = false;			if(eks->TerminalMode != schk2->GetValue()) {				SetDirty();				eks->TerminalMode = schk2->GetValue();			}			if(!digital && eks->Gebuehrenimpuls != schk1->GetValue()) {				SetDirty();				eks->Gebuehrenimpuls = schk1->GetValue();			}			if(!digital && eks->Wahlbewertung != (spop1->GetValue() - 1)) {				SetDirty();				eks->Wahlbewertung = spop1->GetValue() - 1;			}			if(!digital && eks->Dienst != (spop2->GetValue() - 1)) {				SetDirty();				eks->Dienst = spop2->GetValue() - 1;				theDoUpdate = true;			}			if(!digital && (eks->AnklopfenApp != 0) != schk3->GetValue()) {				SetDirty();				eks->AnklopfenApp = schk3->GetValue() ? 0xFF : 0x00;			}			if(!digital && (eks->AnklopfenMSN1 != 0 || eks->AnklopfenMSN2 != 0) != schk4->GetValue()) {				SetDirty();				eks->AnklopfenMSN1 = schk4->GetValue() ? 0xFF : 0x00;				eks->AnklopfenMSN2 = schk4->GetValue() ? 0xFF : 0x00;			}			int		umlValue = 0;			if(radio1->GetValue()) umlValue = 1;			if(radio2->GetValue()) umlValue = 2;			if(radio3->GetValue()) umlValue = 3;			LStr255	nummerNeu;			rufzielNumber->GetDescriptor(nummerNeu);			if(nummerNeu != nummer || rufUmlInitValue != umlValue) {				int		intRufNo;				if(nummerNeu.Length() == 0 || (nummerNeu.Length() == 1 && SInt32(nummerNeu) == 0)) {					intRufNo = 0;					eks->ZiffLenUml = 0;				} else if(nummerNeu.Length() > 2) {					SetBCD(eks->UmlRufnummer, sizeof(eks->UmlRufnummer) << 1, nummerNeu);					eks->ZiffLenUml = nummerNeu.Length();					intRufNo = 0;				} else {					intRufNo = CheckGoodApp(SInt32(nummerNeu), true);				}				eks->Rufumleitung = 0;				eks->UmlBesetzt = 0;				eks->UmlAnzRufseq = 0;				if(intRufNo) {					switch(umlValue) {					case 0: // keine							break;					case 1: // sofort							eks->Rufumleitung = intRufNo;							break;					case 2: // bei Besetzt							eks->UmlBesetzt = intRufNo - 20;							break;					case 3: // nach x Rufzeichen							eks->UmlAnzRufseq = intRufNo - 20;							break;					}				} else if(eks->ZiffLenUml) {					eks->Rufumleitung = 1;				}				SetDirty();			}			int		rufcount = rufcountNumber->GetValue();			if(rufcount != eks->AnzRufseq) {				eks->AnzRufseq = rufcount;				SetDirty();			}			LStr255	pinNeu;			editPIN->GetDescriptor(pinNeu);			if(pinNeu != pin) {				SetBCD(eks->PIN, sizeof(eks->PIN) << 1, pinNeu);				SetDirty();			}			LStr255	nameNeu;			editName->GetDescriptor(nameNeu);			if(nameNeu != theGName) {				SetAppName(index, nameNeu);				theDoUpdate = true;				SetDirty();			}			if(mK->mKonfig.Anschlussart == 0) {				for(int i=0; i<10; i++) {					LStdCheckBox	*schk = (LStdCheckBox*)theDialog->FindPaneByID('msn0' + i);					FailNIL_(schk);					if(schk->GetValue() == ((mK->mKonfig.MSNGroup[i] >> index) & 1))						continue;					SetDirty();					mK->mKonfig.MSNGroup[i] &= ~(1 << index);					if(schk->GetValue())						mK->mKonfig.MSNGroup[i] |= (1 << index);					theDoUpdate = true;				}			}			CheckData();			if(theDoUpdate)				ExecuteAttachments(msg_AnlageDirty, nil);			break;		}	}}/*** *	Befehl von der Istec erwarten ***///#include <stdio.h>OSErr		CISTEC::GetCommand(StringPtr cmd, short &len, short maxLen, unsigned short timeout){unsigned long	time = (unsigned long)TickCount() + timeout;	len = 0;		// bisher: 0 Bytes gelesen	do {		unsigned char	buf[4];		int				i = 1;		buf[0] = 0;					// Längenbyte löschen		if(mSd->Read(buf, 4) == 4) {	// immer 4 Byte-Blöcke lesen			// Timeout bei erhaltenem Block verlängern!			time = (unsigned long)TickCount() + timeout;//			printf("<$%2.2x,$%2.2x,$%2.2x,$%2.2x>\n", buf[0], buf[1], buf[2], buf[3]);			for(int j = buf[0] & 0x03; j>0; j--) {	// Länge auswerten				if(maxLen <= len) return memFullErr;				cmd[len++] = buf[i++];			}			if(buf[0] & 0x80) break;	// letzter Block? => raus		}		if(time < (unsigned long)TickCount()) return ioErr;	// Timeout!	} while(1);	return noErr;}/*** *	Befehl an die Istec senden ***/OSErr		CISTEC::SendCommand(StringPtr cmd, short len){	while(len > 0) {		unsigned char	buf[4];		buf[0] = len <= 3 ? len : 3;		buf[1] = buf[2] = buf[3] = 0x00;		if(--len >= 0) buf[1] = *cmd++;		if(--len >= 0) buf[2] = *cmd++;		if(--len >= 0) buf[3] = *cmd++;		if(len <= 0) buf[0] |= 0x80;		// Befehlsblock in 1 Byte Länge + 3 Bytes Päckchen übertragen		mSd->Write(buf, 4);//		printf("«$%2.2x,$%2.2x,$%2.2x,$%2.2x»\n", buf[0], buf[1], buf[2], buf[3]);		UInt32	time;		Delay(3, &time);	// min. 40ms Pause	}	UInt32	time;	Delay(4, &time);		// nochmals min. 60ms Pause	return noErr;}/*** *	ISTEC auslesen ***/void		CISTEC::Auslesen(){	try{		Str255			cmd;		OSErr			iErr;		short			len;		GrundKonfigStruct	iKonfig;		EndgeraetekonfigStruct	iEndg[64];		KurzwahlKonfigStruct		iKurz[ISTEC_ANZ_KW_NR];		UInt16				iGeb[64];		BlockFill(&iKonfig, 0x00, sizeof(iKonfig));		BlockFill(&iEndg, 0x00, sizeof(iEndg));		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err.GetErrorCode(), 130);			return;		} 		CursHandle	theCursH = ::GetCursor(watchCursor);		if (theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		cmd[0] = 0x02;					// Bereitschaft prüfen		cmd[1] = 0x02; cmd[2] = 0x00;	// Version 2.0 (neu, stört aber auch alte Anlagen nicht)		SendCommand(cmd, 3);		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr || len != 1 || cmd[0] != 0x12)			ThrowOSErr_(ioErr);		// (a) Test, ob wir eine neue Anlage mit 2er ROM haben		cmd[0] = 0xcc;	// CTI_START		cmd[1] = 0x06;	// CTI_QUERY		cmd[2] = 0x07;	// CTI_DAY_NIGHT		cmd[3] = 0xff;	// CTI_STOP		SendCommand(cmd, 4);		iErr = GetCommand(cmd, len, sizeof(cmd));		bool	isAnlage20 = true;		bool	isDayNightFlag = false;		if(iErr != noErr || cmd[0] != 0xcc)			isAnlage20 = false;		// noch eine alte Anlage!		else			isDayNightFlag = cmd[3];		ProgressBar	pb(1000, 1, isAnlage20 ? (1 + (3 + 8) * 2 + ISTEC_ANZ_KW_NR) : (64 + 4));		int			progressIndex = 1;		pb.Set(progressIndex++);		// Alarm Flag lesen		mAlarmApp = 0;		if(isAnlage20) {			cmd[0] = 0xcc;	// CTI_START			cmd[1] = 0x06;	// CTI_QUERY			cmd[2] = 0x05;	// CTI_ALARM			cmd[3] = 0xff;	// CTI_STOP			SendCommand(cmd, 4);			iErr = GetCommand(cmd, len, sizeof(cmd));			if(iErr == noErr && cmd[0] == 0xcc) {				mAlarmApp = cmd[3];				if(mAlarmApp) mAlarmApp += 20;			}		}		// Tag/Nacht-Settings bei 2er Anlage lesen		for(int theConfig=GetConfigCount()-1; theConfig>=0; theConfig--) {			SetConfig(theConfig);			if(isAnlage20) {				cmd[0] = 0xcc;					// Tag/Nacht-Schaltung				cmd[1] = 0x05;				cmd[2] = 0x07;				cmd[3] = theConfig;				cmd[4] = 0xff;				SendCommand(cmd, 5);				iErr = GetCommand(cmd, len, sizeof(cmd));				if(iErr != noErr || len != 5 || cmd[0] != 0xcc) {					theConfig = 999;					break;				}			}			pb.Set(progressIndex++);			cmd[0] = 0x0A;					// Abfrage Grundkonfiguration			SendCommand(cmd, 1);			iErr = GetCommand(cmd, len, sizeof(cmd));			if(iErr != noErr || cmd[0] != 0x17) ThrowOSErr_(ioErr);			::BlockMoveData(cmd + 1, &iKonfig, sizeof(GrundKonfigStruct));			pb.Set(progressIndex++);			cmd[0] = 0x06;					// Abfrage Gebührenzaehler			SendCommand(cmd, 1);			iErr = GetCommand(cmd, len, sizeof(cmd));			short willLen = isAnlage20 ? 17 : 129;			if(iErr != noErr || len != willLen || cmd[0] != 0x15) ThrowOSErr_(ioErr);			::BlockMoveData(cmd + 1, &iGeb, sizeof(iGeb));			pb.Set(progressIndex++);			cmd[0] = 0x08;					// Abfrage Endgerätekonfiguration			SendCommand(cmd, 1);			UInt32	theAppCount = 64;			if(iKonfig.Anz_intS0Bus == 0)	// ISTEC 1003 oder ISTEC 1008?				theAppCount = 8;			if(!isAnlage20)				pb.SetMax(theAppCount + 3);			for(int i=0; i<theAppCount; i++) {				pb.Set(progressIndex++);				iErr = GetCommand(cmd, len, sizeof(cmd));				if(iErr != noErr || cmd[0] != 0x16) ThrowOSErr_(ioErr);				::BlockMoveData(cmd + 2, &iEndg[cmd[1]], sizeof(EndgeraetekonfigStruct));			}			// Daten nur übertragen, wenn kein Fehler aufgetreten ist!			SetKonfig(&iKonfig);			::BlockMoveData(iEndg, mK->mEndg, sizeof(mK->mEndg));			// Worte drehen!			for(int i=0; i<64; i++)				mK->mGeb[i] = ((iGeb[i] >> 8) & 0xFF) | (iGeb[i] << 8);			SetDirty();			CheckData();		}		if(isAnlage20) {			SetConfig(0);			::BlockMoveData(&mK->mKurz, iKurz, sizeof(iKurz));			cmd[0] = 0xcc;		// Tag/Nacht-Schaltung			cmd[1] = 0x05;			cmd[2] = 0x07;			cmd[3] = 0x00;			cmd[4] = 0xff;			SendCommand(cmd, 5);			GetCommand(cmd, len, sizeof(cmd));			// alte Namen etc. übernehmen!			for(int ii=0; ii<ISTEC_ANZ_KW_NR; ii++) {				cmd[0] = 0xcc;	// CTI_START				cmd[1] = 0x06;	// CTI_QUERY				cmd[2] = 0x03;	// CTI_LOAD_NUMBER				cmd[3] = ii+1;	// Speicherstelle				cmd[4] = 0xff;	// CTI_STOP				SendCommand(cmd, 5);				iErr = GetCommand(cmd, len, sizeof(cmd));				if(iErr == noErr && cmd[0] == 0xcc && cmd[1] == 0x08 && cmd[3] == (ii+1)) {					LStr255	theNum;					int	index = 5 + ((cmd[4] + 1) >> 1);					char *bcdPtr = (char*)cmd + 5;					short	bcdSize = cmd[4];					for(int i=0; i< bcdSize; i++) {						char	c = bcdPtr[i >> 1];						if(!(i & 1)) c >>= 4;	// BCD drehen (Intel-Format!)						c &= 0x0F;						if(c == 0x0F) break;	// Ende der Nummer erkannt						theNum += char(c + '0');					}					LString::CopyPStr(theNum, iKurz[ii].RufNr, 21);					if(theNum.Length() == 0)			// keine Nummer?						iKurz[ii].Namen[0] = 0;			// => Namen löschen					iKurz[ii].Babyruf = cmd[index++];					iKurz[ii].Tin = cmd[index++];					iKurz[ii].Sonderruf = cmd[index++];					iKurz[ii].Sperre = cmd[index++];					pb.Set(progressIndex++);				} else {					ThrowOSErr_(ioErr);					break;				}			}			::BlockMoveData(iKurz, &mK->mKurz, sizeof(iKurz));			cmd[0] = 0xcc;					// Tag/Nacht-Schaltung auf alten Wert zurücksetzen			cmd[1] = 0x05;			cmd[2] = 0x07;			cmd[3] = isDayNightFlag;			cmd[4] = 0xff;			SendCommand(cmd, 5);			iErr = GetCommand(cmd, len, sizeof(cmd));			SetConfig(isDayNightFlag);		}		InitCursor();		mSd = 0L;		ExecuteAttachments(msg_AnlageDirty, nil);	}	catch(LException err) {		ErrorAlert(err.GetErrorCode());	} }/*** *	ISTEC wegschreiben ***/#if !DEMO_VERSIONvoid		CISTEC::Senden(){	try{		Str255			cmd;		OSErr			iErr;		short			len;		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err.GetErrorCode(), 130);			return;		} 		int	theAppCount = 64;				// 64 Apparate übertragen		if(GetAnlagenTyp() <= 1008)			// ISTEC 1003 oder ISTEC 1008?			theAppCount = 8;				// dann nur 8 Apparate senden!		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		cmd[0] = 0x02;					// Bereitschaft prüfen		cmd[1] = 0x02; cmd[2] = 0x00;	// Version 2.0 (neu, stört aber auch alte Anlagen nicht)		SendCommand(cmd, 3);		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr || len != 1 || cmd[0] != 0x12) ThrowOSErr_(ioErr);		// (a) Test, ob wir eine neue Anlage mit 2er ROM haben		cmd[0] = 0xcc;	// CTI_START		cmd[1] = 0x06;	// CTI_QUERY		cmd[2] = 0x07;	// CTI_DAY_NIGHT		cmd[3] = 0xff;	// CTI_STOP		SendCommand(cmd, 4);		iErr = GetCommand(cmd, len, sizeof(cmd));		bool	isAnlage20 = true;		if(iErr != noErr || cmd[0] != 0xcc)			isAnlage20 = false;		// noch eine alte Anlage!		if(!isAnlage20) {			cmd[0] = 0x02;				// Bereitschaft prüfen			SendCommand(cmd, 1);			iErr = GetCommand(cmd, len, sizeof(cmd));			if(iErr != noErr || len != 1 || cmd[0] != 0x12) ThrowOSErr_(ioErr);		}		ProgressBar	pb(1000, 2, isAnlage20 ? ((1 + theAppCount) * 2 + 1 + ISTEC_ANZ_KW_NR) : (2 + theAppCount));		// Worte drehen!		UInt16		iGeb[64];		for(int i=0; i<64; i++)			iGeb[i] = ((mK->mGeb[i] >> 8) & 0xFF) | (mK->mGeb[i] << 8);		cmd[0] = 0x05;					// Gebührenzaehler wegschreiben		::BlockMoveData(&iGeb, cmd + 1, 128);		SendCommand(cmd, GetVersion() >= 200 ? 17 : 129);		pb.Set(1);		// Tag/Nacht-Settings bei 2er Anlage lesen		int	progressIndex = 2;		for(int theConfig=GetConfigCount()-1; theConfig>=0; --theConfig) {			SetConfig(theConfig);			if(isAnlage20) {				cmd[0] = 0xcc;					// Tag/Nacht-Schaltung				cmd[1] = 0x05;				cmd[2] = 0x07;				cmd[3] = theConfig;				cmd[4] = 0xff;				SendCommand(cmd, 5);				iErr = GetCommand(cmd, len, sizeof(cmd));				if(iErr != noErr || len != 5 || cmd[0] != 0xcc) {					theConfig = 999;					break;				}			}			cmd[0] = 0x09;					// Grundkonfiguration senden			::BlockMoveData(&mK->mKonfig, cmd + 1, sizeof(mK->mKonfig));			SendCommand(cmd, GetKonfigSize() + 1);			pb.Set(progressIndex++);			for(int i=0; i<theAppCount; i++) {				cmd[0] = 0x07;				// Endgerätekonfiguration setzen				cmd[1] = i;				::BlockMoveData(&mK->mEndg[i], cmd + 2, sizeof(mK->mEndg[0]));				SendCommand(cmd, GetEndgSize() + 2);				iErr = GetCommand(cmd, len, sizeof(cmd));				if(iErr != noErr /*|| len != 2 || cmd[0] != 0x18 || cmd[1] != i*/) ThrowOSErr_(ioErr);				pb.Set(progressIndex++);			}		}		if(isAnlage20) {			cmd[0] = 0xcc;	// CTI_START			cmd[1] = 0x05;	// CTI_CONF			cmd[2] = 0x05;	// CTI_ALARM			cmd[3] = mAlarmApp ? mAlarmApp - 20 : 0;			cmd[4] = 0xff;	// CTI_STOP			SendCommand(cmd, 5);			GetCommand(cmd, len, sizeof(cmd));			int		saveConfig = GetConfig();			SetConfig(0);			for(int ii=0; ii<ISTEC_ANZ_KW_NR; ii++) {				int	count = 5;				cmd[0] = 0xcc;	// CTI_START				cmd[1] = 0x05;	// CTI_CONF				cmd[2] = 0x09;	// CTI_STORE_NUMBER				cmd[3] = ii+1;	// Speicherstelle				cmd[4] = mK->mKurz[ii].RufNr[0];	// Anzahl der Ziffern				for(int i=1; i <= mK->mKurz[ii].RufNr[0]; i++) {					char	c = mK->mKurz[ii].RufNr[i];					c &= 0x0F;					char	mask = 0xF0;					if(i & 1) {						mask = ~mask;						c <<= 4;					}					count = 5 + ((i - 1) >> 1);					cmd[count] &= mask;					cmd[count] |= c;				}				count = ((cmd[4] + 1) >> 1) + 5;				cmd[count++] = mK->mKurz[ii].Babyruf;				cmd[count++] = mK->mKurz[ii].Tin;				cmd[count++] = mK->mKurz[ii].Sonderruf;				cmd[count++] = mK->mKurz[ii].Sperre;				cmd[count++] = 0xff;	// CTI_STOP				SendCommand(cmd, count);				iErr = GetCommand(cmd, len, sizeof(cmd));				if(iErr == noErr && cmd[0] == 0xcc && cmd[1] == 0x08 && cmd[2] == 0x03) {					SetConfig(saveConfig);					ThrowOSErr_(ioErr);				}				pb.Set(progressIndex++);			}			SetConfig(saveConfig);		}		cmd[0] = 0x0C;					// Abschluß Konfiguration		SendCommand(cmd, 1);		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr /*|| len != 1 || cmd[0] != 0x11*/) ThrowOSErr_(ioErr);		if(isAnlage20) {			cmd[0] = 0xcc;					// Tag/Nacht-Schaltung auf den richtigen Wert setzen			cmd[1] = 0x05;			cmd[2] = 0x07;			cmd[3] = GetConfig();			cmd[4] = 0xff;			SendCommand(cmd, 5);			iErr = GetCommand(cmd, len, sizeof(cmd));		}	}	catch(LException err) {		ErrorAlert(err.GetErrorCode());	} 	InitCursor();	mSd = 0L;	BuildIndexTable();}#endif/*** *	ISTEC zurücksetzen ***/void		CISTEC::Reset(){	try{		Str255			cmd;		const int		theSeconds = 30;	// 30 Sekunden warten		const int		the60Ticks = 15;	// 4 mal pro Sekunde (60/15 = 4Hz) ein Update der Progressbar		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err.GetErrorCode(), 130);			return;		} 		ProgressBar	pb(1000, 7, (60 / the60Ticks) * theSeconds);		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		cmd[0] = 0x02;					// Bereitschaft prüfen		SendCommand(cmd, 1);		OSErr			iErr;		short			len;		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr || len != 1 || cmd[0] != 0x12) ThrowOSErr_(ioErr);		cmd[0] = 0x0b;					// Anlage komplett zurücksetzen		SendCommand(cmd, 1);		for(int i=0; i<(theSeconds * (60 / the60Ticks)); i++) {			UInt32	ret;			Delay(15, &ret);			pb.Set(i);		}#if 0		OSErr			iErr;		short			len;		cmd[0] = 0x02;					// Bereitschaft prüfen (hat alles geklappt?)		SendCommand(cmd, 1);		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr || len != 1 || cmd[0] != 0x12) ThrowOSErr_(ioErr);#endif	}	catch(LException err) {		ErrorAlert(err.GetErrorCode());	} 	InitCursor();	mSd = 0L;	BuildIndexTable();}/*** *	ISTEC zurücksetzen ***/#if !DEMO_VERSIONvoid		CISTEC::ReadGeb(){	try{		Str255			cmd;		OSErr			iErr;		short			len;		UInt16			iGeb[64];		GrundKonfigStruct	iKonfig;		BlockFill(&iKonfig, 0x00, sizeof(iKonfig));		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err.GetErrorCode(), 130);			return;		} 		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		cmd[0] = 0x02;					// Bereitschaft prüfen (hat alles geklappt?)		SendCommand(cmd, 1);		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr || len != 1 || cmd[0] != 0x12) ThrowOSErr_(ioErr);		cmd[0] = 0x0A;					// Abfrage Grundkonfiguration		SendCommand(cmd, 1);		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr || cmd[0] != 0x17) ThrowOSErr_(ioErr);		::BlockMoveData(cmd + 1, &iKonfig, sizeof(GrundKonfigStruct));		cmd[0] = 0x06;					// Abfrage Gebührenzaehler		SendCommand(cmd, 1);		iErr = GetCommand(cmd, len, sizeof(cmd));		if(iErr != noErr || len != (GetVersion() >= 200 ? 17 : 129) || cmd[0] != 0x15) ThrowOSErr_(ioErr);		::BlockMoveData(cmd + 1, &iGeb, 128);		// Worte drehen!		for(int i=0; i<64; i++)			mK->mGeb[i] = ((iGeb[i] >> 8) & 0xFF) | (iGeb[i] << 8);		FSSpec	fs;		GetIndString(fs.name, 1000, 8);		fs.parID = 0L;		fs.vRefNum = 0;		LFileStream	fss(fs);		LStr255		s;		try{			fss.OpenDataFork(fsWrPerm);	// Datei öffnen		}		catch(LException err) {			fss.CreateNewDataFile('ttxt', 'TEXT', smSystemScript);	// bei Bedarf erstellen			fss.OpenDataFork(fsWrPerm);		} 		fss.SetMarker(fss.GetLength(), streamFrom_Start);	// Ptr aufs Dateiende		// Datum/Uhrzeit		UInt32	rawSecs;		Str255	resultStr;		GetDateTime(&rawSecs);		IUDateString(rawSecs, shortDate, resultStr);		s = resultStr;		s += "\p\t";		s += resultStr;		s += "\p ";		IUTimeString(rawSecs, false, resultStr);		s += resultStr;		s += "\p\t";		// bei rein analogen ISTEC nur die analogen Apparate exportieren, sonst _alle_		SInt32	theAppCount = (iKonfig.Anz_intS0Bus == 0) ? iKonfig.Anz_abSchnittstellen : 64;		// Gesamtsumme		SInt32	sum = 0L;		for(int i=0; i<theAppCount; i++)			sum += mK->mGeb[i];		s += LStr255(sum);		fss.WriteData((StringPtr)s + 1, s.Length());		// und die Einzelsummen		for(int i=0; i<theAppCount; i++) {			s = "\p\t";			s += LStr255(SInt32(mK->mGeb[i]));			fss.WriteData((StringPtr)s + 1, s.Length());		}		s = "\p\r";		fss.WriteData((StringPtr)s + 1, s.Length());	}	catch(LException err) {		ErrorAlert(err.GetErrorCode());	} 	InitCursor();	mSd = 0L;	BuildIndexTable();}#endif#endif