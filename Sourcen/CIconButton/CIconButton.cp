// ===========================================================================//	File:					CIconButton.cp//  Version:				1.1 - Dec 5, 1994////	Copyright ©1994 Mike Shields. All rights reserved.//	You may use the source code included in this archive in any application (commercial, //	shareware, freeware, postcardware, etc) when delivered an executable Macintosh //	application. You must attribute use of this source code in your copyright notice. //	You may not sell this source code in any form. This source code may be placed on //	publicly accessable archive sites and source code disks. It may not be placed on //	for profit archive sites and source code disks without the permission of the author, //	Mike Shields.////	    This source code is distributed in the hope that it will be useful,//	    but WITHOUT ANY WARRANTY; without even the implied warranty of//	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.// ===========================================================================//	CIconButton.h				<- double-click + Command-D to see class declaration////// CIconButton is a Pane derived class which encapulates the drawing behavior of // the PlotIconID, PlotCIcon, PlotIcon Toolbox calls into a class. The class // handles retriving and disposing of the icon data, you only have to tell it// the type and id of icon to draw. Optionally, you can specify the alignment, // state and label of the icon. (Not available for B&W ICON resource drawing).// To use the PlotIconID drawing style, specify the graphics type as kUseIconFamily// To use the PlotCIcon drawing style, specify the graphics type as kUseCICN// To use the PlotIcon drawing style, specify the graphics type as kUseBWIcon//// Note: For more info on the PlotIconID calls see TN QD 18 - // Drawing Icons the System 7 Way//#ifndef __CIconPane__#include "CIconButton.h"#endif#include <LControl.h>#include <LStream.h>#include <UDrawingState.h>bool    CIconButton::sRegisterClass = PPFactory<CIconButton>::RegisterClass();// ---------------------------------------------------------------------------//		¥ CIconButton// ---------------------------------------------------------------------------//	Default ConstructorCIconButton::CIconButton(){	mGraphicsType = resID_Undefined;	mIconID = 0;	mAlignment = atNone;	mState = ttNone;	mLabel = ttNone;	mIconHandle = NULL;}// ---------------------------------------------------------------------------//		¥ CIconButton(const CIconButton&)// ---------------------------------------------------------------------------//	Copy ConstructorCIconButton::CIconButton(const CIconButton &inOriginal)		: LControl(inOriginal){	SetGraphicsType(inOriginal.GetGraphicsType());	SetIconID(inOriginal.GetIconID());	SetAlignment(inOriginal.GetAlignment());	SetIconState(inOriginal.GetIconState());	SetIconLabel(inOriginal.GetIconLabel());	// we want to copy the handle data, not just the handle ptr.	mIconHandle = inOriginal.GetIconHandle();	FailOSErr_(HandToHand(&mIconHandle));}// ---------------------------------------------------------------------------//		¥ CIconButton(SPaneInfo&, Str255, ResIDT)// ---------------------------------------------------------------------------//	Construct from parameters. Use this constructor to create a IconPane//	from runtime data.CIconButton::CIconButton(const SPaneInfo &inPaneInfo, MessageT inClickedMessage, OSType inGraphicsType, 					ResIDT inIconID, SInt16 inAlignment,					SInt16 inState, SInt16 inLabel)		: LControl(inPaneInfo, inClickedMessage, 0, 0, 1){	mGraphicsType = inGraphicsType;	mIconID = inIconID;	mAlignment = inAlignment;	mState = inState;	mLabel = inLabel;	mIconHandle = NULL;	if ( inGraphicsType == kUseCICN )	{		FailNIL_(mIconHandle = (Handle)GetCIcon(mIconID));	}	else if ( inGraphicsType == kUseBWIcon )	{		FailNIL_(mIconHandle = GetIcon(mIconID));		::DetachResource(mIconHandle);		ThrowIfResError_();	}}// ---------------------------------------------------------------------------//		¥ CIconButton(LStream*)// ---------------------------------------------------------------------------//	Construct from data in a StreamCIconButton::CIconButton(LStream *inStream)		: LControl(inStream){	inStream->ReadData(&mGraphicsType,  sizeof(OSType));	inStream->ReadData(&mIconID, sizeof(ResIDT));	inStream->ReadData(&mAlignment, sizeof(SInt16));	inStream->ReadData(&mState, sizeof(SInt16));	inStream->ReadData(&mLabel, sizeof(SInt16));	mIconHandle = NULL;	if ( mGraphicsType == kUseCICN )	{		FailNIL_(mIconHandle = (Handle)GetCIcon(mIconID));	}	else if ( mGraphicsType == kUseBWIcon )	{		FailNIL_(mIconHandle = GetIcon(mIconID));		::DetachResource(mIconHandle);		ThrowIfResError_();	}}// ---------------------------------------------------------------------------//		¥ ~CIconButton// ---------------------------------------------------------------------------//	DestructorCIconButton::~CIconButton(){}// ---------------------------------------------------------------------------//		¥ SetGraphicsType// ---------------------------------------------------------------------------//	Set the icon type we are drawingvoid CIconButton::SetGraphicsType(OSType inGraphicsType){	if ( mGraphicsType == kUseCICN )	{		// dispose of the old icon		DisposeCIcon((CIconHandle)mIconHandle);	}	else if ( mGraphicsType == kUseBWIcon )	{		// dispose of the old icon		DisposeHandle(mIconHandle);	}	mIconHandle = NULL;	mGraphicsType = inGraphicsType;	if ( inGraphicsType == kUseCICN )	{		FailNIL_(mIconHandle = (Handle)GetCIcon(mIconID));	}	else if ( inGraphicsType == kUseBWIcon )	{		FailNIL_(mIconHandle = GetIcon(mIconID));		// detatch the resource otherwise disposing of it is _very_ bad		::DetachResource(mIconHandle);		ThrowIfResError_();	}}// ---------------------------------------------------------------------------//		¥ SetIconID// ---------------------------------------------------------------------------//	Get the icon family to drawvoid CIconButton::SetIconID(ResIDT inIconID){	mIconID = inIconID;	if ( mGraphicsType == kUseCICN )	{		// dispose of the old icon and get the new one		DisposeCIcon((CIconHandle)mIconHandle);		FailNIL_(mIconHandle = (Handle)GetCIcon(inIconID));	}	else if ( mGraphicsType == kUseBWIcon )	{		// dispose of the old icon and get the new one		DisposeHandle(mIconHandle);		FailNIL_(mIconHandle = GetIcon(inIconID));		// detatch the resource otherwise disposing of it is _very_ bad		::DetachResource(mIconHandle);		ThrowIfResError_();	}}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------//	Draw the IconPanevoid CIconButton::DrawSelf(){	StColorPenState	theColorState;	Rect			frame;	theColorState.Normalize();	CalcLocalFrameRect(frame);	// if this isn't set to a type we know abour then just fill 	// the frame with gray	if ( mGraphicsType != kUseIconFamily && 		mGraphicsType != kUseCICN && 		mGraphicsType != kUseBWIcon ) 	{		::FillRect(&frame, &UQDGlobals::GetQDGlobals()->ltGray);		::FrameRect(&frame);	} 	else if ( mGraphicsType == kUseIconFamily ) 	{		::PlotIconID(&frame, mAlignment, mState + mLabel, mIconID);	}	else	{		// if there isn't a handle for a 'cicn' or 'ICON' then once again fill 		// with gray		if ( mIconHandle == NULL )		{			::FillRect(&frame, &UQDGlobals::GetQDGlobals()->ltGray);			::FrameRect(&frame);		}		else		{			if ( mGraphicsType == kUseCICN )			{				::PlotCIcon(&frame, (CIconHandle)mIconHandle);			}			else			{				::PlotIcon(&frame, mIconHandle);			}		}	}}// ---------------------------------------------------------------------------//		¥ HotSpotAction// ---------------------------------------------------------------------------//	Take action during mouse down tracking////	CicnButtons toggle between two graphics, depending on whether the mouse is//	inside or outside the CIconButton.voidCIconButton::HotSpotAction(	SInt16		/* inHotSpot */,	Boolean		inCurrInside,	Boolean		inPrevInside){									// Draw if cursor moved from IN to OUT									//   or from OUT to IN	if (inCurrInside != inPrevInside) {		SInt16	theState = GetIconState() & ~kTransformSelected;		if(inCurrInside) theState |= kTransformSelected;		SetIconState(theState);		DrawSelf();	}}voidCIconButton::HotSpotResult(	short	inHotSpot){									// Undo CIconButton hilighting	HotSpotAction(inHotSpot, false, true);	BroadcastValueMessage();		// Although value doesn't change,									//   send message to inform Listeners									//   that CIconButton was clicked}