// ===========================================================================//	CElmeg.cp						©1994 Metrowerks Inc. All rights reserved.// ===========================================================================#include "SharewareFlags.h"#if INCLUDE_ELMEG#include "CElmeg.h"#include <UModalDialogs.h>#include "MRFUtilities.h"#include "CPreferences.h"#include <UMemoryMgr.h>#include <LWindow.h>#include <LStaticText.h>#include <LEditText.h>#include <LPopupButton.h>#include <LCheckBox.h>#include <LTextGroupBox.h>#include <LPushButton.h>#include <LPopupGroupBox.h>#include <LTabsControl.h>#include <LCheckBoxGroupBox.h>#include <LRadioGroupView.h>#include <PP_Messages.h>#include "ProgressBar.h"void	CElmeg::DoAbout(){	StDialogHandler	theHandler(3100, nil);	LWindow		*theDialog = theHandler.GetDialog();	theDialog->Show();	while(true) {		MessageT	hitMessage = theHandler.DoDialog();		if(hitMessage == msg_Cancel) {			return;		} else if(hitMessage == msg_OK) {			break;		}	}}// Versionnummer als String zurückgebenvoid	CElmeg::GetVersionStr(LStr255 &oVersionStr) const{	oVersionStr.Assign(mKonfig.mVersion+23, 9);}// Versionnummer als String zurückgebenvoid	CElmeg::GetVersionDateStr(LStr255 &oVersionStr) const{	oVersionStr.Assign(mKonfig.mVersion+23+10, 20);}// Namen der Telefonanlage zurückgebenvoid	CElmeg::GetAnlagenName(LStr255 &oAnlageName) const{	switch(GetAnlagenTyp()) {	case ELMEG_C68: oAnlageName = "\pElmeg C68"; break;	case ELMEG_C88: oAnlageName = "\pElmeg C88"; break;	}}// Namen eines Apparates ermittelnvoid	CElmeg::SetAppName(SInt16 iAppIndex, const LStr255 &iAppName){	BlockFill(mApp[iAppIndex].mName, 0, sizeof(Str31));	LString::CopyPStr(iAppName, mApp[iAppIndex].mName, sizeof(Str31));}void	CElmeg::GetSperrnummer(SInt16 iIndex, LStr255 &oNummer) const{	if(iIndex < 1 || iIndex > 10)		return;	LString::CopyPStr(mKonfig.mSperr[iIndex-1], oNummer);}void	CElmeg::SetSperrnummer(SInt16 iIndex, const LStr255 &oNummer){	if(iIndex < 1 || iIndex > 10)		return;	LString::CopyPStr(oNummer, mKonfig.mSperr[iIndex-1]);	if(oNummer[0] > 20)		mKonfig.mSperr[iIndex-1][0] = 20;}void	CElmeg::GetFreinummer(SInt16 iIndex, LStr255 &oNummer) const{	if(iIndex < 1 || iIndex > 30)		return;	LString::CopyPStr(mKonfig.mFrei[iIndex-1], oNummer);}void	CElmeg::SetFreinummer(SInt16 iIndex, const LStr255 &oNummer){	if(iIndex < 1 || iIndex > 30)		return;	LString::CopyPStr(oNummer, mKonfig.mFrei[iIndex-1]);	if(oNummer[0] > 20)		mKonfig.mSperr[iIndex-1][0] = 20;}void	CElmeg::GetKurzwahl(SInt16 iKurzIndex, SInt16 &oAppKurzNo, LStr255 &oAppNummer, LStr255 &oAppName) const{	if(iKurzIndex < 1 || iKurzIndex > 100) {		oAppKurzNo = -1;		return;	}	oAppKurzNo = iKurzIndex - 1;	LString::CopyPStr(mKonfig.mKurz[iKurzIndex-1], oAppNummer);	LString::CopyPStr(mKonfig.mKurzname[iKurzIndex-1], oAppName);}void	CElmeg::SetKurzwahl(SInt16 iKurzIndex, const LStr255 oAppNummer, const LStr255 oAppName){	if(iKurzIndex < 1 || iKurzIndex > 100) {		return;	}	LString::CopyPStr(oAppNummer, mKonfig.mKurz[iKurzIndex-1], sizeof(mKonfig.mKurz[iKurzIndex-1]));	LString::CopyPStr(oAppName, mKonfig.mKurzname[iKurzIndex-1]);}void	CElmeg::SetDefault(Boolean iOptionalFlag){#pragma unused(iOptionalFlag)	BlockFill(&mKonfig, 0, sizeof(mKonfig));	BlockFill(&mApp, 0, sizeof(mApp));	mKonfig.mAnlage = gPrefs->P.DefAnlage;//	LString::CopyPStr("\pISDN TkAnl Ausbau 4So V2.00 R01 Jul 03 1997 16:26:37", mKonfig.mVersion);	LString::CopyPStr("\pISDN TkAnl Ausbau 4So V3.00 R01 Jan 28 1998 08:54:22", mKonfig.mVersion);	if(mKonfig.mAnlage == ELMEG_C68)		mKonfig.mVersion[19] = '3';	mKonfig.mMusic = 1;	mKonfig.mGebInfo = 2;	// alles auf die AVA mappen	for(int i=0; i<2; ++i)		for(int j=0; j<10; ++j)			mKonfig.mAVAMSN[i][j] = true;	BlockFill(&mKonfig.mTFE_Var, -1, sizeof(mKonfig.mTFE_Var));	BlockFill(&mKonfig.mAVA_Var, -1, sizeof(mKonfig.mAVA_Var));	//					Tag								Nacht	mKonfig.mAVA_Var[0][0][0] = 10; mKonfig.mAVA_Var[1][0][0] = 14;	// Telefonie	mKonfig.mAVA_Var[0][1][0] = 11; mKonfig.mAVA_Var[1][1][0] = 15;	// Daten	mKonfig.mAVA_Var[0][2][0] = 12; mKonfig.mAVA_Var[1][2][0] = 16;	// Fax Gruppe 3	mKonfig.mAVA_Var[0][3][0] = 13; mKonfig.mAVA_Var[1][3][0] = 17;	// Fax Gruppe 4	BlockFill(&mKonfig.mApp, -1, sizeof(mKonfig.mApp));	for(int i=0; i<MAX_APP_COUNT; i++) {		if(i < 8)		{			mApp[i].mAppNo = 40 + i;			mApp[i].mDienst = Endgeraetedienst_Fernsprechen;		} else {			mApp[i].mAppNo = 10 + i - 8;			mApp[i].mDienst = Endgeraetedienst_Digital;		}		mApp[i].mBer = EB_Vollamt;		mApp[i].mActive = /**/true/*false/**/;		mApp[i].mWahl = 1;			// MFV		mApp[i].mDispNum = true;		mApp[i].mSendNum = true;		mApp[i].mGeb = true;		mApp[i].mMSN[0] = -1;	// Default MSN		mApp[i].mMSN[1] = -1;		LString::CopyPStr(LStr255(1000, 13), mApp[i].mName);	}}CElmeg::CElmeg(){	SetDefault();	SetDirty(false);}// Apparat möglich? Nein => Default-Apparat liefernchar		CElmeg::CheckGoodApp(char inApp, Boolean retNull){#pragma unused(retNull)	return inApp;}// interne Struktur überprüfen und ggf. korrigierenvoid		CElmeg::CheckData(){}Boolean		CElmeg::IsElmegData(Handle inH){	StHandleLocker	lock(inH);	UInt32			theSize = GetHandleSize(inH);	return (*(long*)*inH) == 'ElmG';}void		CElmeg::SetISDNData(Handle inH){	if(inH == nil) {		SetDefault();	} else {		StHandleLocker	lock(inH);		UInt32			theSize = GetHandleSize(inH);		Ptr				pp = *inH;		pp += sizeof(long);		::BlockMoveData(pp, &mKonfig, sizeof(mKonfig));		pp += sizeof(mKonfig);		::BlockMoveData(pp, &mApp, sizeof(mApp));	}	CheckData();	ExecuteAttachments(msg_AnlageDirty, nil);}Handle		CElmeg::GetISDNData(){	Handle		h = NewHandleClear(sizeof(long) + sizeof(mKonfig) + sizeof(mApp));	ThrowIfMemError_(); ThrowIfNil_(h);	StHandleLocker	lock(h);	Ptr		pp = *h;	// Magic	*((long*)pp)++ = 'ElmG';	// Anlagenkonfiguration	::BlockMoveData(&mKonfig, pp, sizeof(mKonfig));	pp += sizeof(mKonfig);	// Endgerätenamen anhängen	::BlockMoveData(&mApp, pp, sizeof(mApp));	pp += sizeof(mApp);	return h;}// ---------------------------------------------------------------------------//		• Anlangeinformationen// ---------------------------------------------------------------------------void		CElmeg::EditAnlagenSubsettings(int bus, bool isMG){	if(isMG)	// Mehrgeräteanschluß gewählt?	{		StDialogHandler	theHandler(3003, this);		LWindow		*theDialog = theHandler.GetDialog(); FailNIL_(theDialog);		LPopupGroupBox	*popbox = dynamic_cast<LPopupGroupBox*>(theDialog->FindPaneByID('MSNc')); FailNIL_(popbox);		popbox->SetValue(1);		int	index = -1;		SInt8	theAppNoList[MAX_APP_COUNT+1];		int	appIndex = 0;		theAppNoList[appIndex++] = 0;		// keine Auswahl		for(int i=0; i<MAX_APP_COUNT; ++i)		{			if(!IsAppActive(i))				continue;			if(GetAppDienst(i) == Endgeraetedienst_Tuerstelle || GetAppDienst(i) == Endgeraetedienst_MusikIn)				continue;			if(GetAppBerechtigung(i) < EB_Halbamt)				continue;			theAppNoList[appIndex++] = GetAppNo(i);		}		LPopupButton	*msn_spop[8];		for(int i=0; i<8; ++i)		{			msn_spop[i] = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('MSN0'+i));			FailNIL_(msn_spop[i]);			if(appIndex <= 1)				msn_spop[i]->Disable();			else			{				MenuRef		mref = msn_spop[i]->GetMacMenuH();				FailNIL_(mref);				for(int j=0; j<appIndex; ++j)				{					::AppendMenu(mref, "\p ");					if(theAppNoList[j] > 0)						::SetMenuItemText(mref, ::CountMenuItems(mref), LStr255(long(theAppNoList[j])));					else						::SetMenuItemText(mref, ::CountMenuItems(mref), "\p—");				}				msn_spop[i]->SetMaxValue(appIndex);			}		}		LEditText		*msn = dynamic_cast<LEditText*>(theDialog->FindPaneByID('MSNv')); FailNIL_(msn);		LCheckBox		*ava_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('AVAr')); FailNIL_(ava_schk);		LTextGroupBox	*msnbox = dynamic_cast<LTextGroupBox*>(theDialog->FindPaneByID('MSNL')); FailNIL_(msnbox);		bool	isVisible = false;		CElmegKonfig	*saveKonfig = new CElmegKonfig;		if(saveKonfig) *saveKonfig = mKonfig;		MessageT	hitMessage = cmd_Nothing;		while (true) {					// Let DialogHandler process events			if(index != (popbox->GetValue() - 1) || hitMessage == msg_OK)			{				if(index >= 0)				{					LStr255		theMSN;					msn->GetDescriptor(theMSN);					LString::CopyPStr(theMSN, mKonfig.mMSN[bus][index]);					mKonfig.mAVAMSN[bus][index] = ava_schk->GetValue();					for(int i=0; i<8; ++i)					{						MenuRef		mref = msn_spop[i]->GetMacMenuH();						FailNIL_(mref);						Str255	theStr;						::GetMenuItemText(mref, msn_spop[i]->GetValue(), theStr);						SInt32	theVal = 0;						if(theStr[1] != '—')							::StringToNum(theStr, &theVal);						mKonfig.mApp[bus][index][i] = theVal;					}				}				index = popbox->GetValue() - 1;				msn->SetDescriptor(mKonfig.mMSN[bus][index]);				msn->SelectAll();				ava_schk->SetValue(mKonfig.mAVAMSN[bus][index]);				for(int i=0; i<8; ++i)				{					bool	found = false;					for(int j=0; j<appIndex; ++j)					{						if(theAppNoList[j] != mKonfig.mApp[bus][index][i])							continue;						msn_spop[i]->SetValue(j+1);						found = true;						break;					}					if(!found)						msn_spop[i]->SetValue(0);				}			}			if (hitMessage == msg_OK)			{				if(!saveKonfig || BlockCompare(&mKonfig, saveKonfig, sizeof(mKonfig)) != 0)					SetDirty();				delete saveKonfig;				break;			}			if(ava_schk->GetValue())				msnbox->Disable();			else				msnbox->Enable();			if(!isVisible) {				theDialog->Show();				isVisible = true;			}			hitMessage = theHandler.DoDialog();			if (hitMessage == msg_Cancel) {				if(saveKonfig) mKonfig = *saveKonfig;				delete saveKonfig;				break;			}		}	} else {		StDialogHandler	theHandler(3004, this);		LWindow		*theDialog = theHandler.GetDialog(); FailNIL_(theDialog);		theDialog->Show();		LEditText		*msn = dynamic_cast<LEditText*>(theDialog->FindPaneByID('MSNv')); FailNIL_(msn);		msn->SetDescriptor(mKonfig.mAnl[bus]);		MessageT	hitMessage = cmd_Nothing;		while (true) {					// Let DialogHandler process events			MessageT	hitMessage = theHandler.DoDialog();			if (hitMessage == msg_Cancel) {				break;			} else if (hitMessage == msg_OK)			{				LStr255		theMSN;				msn->GetDescriptor(theMSN);				LString::CopyPStr(theMSN, mKonfig.mAnl[bus]);				SetDirty();				break;			}		}	}}void		CElmeg::AnlageInfoDialog(){	StDialogHandler	theHandler(3000, this);	LWindow		*theDialog = theHandler.GetDialog();	FailNIL_(theDialog);	LStaticText *str = dynamic_cast<LStaticText*>(theDialog->FindPaneByID('Anla')); FailNIL_(str);	LStr255	s;	GetAnlagenName(s);	str->SetDescriptor(s);	str = dynamic_cast<LStaticText*>(theDialog->FindPaneByID('SWVe')); FailNIL_(str);	GetVersionStr(s); str->SetDescriptor(s);	str = dynamic_cast<LStaticText*>(theDialog->FindPaneByID('SWVd')); FailNIL_(str);	GetVersionDateStr(s); str->SetDescriptor(s);	str = dynamic_cast<LStaticText*>(theDialog->FindPaneByID('S0ex')); FailNIL_(str);	str->SetValue(GetExtS0());	str = dynamic_cast<LStaticText*>(theDialog->FindPaneByID('S0in')); FailNIL_(str);	str->SetValue(GetIntS0());	str = dynamic_cast<LStaticText*>(theDialog->FindPaneByID('abSc')); FailNIL_(str);	str->SetValue(GetAB());	LPopupButton	*isdnamt_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('IAmt')); FailNIL_(isdnamt_spop);	LPopupButton	*amt1_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Amt1')); FailNIL_(amt1_spop);	LPopupButton	*amt2_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Amt2')); FailNIL_(amt2_spop);	LPushButton	*amt2_but = dynamic_cast<LPushButton*>(theDialog->FindPaneByID('A2Se')); FailNIL_(amt2_but);	amt1_spop->SetValue(mKonfig.mAnschlussArt[0] + 1);	if(mKonfig.mAnlage == ELMEG_C68)	{		isdnamt_spop->Disable();		amt2_spop->Hide();		amt2_but->Hide();		theDialog->ResizeWindowBy(0, -20);	} else {		isdnamt_spop->SetValue(mKonfig.mAmtAnschl + 1);		amt2_spop->SetValue(mKonfig.mAnschlussArt[1] + 1);	}	LPopupButton	*music_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Musi')); FailNIL_(music_spop);	music_spop->SetValue(mKonfig.mMusic + 1);	LPopupButton	*geb_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('GebI')); FailNIL_(geb_spop);	geb_spop->SetValue(mKonfig.mGebInfo + 1);	LPopupButton	*ava_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('AVAr')); FailNIL_(ava_spop);	ava_spop->SetValue(mKonfig.mAVA + 1);	LPopupButton	*tava_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Tuer')); FailNIL_(tava_spop);	tava_spop->SetValue(mKonfig.mTAVA + 1);	if(GetAppDienst(7) != Endgeraetedienst_Tuerstelle)	{		tava_spop->Disable();		LPushButton		*tava_but = dynamic_cast<LPushButton*>(theDialog->FindPaneByID('TueS')); FailNIL_(tava_but);		tava_but->Disable();	}	LPopupButton	*amta_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('AmtA')); FailNIL_(amta_spop);	int		amta = mKonfig.mBelegZiffer + 2;	MenuRef		mref = amta_spop->GetMacMenuH(); FailNIL_(mref);	for(int i=0; i<MAX_APP_COUNT; ++i)	{		int	theVal = GetAppNo(i) / 10 + 2;		if(amta == theVal)		// gar nicht möglich?		{			amta = 0;			mKonfig.mBelegZiffer = -1;		}		DisableItem(mref, theVal);	}	amta_spop->SetValue(amta);	bool	isVisible = false;	while (true) {		bool	hasMSNAVA = false;		for(int i=0; i<GetExtS0(); ++i)		{			for(int j=0; j<10; ++j)			{				if(mKonfig.mAVAMSN[i][j] == true)					hasMSNAVA = true;			}		}		if(hasMSNAVA)			ava_spop->Enable();		else			ava_spop->Disable();		if(isdnamt_spop->GetValue() == 2)		{			amt2_spop->Enable();			amt2_but->Enable();		} else {			amt2_spop->Disable();			amt2_but->Disable();		}		if(!isVisible) {			theDialog->Show();			isVisible = true;		}		MessageT	hitMessage = theHandler.DoDialog();		if(hitMessage == 'AVAs') {			int		tag_nacht = ava_spop->GetValue()-1;			StDialogHandler	theHandler(3020, this);			LWindow		*theDialog = theHandler.GetDialog();			LTabsControl	*popbox = dynamic_cast<LTabsControl*>(theDialog->FindPaneByID('ATyp')); FailNIL_(popbox);			popbox->SetValue(1);			int	index = -1;			SInt8	theAppNoList[MAX_APP_COUNT+1];			int	appIndex = 0;			theAppNoList[appIndex++] = 0;		// keine Auswahl			for(int i=0; i<MAX_APP_COUNT; ++i)			{				if(!IsAppActive(i))					continue;				if(GetAppDienst(i) == Endgeraetedienst_Tuerstelle || GetAppDienst(i) == Endgeraetedienst_MusikIn)					continue;				theAppNoList[appIndex++] = GetAppNo(i);			}			LPopupButton	*msn_spop[6];			for(int i=0; i<6; ++i)			{				msn_spop[i] = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('MSN0'+i));				FailNIL_(msn_spop[i]);				if(appIndex <= 1)					msn_spop[i]->Disable();				else				{					MenuRef		mref = msn_spop[i]->GetMacMenuH();					FailNIL_(mref);					for(int j=0; j<appIndex; ++j)					{						::AppendMenu(mref, "\p ");						if(theAppNoList[j] > 0)							::SetMenuItemText(mref, ::CountMenuItems(mref), LStr255(long(theAppNoList[j])));						else							::SetMenuItemText(mref, ::CountMenuItems(mref), "\p—");					}					msn_spop[i]->SetMaxValue(appIndex);				}			}			LEditText		*intNo = dynamic_cast<LEditText*>(theDialog->FindPaneByID('eTel')); FailNIL_(intNo);			LPopupButton	*geb_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('GebA')); FailNIL_(geb_spop);			{				if(appIndex <= 1)					geb_spop->Disable();				else				{					MenuRef		mref = geb_spop->GetMacMenuH();					FailNIL_(mref);					for(int j=0; j<appIndex; ++j)					{						::AppendMenu(mref, "\p ");						if(theAppNoList[j] > 0)							::SetMenuItemText(mref, ::CountMenuItems(mref), LStr255(long(theAppNoList[j])));						else							::SetMenuItemText(mref, ::CountMenuItems(mref), "\p—");					}					geb_spop->SetMaxValue(appIndex);				}			}			LCheckBoxGroupBox	*cbox = dynamic_cast<LCheckBoxGroupBox*>(theDialog->FindPaneByID('CBox')); FailNIL_(cbox);			LTextGroupBox		*xbox = dynamic_cast<LTextGroupBox*>(theDialog->FindPaneByID('xBox')); FailNIL_(xbox);			bool	isVisible = false;			CElmegKonfig	*saveKonfig = new CElmegKonfig;			if(saveKonfig) *saveKonfig = mKonfig;			MessageT	hitMessage = cmd_Nothing;			while (true) {					// Let DialogHandler process events				if(index != (popbox->GetValue() - 1) || hitMessage == msg_OK)				{					if(index >= 0)					{						mKonfig.mAVA_Extern[tag_nacht][index] = !cbox->GetValue();						LStr255		theExtNo;						intNo->GetDescriptor(theExtNo);						LString::CopyPStr(theExtNo, mKonfig.mAVA_Ext[tag_nacht][index]);						MenuRef		mref = geb_spop->GetMacMenuH();						FailNIL_(mref);						Str255	theStr;						::GetMenuItemText(mref, geb_spop->GetValue(), theStr);						SInt32	theVal = 0;						if(theStr[1] != '—')							::StringToNum(theStr, &theVal);						mKonfig.mAVA_Geb[tag_nacht][index] = theVal;						for(int i=0; i<6; ++i)						{							MenuRef		mref = msn_spop[i]->GetMacMenuH();							FailNIL_(mref);							Str255	theStr;							::GetMenuItemText(mref, msn_spop[i]->GetValue(), theStr);							SInt32	theVal = 0;							if(theStr[1] != '—')								::StringToNum(theStr, &theVal);							mKonfig.mAVA_Var[tag_nacht][index][i] = theVal;						}					}					index = popbox->GetValue() - 1;					cbox->SetValue(!mKonfig.mAVA_Extern[tag_nacht][index]);					intNo->SetDescriptor(mKonfig.mAVA_Ext[tag_nacht][index]);					bool	found = false;					for(int j=0; j<appIndex; ++j)					{						if(theAppNoList[j] != mKonfig.mAVA_Geb[tag_nacht][index])							continue;						geb_spop->SetValue(j+1);						found = true;						break;					}					if(!found)						geb_spop->SetValue(0);					for(int i=0; i<6; ++i)					{						bool	found = false;						for(int j=0; j<appIndex; ++j)						{							if(theAppNoList[j] != mKonfig.mAVA_Var[tag_nacht][index][i])								continue;							msn_spop[i]->SetValue(j+1);							found = true;							break;						}						if(!found)							msn_spop[i]->SetValue(0);					}				}				if(cbox->GetValue())					xbox->Disable();				else					xbox->Enable();				if (hitMessage == msg_OK)				{					if(!saveKonfig || BlockCompare(&mKonfig, saveKonfig, sizeof(mKonfig)) != 0)						SetDirty();					delete saveKonfig;					break;				}				if(!isVisible) {					theDialog->Show();					isVisible = true;				}				hitMessage = theHandler.DoDialog();				if (hitMessage == msg_Cancel) {					if(saveKonfig) mKonfig = *saveKonfig;					delete saveKonfig;					break;				}			}		} else if(hitMessage == 'TueS') {			int		tag_nacht = tava_spop->GetValue()-1;			StDialogHandler	theHandler(3021, this);			LWindow		*theDialog = theHandler.GetDialog();			SInt8	theAppNoList[MAX_APP_COUNT+1];			int	appIndex = 0;			theAppNoList[appIndex++] = 0;		// keine Auswahl			for(int i=0; i<MAX_APP_COUNT; ++i)			{				if(!IsAppActive(i))					continue;				if(GetAppDienst(i) == Endgeraetedienst_Tuerstelle || GetAppDienst(i) == Endgeraetedienst_MusikIn)					continue;				theAppNoList[appIndex++] = GetAppNo(i);			}			LPopupButton	*msn_spop[6];			for(int i=0; i<6; ++i)			{				msn_spop[i] = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('MSN0'+i));				FailNIL_(msn_spop[i]);				if(appIndex <= 1)					msn_spop[i]->Disable();				else				{					MenuRef		mref = msn_spop[i]->GetMacMenuH();					FailNIL_(mref);					for(int j=0; j<appIndex; ++j)					{						::AppendMenu(mref, "\p ");						if(theAppNoList[j] > 0)							::SetMenuItemText(mref, ::CountMenuItems(mref), LStr255(long(theAppNoList[j])));						else							::SetMenuItemText(mref, ::CountMenuItems(mref), "\p—");					}					msn_spop[i]->SetMaxValue(appIndex);				}			}			for(int i=0; i<6; ++i)			{				bool	found = false;				for(int j=0; j<appIndex; ++j)				{					if(theAppNoList[j] != mKonfig.mTFE_Var[tag_nacht][i])						continue;					msn_spop[i]->SetValue(j+1);					found = true;					break;				}				if(!found)					msn_spop[i]->SetValue(0);			}			LEditText		*intNo = dynamic_cast<LEditText*>(theDialog->FindPaneByID('eTel')); FailNIL_(intNo);			intNo->SetDescriptor(mKonfig.mTFE_Ext[tag_nacht]);			LCheckBoxGroupBox	*cbox = dynamic_cast<LCheckBoxGroupBox*>(theDialog->FindPaneByID('CBox')); FailNIL_(cbox);			cbox->SetValue(!mKonfig.mTFE_Extern[tag_nacht]);			LTextGroupBox		*xbox = dynamic_cast<LTextGroupBox*>(theDialog->FindPaneByID('xBox')); FailNIL_(xbox);			bool	isVisible = false;			while (true) {					// Let DialogHandler process events				if(cbox->GetValue())					xbox->Disable();				else					xbox->Enable();				if(!isVisible) {					theDialog->Show();					isVisible = true;				}				MessageT	hitMessage = theHandler.DoDialog();				if(hitMessage == msg_Cancel) {					break;				} else if(hitMessage == msg_OK) {					CElmegKonfig	*saveKonfig = new CElmegKonfig;					if(saveKonfig) *saveKonfig = mKonfig;					mKonfig.mTFE_Extern[tag_nacht] = !cbox->GetValue();					LStr255		theExtNo;					intNo->GetDescriptor(theExtNo);					LString::CopyPStr(theExtNo, mKonfig.mTFE_Ext[tag_nacht]);					for(int i=0; i<6; ++i)					{						MenuRef		mref = msn_spop[i]->GetMacMenuH();						FailNIL_(mref);						Str255	theStr;						::GetMenuItemText(mref, msn_spop[i]->GetValue(), theStr);						SInt32	theVal = 0;						if(theStr[1] != '—')							::StringToNum(theStr, &theVal);						mKonfig.mTFE_Var[tag_nacht][i] = theVal;					}					if(!saveKonfig || BlockCompare(&mKonfig, saveKonfig, sizeof(mKonfig)) != 0)						SetDirty();					delete saveKonfig;					break;				}			}		} else if(hitMessage == 'A1Se' || hitMessage == 'A2Se') {			int bus = hitMessage == 'A1Se' ? 0 : 1;			LPopupButton	*a_spop = bus == 0 ? amt1_spop : amt2_spop;			EditAnlagenSubsettings(bus, a_spop->GetValue() == 1);		}		if(hitMessage == msg_Cancel) {			break;		} else if (hitMessage == msg_OK) {			bool	theDoUpdate = false;			if(mKonfig.mAmtAnschl != (isdnamt_spop->GetValue() - 1)) {				mKonfig.mAmtAnschl = isdnamt_spop->GetValue() - 1;				SetDirty();				theDoUpdate = true;				StDialogHandler	theHandler(mKonfig.mAmtAnschl ? 3001 : 3002, this);				LWindow		*theDialog = theHandler.GetDialog();				theDialog->Show();				while (true) {					// Let DialogHandler process events					MessageT	hitMessage = theHandler.DoDialog();					if (hitMessage == msg_Cancel) {						break;					} else if (hitMessage == msg_OK) {						break;					}				}			}			if(mKonfig.mAnschlussArt[0] != (amt1_spop->GetValue() - 1)) {				mKonfig.mAnschlussArt[0] = amt1_spop->GetValue() - 1;				SetDirty();			}			if(mKonfig.mAnschlussArt[1] != (amt2_spop->GetValue() - 1) && mKonfig.mAmtAnschl > 0) {				mKonfig.mAnschlussArt[1] = amt2_spop->GetValue() - 1;				SetDirty();			}			if(mKonfig.mMusic != (music_spop->GetValue() - 1)) {				int	oldKonfig = mKonfig.mMusic;				mKonfig.mMusic = music_spop->GetValue() - 1;				if(mKonfig.mMusic == 3)				{					mApp[6].mDienst = Endgeraetedienst_MusikIn;					mApp[6].mActive = true;					theDoUpdate = true;				}				if(oldKonfig == 3)				{					mApp[6].mDienst = Endgeraetedienst_Fernsprechen;					theDoUpdate = true;				}				SetDirty();			}			if(amta != amta_spop->GetValue()) {				mKonfig.mBelegZiffer = amta_spop->GetValue() - 2;				SetDirty();			}			if(mKonfig.mGebInfo != geb_spop->GetValue() - 1) {				mKonfig.mGebInfo = geb_spop->GetValue() - 1;				SetDirty();			}			if(mKonfig.mAVA != ava_spop->GetValue() - 1) {				mKonfig.mAVA = ava_spop->GetValue() - 1;				SetDirty();			}			if(mKonfig.mTAVA != tava_spop->GetValue() - 1) {				mKonfig.mTAVA = tava_spop->GetValue() - 1;				SetDirty();			}			CheckData();			if(theDoUpdate)				ExecuteAttachments(msg_AnlageDirty, nil);			break;		}	}}// ---------------------------------------------------------------------------//		• Endgeräteinformationen// ---------------------------------------------------------------------------void		CElmeg::GeraetInfoDialog(short geraet){	StDialogHandler	theHandler(3500, this);	LWindow		*theDialog = theHandler.GetDialog();	// Gerätenummer an den Fenstertitel hängen	LStr255	titel;	theDialog->GetDescriptor(titel);	titel += LStr255(SInt32(GetAppNo(geraet)));	LStr255	s;	::GetIndString(s, 1000, IsAppDigital(geraet) ? 6 : 5);	titel += s;	theDialog->SetDescriptor(titel);	LEditText		*editName = dynamic_cast<LEditText*>(theDialog->FindPaneByID('Enam')); FailNIL_(editName);	LStr255	theGName;	GetAppName(geraet, theGName);	editName->SetDescriptor(theGName);//	theDialog->SwitchTarget(editName);	editName->SelectAll();	// interne Rufnummer	LEditText		*intNo = dynamic_cast<LEditText*>(theDialog->FindPaneByID('IntN')); FailNIL_(intNo);	intNo->SetValue(mApp[geraet].mAppNo);	LPopupButton	*spop1 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Wahl')); FailNIL_(spop1);	int	theBer;	switch(GetAppBerechtigung(geraet)) {	case EB_Vollamt:theBer = 1; break;	case EB_Inland:		case EB_Nah:	theBer = 2; break;	case EB_Ort:	theBer = 3; break;	case EB_Halbamt:theBer = 4; break;	default:		theBer = 5; break;	}	spop1->SetValue(theBer);	int	theDispBer = -1;	LPopupButton	*spop2 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Dien')); FailNIL_(spop2);	int	theDienst;	MenuRef		mref = spop2->GetMacMenuH(); FailNIL_(mref);	if(IsAppDigital(geraet))	{		theDienst = 7;		for(int i=2; i<=9; ++i)		{			if(i == 7) continue;			DisableItem(mref, i);		}	}	else	{		for(int i=7; i<=9; ++i)			DisableItem(mref, i);		if(geraet == 6) EnableItem(mref, 8);		if(geraet == 7) EnableItem(mref, 9);		switch(GetAppDienst(geraet)) {		case Endgeraetedienst_Anrufbeantworter:theDienst = 3; break;		case Endgeraetedienst_Kombi:theDienst = 4; break;		case Endgeraetedienst_Modem:theDienst = 5; break;		case Endgeraetedienst_Fax:theDienst = 6; break;		case Endgeraetedienst_MusikIn:theDienst = 8; break;		case Endgeraetedienst_Tuerstelle:theDienst = 9; break;		default:theDienst = 2;		}	}	if(!IsAppActive(geraet))		theDienst = 1;	spop2->SetValue(theDienst);	int	theDispDienst = -1;	LPopupButton	*msn_spop[2];	msn_spop[0] = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('MSN1')); FailNIL_(msn_spop[0]);	msn_spop[1] = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('MSN2')); FailNIL_(msn_spop[1]);	LPopupButton	*richt_spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Rich')); FailNIL_(richt_spop);	LTextGroupBox	*msn_box = dynamic_cast<LTextGroupBox*>(theDialog->FindPaneByID('MSNb')); FailNIL_(msn_box);	if(GetExtS0() < 2)	{		msn_spop[1]->Hide();		richt_spop->Hide();		msn_box->ResizeFrameBy(0, -53, true);		theDialog->ResizeWindowBy(0, -53);	} else {		richt_spop->SetValue(mApp[geraet].mRichtung + 1);	}	int	theMSN[2];	SInt8	msnConvTable[2][20];	BlockFill(&msnConvTable, -1, sizeof(msnConvTable));	for(int j=0; j<2; ++j)	{		theMSN[j] = 1;		int	menuCount = 1;		MenuRef		mref2 = msn_spop[j]->GetMacMenuH();		FailNIL_(mref2);		for(int i=::CountMenuItems(mref2); i>1; --i)			::DeleteMenuItem(mref2, 2);		for(int i=0; i<10; ++i)		{			if(mKonfig.mMSN[j][i][0] == 0)				continue;			msnConvTable[j][menuCount] = i;			if(msnConvTable[j][menuCount] == mApp[geraet].mMSN[j])				theMSN[j] = menuCount + 1;			LStr255	theStr(mKonfig.mMSN[j][i]);			::AppendMenu(mref2, "\p ");			::SetMenuItemText(mref2, ::CountMenuItems(mref2), theStr);			++menuCount;		}		msn_spop[j]->SetMaxValue(menuCount);		msn_spop[j]->SetValue(theMSN[j]);	}	// IWV?	LCheckBox	*iwv_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('IWVi')); FailNIL_(iwv_schk);	iwv_schk->SetValue(mApp[geraet].mWahl == 0);	if(IsAppDigital(geraet))		iwv_schk->Disable();	// auto-amt	LCheckBox	*aa_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('AmtB')); FailNIL_(aa_schk);	aa_schk->SetValue(mApp[geraet].mAuto);	// Gebühren	LCheckBox	*geb_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('Gebu')); FailNIL_(geb_schk);	geb_schk->SetValue(mApp[geraet].mGeb);	// ausgehende Nummer	LCheckBox	*clir_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('CLIR')); FailNIL_(clir_schk);	clir_schk->SetValue(mApp[geraet].mDispNum);	// eingehende Nummer	LCheckBox	*colr_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('COLR')); FailNIL_(colr_schk);	colr_schk->SetValue(mApp[geraet].mSendNum);	// Schaltberechtigung	LCheckBox	*schalt_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('Scha')); FailNIL_(schalt_schk);	schalt_schk->SetValue(mApp[geraet].mAVABer);	// TFE-Berechtigung	LCheckBox	*tfe_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('TFEB')); FailNIL_(tfe_schk);	tfe_schk->SetValue(mApp[geraet].mTFE);	// KeyPad Prozeduren	LCheckBox	*keypad_schk = dynamic_cast<LCheckBox*>(theDialog->FindPaneByID('KeyP')); FailNIL_(keypad_schk);	keypad_schk->SetValue(mApp[geraet].mKeyPad);	theDialog->Show();	while (true) {					// Let DialogHandler process events		if(spop1->GetValue() != theDispBer)		{			if(spop1->GetValue() >= 4)	// kein Amt erlaubt?			{				aa_schk->SetValue(false);				aa_schk->Disable();			} else				aa_schk->Enable();			theDispBer = spop1->GetValue();		}		if(theDispDienst != spop2->GetValue())		{			LTextGroupBox	*bere_box = dynamic_cast<LTextGroupBox*>(theDialog->FindPaneByID('Bere')); FailNIL_(bere_box);			LTextGroupBox	*wopt_box = dynamic_cast<LTextGroupBox*>(theDialog->FindPaneByID('WOpt')); FailNIL_(wopt_box);			if(spop2->GetValue() >= 8 || spop2->GetValue() == 1)			{				intNo->Disable();				msn_box->Disable();				bere_box->Disable();				wopt_box->Disable();			} else {				intNo->Enable();				msn_box->Enable();				bere_box->Enable();				wopt_box->Enable();			}			theDispDienst = spop2->GetValue();		}		MessageT	hitMessage = theHandler.DoDialog();		if (hitMessage == msg_Cancel) {			break;		} else if (hitMessage == msg_OK) {			bool	theDoUpdate = false;			// interne Rufnummer			int	appNo = intNo->GetValue();			if(mApp[geraet].mAppNo != appNo)			{				int	i;				for(i=MAX_APP_COUNT-1; i>=0; --i)				{					if(mApp[i].mAppNo != appNo)						continue;					if(i == geraet)						continue;					break;				}				if(i<0)				{					mApp[geraet].mAppNo = appNo;					theDoUpdate = true;					SetDirty();				} else				{//					theDialog->SwitchTarget(intNo);					intNo->SelectAll();					::SysBeep(10);					continue;				}			}			for(int i=0; i<2; ++i)			{				if(theMSN[i] != msn_spop[i]->GetValue()) {					mApp[geraet].mMSN[i] = msnConvTable[i][msn_spop[i]->GetValue()-1];					SetDirty();				}			}			LStr255	nameNeu;			editName->GetDescriptor(nameNeu);			if(nameNeu != theGName) {				SetAppName(geraet, nameNeu);				theDoUpdate = true;				SetDirty();			}			if(theBer != spop1->GetValue()) {				Endgeraeteberechtigung	bb;				switch(spop1->GetValue())				{				case 1:	bb = EB_Vollamt; break;				case 2:	bb = EB_Inland; break;				case 3:	bb = EB_Ort; break;				case 4:	bb = EB_Halbamt; break;				default:bb = EB_Intern; break;				}				mApp[geraet].mBer = bb;				SetDirty();			}			if(theDienst != spop2->GetValue()) {				Endgeraetedienst	dd;				switch(spop2->GetValue())				{				case 2:	dd = Endgeraetedienst_Fernsprechen; break;				case 3:	dd = Endgeraetedienst_Anrufbeantworter; break;				case 4:	dd = Endgeraetedienst_Kombi; break;				case 5:	dd = Endgeraetedienst_Modem; break;				case 6:	dd = Endgeraetedienst_Fax; break;				case 7:	dd = Endgeraetedienst_Digital; break;				case 8: dd = Endgeraetedienst_MusikIn; break;				case 9: dd = Endgeraetedienst_Tuerstelle; break;				default:dd = Endgeraetedienst_Unbekannt; break;				}				if(dd == Endgeraetedienst_MusikIn)				{					mKonfig.mMusic = 3;				} else {					if(mKonfig.mMusic == 3 && geraet == 6)						mKonfig.mMusic = 1;				}				mApp[geraet].mActive = dd != Endgeraetedienst_Unbekannt;				if(IsAppActive(geraet))					mApp[geraet].mDienst = dd;				else					mApp[geraet].mDienst = IsAppDigital(geraet) ? Endgeraetedienst_Digital : Endgeraetedienst_Fernsprechen;				SetDirty();				theDoUpdate = true;			}			// IWV?			if((mApp[geraet].mWahl == 0) != iwv_schk->GetValue() && !IsAppDigital(geraet)) {				mApp[geraet].mWahl = !iwv_schk->GetValue();				SetDirty();			}			// auto-amt			if(mApp[geraet].mAuto != aa_schk->GetValue()) {				mApp[geraet].mAuto = aa_schk->GetValue();				SetDirty();			}			// Gebühren			if(mApp[geraet].mGeb != geb_schk->GetValue()) {				mApp[geraet].mGeb = geb_schk->GetValue();				SetDirty();			}			// CLIR			if(mApp[geraet].mDispNum != clir_schk->GetValue()) {				mApp[geraet].mDispNum = clir_schk->GetValue();				SetDirty();			}			// COLR			if(mApp[geraet].mSendNum != colr_schk->GetValue()) {				mApp[geraet].mSendNum = colr_schk->GetValue();				SetDirty();			}			// Schaltberechtigung			if(mApp[geraet].mAVABer != schalt_schk->GetValue()) {				mApp[geraet].mAVABer = schalt_schk->GetValue();				SetDirty();			}			// TFE-Berechtigung			if(mApp[geraet].mTFE != tfe_schk->GetValue()) {				mApp[geraet].mTFE = tfe_schk->GetValue();				SetDirty();			}			// KeyPad Prozeduren			if(mApp[geraet].mKeyPad != keypad_schk->GetValue()) {				mApp[geraet].mKeyPad = keypad_schk->GetValue();				SetDirty();			}			// Richtung			if(mApp[geraet].mRichtung != (richt_spop->GetValue() - 1)) {				mApp[geraet].mRichtung = richt_spop->GetValue() - 1;				SetDirty();			}			CheckData();			if(theDoUpdate)				ExecuteAttachments(msg_AnlageDirty, nil);			break;		}	}}/*** *	Kommunikation mit der Elmeg Anlage ***/#include <stdarg.h>#include <stdio.h>#include <stdlib.h>#include <ctype.h>#include <string.h>// einen String einzelner Bytes sendenvoid		CElmeg::SendLine(const char *iString){	FailNIL_(mSd);#if 0	mSd->Write(StringPtr(iString), ::strlen(iString));#else	UInt8	cc;	while((cc = *iString++) != 0)	{		mSd->Write(&cc, 1);		UInt32	time;		::Delay(cc == 13 ? 5 : 1, &time);	// min. 10ms Pause zwischen den einzelnen Bytes	}#endif}// eine Befehlszeile sendenvoid		CElmeg::SendData(const char *fmt, ...){	va_list	theList;	va_start(theList, fmt);	char	theBuf[256];	::vsprintf(theBuf, fmt, theList);	va_end(theList);	::strcat(theBuf, "\r");			// stets ein CR anhängen	SendLine(theBuf);}// eine Zeile lesenint		CElmeg::GetData(char *theBuf){	FailNIL_(mSd);	mSd->SetTimeout(mTimeout ? mTimeout : 30);		// 1/2s Timeout für das 1. Byte	int		bufPos = 0;	while(1)	{		UInt8	c;		short	count = mSd->Read(&c, 1);		if(count == 0)				// keine Daten!			break;		if(c == 10) continue;		// LF ignorieren!		if(c == 13)					// CR = Zeilenende		{			if(bufPos == 0)			// Buffer leer?				continue;			// => Leerzeile überlesen!			break;					// Zeile gefunden!		}		mSd->SetTimeout(10);		// 1/6s Timeout für die Folgebytes		theBuf[bufPos++] = c;	}	theBuf[bufPos] = 0;	return bufPos;}// Befehlszeile senden und Fehlercode abwartenint			CElmeg::SendCmd(const char *fmt, ...){	char	theBuf[256];	va_list	theList;	va_start(theList, fmt);	::vsprintf(theBuf, fmt, theList);	va_end(theList);	int tryCount = 3;again:	SendData(theBuf);				// Befehl abschicken	char	theResult[256];	GetData(theResult);				// Antwort abwarten	if(theResult[0] == 'O' && theResult[1] == 'K' && theResult[2] == ' ')		return 0;					// alles ok	if(theResult[0] == 'N' && theResult[1] == 'O' && theResult[2] == 'K' && theResult[3] == ':')	{		if(--tryCount > 0)			// bei "NOK:" geben wir uns 3 Versuche!			goto again;		return ::atoi(theResult+5);	// Fehlercode zurückgeben	}	return ioErr;}// Befehlszeile senden und Fehlercode abwartenint			CElmeg::Send(char *result, const char *fmt, ...){	va_list	theList;	va_start(theList, fmt);	char	theBuf[256];	::vsprintf(theBuf, fmt, theList);	va_end(theList);	int tryCount = 3;again:	SendData(theBuf);				// Befehl abschicken	GetData(result);				// Antwort abwarten	if(result[0] == 'O' && result[1] == 'K' && result[2] == ' ')		return 0;					// alles ok	if(result[0] == 'N' && result[1] == 'O' && result[2] == 'K' && result[3] == ':')	{		if(--tryCount > 0)			// bei "NOK:" geben wir uns 3 Versuche!			goto again;		return ::atoi(result+5);	// Fehlercode zurückgeben	}	return -1;}/*** *	Übertragung vorbereiten (mit Error Toleranz) ***/void		CElmeg::Prepare(char *oVersion, bool inDoSetProg){	char	buf[128];	CursHandle	theCursH = ::GetCursor(watchCursor);	if(theCursH != nil)		::SetCursor(*theCursH);	mTimeout = 0L;	bool	ok = false;	for(int i=0; i<3; ++i)		// 3 Versuche	{		SendCmd("prog_end");		if(inDoSetProg)		{			int err = Send(buf, "prog_start");			if(::strcmp(buf, "PROG_START") != 0)				continue;		}		// Versionsnummer abfragen		Send(buf, "*90");		if(::strncmp(buf, "ISDN TkAnl", 10) != 0)			continue;		::strcpy(oVersion, buf);		SendCmd("82#");		ok = true;		break;	}	if(!ok) Throw_(ioErr);}/*** *	Übertragung vorbereiten (mit Error Toleranz) ***/void		CElmeg::Finish(){	mTimeout = 0L;	::InitCursor();	FailNIL_(mSd);	mSd->FlushIO();	SendCmd("prog_end");	FailNIL_(mSd);	mSd->FlushIO();}/*** *	Elmeg auslesen ***/void		CElmeg::Auslesen(){	CElmegApp		*iApp = new CElmegApp[MAX_APP_COUNT];	CElmegKonfig	*iKonfig = new CElmegKonfig;	// Konfiguration sichern	*iKonfig = mKonfig;	for(int i=0; i<MAX_APP_COUNT; ++i)		iApp[i] = mApp[i];	SetDefault();	try{		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err, 130);			return;		} 		mSd = &sd;		ProgressBar	pb(1000, 1, 12 + MAX_APP_COUNT);		int			progressIndex = 0;		pb.SetInfo("\pLese Basis Konfiguration");		pb.Set(progressIndex++);		char	buf[1024];		Prepare(buf);		::strcpy((char*)mKonfig.mVersion, buf); ::c2pstr((char*)mKonfig.mVersion);		mKonfig.mAnlage = ELMEG_C88;		if(mKonfig.mVersion[19] == '3')			mKonfig.mAnlage = ELMEG_C68;		// MOH Konfiguration abfragen		pb.Set(progressIndex++);Send(buf, "*97");		if(::strncmp(buf, "MOH: ", 5)) Throw_(ioErr);		if(buf[5] == 'I')			// INTERN 1/2/-		{			if(buf[12] == '-')		// MOH ausgeschaltet				mKonfig.mMusic = 0;			else				mKonfig.mMusic = buf[12] - '0';	// Melodie 1 oder 2		} else if(buf[6] == 'E')	// EXTERN		{			mKonfig.mMusic = 3;		} else			Throw_(ioErr);		// Ausgabe des Gebührenprotokolls		pb.Set(progressIndex++);Send(buf, "*83");		if(::strncmp(buf, "GEB.PROT:", 9)) Throw_(ioErr);		switch(buf[10]) {		case 'F':	mKonfig.mGebInfo = 1; break;	// Funktionsprotokoll		case 'K':	mKonfig.mGebInfo = 0; break;	// Keypad		default:	// 'A'				 	mKonfig.mGebInfo = 2; break;	// Alles		}		// Rufnummernverteilung intern		pb.SetInfo("\pLese Rufnummernverteilung intern");		pb.Set(progressIndex++);Send(buf, "*00");		for(int i=0; i<3; ++i)		{			if(buf[0] != 'I') Throw_(ioErr);			if(buf[1] != (i + '1'))  Throw_(ioErr);			for(int j=0; j<10; ++j)			{				int		app = (buf[1] - '1') * 10 + 8 + j;				UInt8	c = buf[4 + j * 3];				if(c == ' ' || c == '-')				{					mApp[app].mAppNo = -1;					mApp[app].mActive = false;				} else {					mApp[app].mAppNo = (c - '0') * 10 + (buf[4 + j * 3 + 1] - '0');					mApp[app].mActive = true;				}			}			GetData(buf);		}		pb.SetInfo("\pLese Endgerätekonfiguration");		for(int i=0; i<8; ++i)		{			if(buf[0] != 'A') Throw_(ioErr);			int	index = buf[1] - '1';			if(index != i)  Throw_(ioErr);			mApp[i].mAppNo = (buf[11] - '0') * 10 + (buf[12] - '0');			UInt32	theDienst = (UInt32(buf[4]) << 16) | (UInt32(buf[5]) << 8) | UInt8(buf[6]);			Endgeraetedienst dd;			switch(theDienst) {			case 'KEG': dd = Endgeraetedienst_Unbekannt; break;			case 'TEL': dd = Endgeraetedienst_Fernsprechen; break;			case 'ARU': dd = Endgeraetedienst_Anrufbeantworter; break;			case 'MOD': dd = Endgeraetedienst_Modem; break;			case 'FAX': dd = Endgeraetedienst_Fax; break;			case 'MUL': dd = Endgeraetedienst_Kombi; break;			case 'MOH': dd = Endgeraetedienst_MusikIn; break;			case 'TFE': dd = Endgeraetedienst_Tuerstelle; break;			default:	dd = Endgeraetedienst_Unbekannt; break;			}			mApp[i].mDienst = dd;			mApp[i].mWahl = buf[8] == 'M';	// MFV oder 'I'?			GetData(buf);		}		pb.SetInfo("\pLese Amtskonfiguration");		// Amtskonfiguration, globale Amtsanlassung		pb.Set(progressIndex++);Send(buf, "*10");		if(::strncmp(buf, "AMT 1 ", 6)) Throw_(ioErr);		mKonfig.mAnschlussArt[0] = buf[7] != 'M';		mKonfig.mAmtAnschl = 0;		GetData(buf);		if(::strncmp(buf, "AMT 2 ", 6)) Throw_(ioErr);		mKonfig.mAnschlussArt[1] = buf[7] != 'M';		if(buf[6] != '-')			mKonfig.mAmtAnschl++;		GetData(buf);		if(::strncmp(buf, "AMTSANLASSUNG:", 14)) Throw_(ioErr);		if(buf[15] == '*')			mKonfig.mBelegZiffer = -1;		else			mKonfig.mBelegZiffer = buf[15] - '0';		pb.SetInfo("\pLese Amtsrufnummern");		// Amtskonfiguration (Rufnummern)		pb.Set(progressIndex++);Send(buf, "*11");		BlockFill(&mKonfig.mMSN, 0, sizeof(mKonfig.mMSN));		for(int j=0; j<2; ++j)		{			if(::strncmp(buf, "AMT ", 4)) Throw_(ioErr);			if(buf[6] == '-')		// keine Nummern?				continue;			if(buf[7] == 'M')		// PMP Anschluß			{				mKonfig.mAnl[j][0] = 0;		// PP Nummer löschen				GetData(buf);				for(int i=0; i<10; ++i)				{					// maximal 10 PMP Nummern übertragen					if(buf[0] != i + '0') Throw_(ioErr);					mKonfig.mMSN[j][i][0] = 0;					if(buf[4] != '-')					{						for(int pos=0; pos<18; ++pos)						{							UInt8	c = buf[pos+4];							if(!isdigit(c))								break;							mKonfig.mMSN[j][i][pos+1] = c;							mKonfig.mMSN[j][i][0]++;						}					}					if(buf[22] == 'A')		// AVA					{						mKonfig.mAVAMSN[j][i] = true;					} else {						mKonfig.mAVAMSN[j][i] = false;						for(int k=0; k<8; ++k)						{							UInt8	c = buf[22 + k * 3];							if(c == ' ' || c == '-')								mKonfig.mApp[j][i][k] = -1;							else								mKonfig.mApp[j][i][k] = (c - '0') * 10 + (buf[22 + k * 3 + 1] - '0');						}					}					GetData(buf);				}			} else if(buf[7] == 'P')	// PP Anschluß			{				// PMP Nummern löschen				for(int i=0; i<10; ++i)					mKonfig.mMSN[j][i][0] = 0;				// PP Nummer übertragen				::strcpy((char*)mKonfig.mAnl[j], buf + 10); ::c2pstr((char*)mKonfig.mAnl[j]);				GetData(buf);			} else Throw_(ioErr);		}		pb.SetInfo("\pLese Endgeräteamtseinstellungen");		// Amtskonfiguration (Rufnummern)		for(int i=0; i<MAX_APP_COUNT; ++i)		{			pb.Set(progressIndex++);			int	app = GetAppNo(i);			if(app < 0) continue;			Send(buf, "*20%2.2ld", long(app));			if(::strncmp(buf, "TLN AMTB", 8)) Throw_(ioErr);	// Titelzeile ignorieren			GetData(buf);			UInt32	theBer = (UInt32(buf[4]) << 24) | (UInt32(buf[5]) << 16) | (UInt32(buf[6]) << 8) | UInt8(buf[7]);			Endgeraeteberechtigung eb;			switch(theBer) {			case 'INAT': eb = EB_Vollamt; break;			case 'NAT ': eb = EB_Inland; break;			case 'ORT ': eb = EB_Ort; break;			case 'HALB': eb = EB_Halbamt; break;			case 'NAMT': eb = EB_Intern; break;			default:	eb = EB_keine; break;			}			mApp[i].mBer = eb;					// AMTB			mApp[i].mDispNum = buf[10] - '0';	// CLIR												// CW = ????????			mApp[i].mAVABer = buf[18] - '0';	// SAT			mApp[i].mTFE = buf[22] - '0';		// TFE			mApp[i].mGeb = buf[26] - '0';		// GEB			mApp[i].mAuto = buf[30] - '0';		// AAH			mApp[i].mRichtung = buf[34] - '0';	// RA			mApp[i].mMSN[0] = -1;			if(buf[38] != '-')				mApp[i].mMSN[0] = buf[38] - '0';// MI1			mApp[i].mMSN[1] = -1;			if(buf[42] != '-')				mApp[i].mMSN[1] = buf[42] - '0';// MI2			mApp[i].mKeyPad = buf[46] - '0';	// KPD			mApp[i].mSendNum = buf[50] - '0';	// COLR		}		// Anrufvarianten		pb.SetInfo("\pLese Anrufvarianten");		pb.Set(progressIndex++);Send(buf, "*40");		/*		AVA 1 *:		FERNSPR 10 40 41 42 43 44		DAT_64K 52682650           40		FAX_2/3		FAX___4 13		AVA 2 :		FERNSPR 1345678901345678   14		DAT_64K 15		FAX_2/3 16		FAX___4 17		*/		for(int i=0; i<2; ++i)		// AVA Tag/Nacht		{			if(::strncmp(buf, "AVA ", 4)) Throw_(ioErr);			if(i == 0)				mKonfig.mAVA = buf[6] == '*' ? 0 : 1;	// Tag oder Nacht aktiv?			for(int j=0; j<4; ++j)			{				GetData(buf);				if(buf[10] == ' ')	// AVA intern?				{					mKonfig.mAVA_Extern[i][j] = false;					mKonfig.mAVA_Ext[i][j][0] = 0;					mKonfig.mAVA_Geb[i][j] = -1;					for(int k=0; k<6; ++k)					{						UInt8	c = buf[8 + k * 3];						if(c == ' ' || c == '-')							mKonfig.mAVA_Var[i][j][k] = -1;						else							mKonfig.mAVA_Var[i][j][k] = (c - '0') * 10 + (buf[8 + k * 3 + 1] - '0');					}				} else {			// AVA extern					mKonfig.mAVA_Extern[i][j] = true;					for(int k=0; k<6; ++k)						mKonfig.mAVA_Var[i][j][k] = -1;					mKonfig.mAVA_Ext[i][j][0] = 0;					for(int pos=0; pos<18; ++pos)					{						UInt8	c = buf[pos+8];						if(!isdigit(c))							break;						mKonfig.mAVA_Ext[i][j][pos+1] = c;						mKonfig.mAVA_Ext[i][j][0]++;					}					mKonfig.mAVA_Geb[i][j] = (buf[27] - '0') * 10 + (buf[28] - '0');				}			}			GetData(buf);		}		// TFE		pb.SetInfo("\pLese TFE");		pb.Set(progressIndex++);Send(buf, "*50");		/*		TFE 1 *: 10 11 12 13 14 15		TFE 2 : 1234567890123456		*/		for(int i=0; i<2; ++i)		{			if(::strncmp(buf, "TFE ", 4)) Throw_(ioErr);			int	offset = 8;			if(i == 0)			{				++offset;				mKonfig.mTAVA = (buf[6] == '*') ? 0 : 1;			}			if(buf[offset+2] == ' ')	// TFE intern?			{				mKonfig.mTFE_Extern[i] = false;				mKonfig.mTFE_Ext[i][0] = 0;				for(int k=0; k<6; ++k)				{					UInt8	c = buf[offset + k * 3];					if(c == ' ' || c == '-')						mKonfig.mTFE_Var[i][k] = -1;					else						mKonfig.mTFE_Var[i][k] = (c - '0') * 10 + (buf[offset + k * 3 + 1] - '0');				}			} else {			// AVA extern				mKonfig.mTFE_Extern[i] = true;				for(int k=0; k<6; ++k)					mKonfig.mTFE_Var[i][k] = -1;				mKonfig.mTFE_Ext[i][0] = 0;				for(int pos=0; pos<16; ++pos)				{					UInt8	c = buf[pos+offset];					if(!isdigit(c))						break;					mKonfig.mTFE_Ext[i][pos+1] = c;					mKonfig.mTFE_Ext[i][0]++;				}			}			GetData(buf);		}		// Kurzwahlen 00..49/50..99		pb.SetInfo("\pLese Kurzwahlen");		for(int k=0; k<2; ++k)		{			pb.Set(progressIndex++);Send(buf, k == 0 ? "*770" : "*775");			/*			KW ZIELRUFNUMMER    KW ZIELRUFNUMMER    KW ZIELRUFNUMMER    KW ZIELRUFNUMMER			00 52682041         01 1234567890123456 02 -                03 -			04 -                05 -                06 -                07 -			08 -                09 -                10 -                11 -			12 -                13 -                14 -                15 -			16 -                17 -                18 -                19 -			20 -                21 -                22 -                23 -			24 -                25 -                26 -                27 -			28 -                29 -                30 -                31 -			32 -                33 -                34 -                35 -			36 -                37 -                38 -                39 -			40 -                41 -                42 -                43 -			44 -                45 -                46 -                47 -			48 -                49 -			*/			if(::strncmp(buf, "KW ", 3)) Throw_(ioErr);			for(int i=0; i<13; ++i)			{				GetData(buf);				for(int j=0; j<4; ++j)				{					int	offset = j * 20;					if(offset >= ::strlen(buf))						break;					int	index = (buf[offset] - '0') * 10 + (buf[offset+1] - '0');					mKonfig.mKurz[index][0] = 0;					for(int pos=0; pos<16; ++pos)					{						UInt8	c = buf[pos+offset+3];						if(!isdigit(c))							break;						mKonfig.mKurz[index][pos+1] = c;						mKonfig.mKurz[index][0]++;					}				}			}		}		if(GetVersion() >= 0x300)		{			pb.SetInfo("\pLese Sperrwerk");			// Sperrwerk			// SPERRWERK			// 00 -                01 -                02 -                03 -			// 04 -                05 -                06 -                07 -			// 08 -                09 -			pb.Set(progressIndex++);Send(buf, "*78");			if(::strcmp(buf, "SPERRWERK")) Throw_(ioErr);			for(int i=0; i<3; ++i)			{				GetData(buf);				for(int j=0; j<4; ++j)				{					int	offset = j * 20;					if(offset >= ::strlen(buf))						break;					int	index = (buf[offset] - '0') * 10 + (buf[offset+1] - '0');					mKonfig.mSperr[index][0] = 0;					for(int pos=0; pos<16; ++pos)					{						UInt8	c = buf[pos+offset+3];						if(!isdigit(c))							break;						mKonfig.mSperr[index][pos+1] = c;						mKonfig.mSperr[index][0]++;					}				}			}			// Freiwerk			// FREIWERK			// 00 -                01 -                02 -                03 -			// 04 -                05 -                06 -                07 -			// 08 -                09 -                10 -                11 -			// 12 -                13 -                14 -                15 -			// 16 -                17 -                18 -                19 -			// 20 -                21 -                22 -                23 -			// 24 -                25 -                26 -                27 -			// 28 -                29 -			pb.SetInfo("\pLese Freiwerk");			pb.Set(progressIndex++);Send(buf, "*79");			if(::strcmp(buf, "FREIWERK")) Throw_(ioErr);			for(int i=0; i<8; ++i)			{				GetData(buf);				for(int j=0; j<4; ++j)				{					int	offset = j * 20;					if(offset >= ::strlen(buf))						break;					int	index = (buf[offset] - '0') * 10 + (buf[offset+1] - '0');					mKonfig.mFrei[index][0] = 0;					for(int pos=0; pos<16; ++pos)					{						UInt8	c = buf[pos+offset+3];						if(!isdigit(c))							break;						mKonfig.mFrei[index][pos+1] = c;						mKonfig.mFrei[index][0]++;					}				}			}		}		Finish();		pb.Set(progressIndex++);		SetDirty();		mSd = 0L;		ExecuteAttachments(msg_AnlageDirty, nil);	}	catch(LException err) {		// alte Konfiguration zurücksetzen		mKonfig = *iKonfig;		for(int i=0; i<MAX_APP_COUNT; ++i)			mApp[i] = iApp[i];		ErrorAlert(err);	} 	delete[] iApp;	delete iKonfig;}/*** *	Elmeg wegschreiben ***/#if !DEMO_VERSIONvoid		CElmeg::Senden(){	try{		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err, 130);			return;		} 		mSd = &sd;		ProgressBar	pb(1000, 2, 110 + 10 + 30 + MAX_APP_COUNT * 3);		int			progressIndex = 0;		int			err = 0;		char		buf[128];		Prepare(buf);		// Globale Amtsanlassung		pb.SetInfo("\pSende Basis Konfiguration");		if(mKonfig.mBelegZiffer >= 0)		{			if((err = SendCmd("00%c", mKonfig.mBelegZiffer + '0')) != 0) Throw_(err);		} else {			if((err = SendCmd("00*")) != 0) Throw_(err);		}		pb.Set(progressIndex++);		// Löschen aller internen Rufnummern		if((err = SendCmd("01*")) != 0) Throw_(err);		// Analoge Endgeräte		pb.SetInfo("\pSende analoge Endgeräte");		for(int i=0; i<8; ++i)		{			pb.Set(progressIndex++);			if(GetAppNo(i) < 0)				continue;			int	typ = '0';			switch(GetAppDienst(i))			{			case Endgeraetedienst_Fernsprechen:		typ = '1'; break;			case Endgeraetedienst_Fax:				typ = '4'; break;			case Endgeraetedienst_Modem:			typ = '3'; break;			case Endgeraetedienst_Anrufbeantworter:	typ = '2'; break;			case Endgeraetedienst_Kombi:			typ = '5'; break;			case Endgeraetedienst_Tuerstelle:		typ = '7'; break;			case Endgeraetedienst_MusikIn:			typ = '6'; break;			}			if((err = SendCmd("07%c%c", i+'1', typ)) != 0) Throw_(err);			if((err = SendCmd("08%c%c", i+'1', mApp[i].mWahl + '1')) != 0) Throw_(err);			if((err = SendCmd("03%c%2.2d", i+'1', int(GetAppNo(i)))) != 0) Throw_(err);		}		pb.SetInfo("\pSende digitale Endgeräte");		// Digitale Endgeräte		for(int i=8; i<MAX_APP_COUNT; ++i)		{			pb.Set(progressIndex++);			if(GetAppNo(i) < 0)				continue;			if((err = SendCmd("02%c%2.2d", (i-8) / 10 + '1', int(GetAppNo(i)))) != 0) Throw_(err);		}		// Amtskonfiguration		pb.SetInfo("\pSende Amtseinstellungen");		if(mKonfig.mAnschlussArt[0] == mKonfig.mAnschlussArt[1])	// identische Konfiguration?		{			const char	*amtStr;			if(mKonfig.mAnschlussArt[0] == 0)				amtStr = "10#";		// PMP			else				amtStr = "10*";		// PP			if((err = SendCmd(amtStr)) != 0) Throw_(err);		} else {			if((err = SendCmd(mKonfig.mAnschlussArt[0] == 0 ? "101#" : "101*")) != 0) Throw_(err);			if(GetExtS0() > 1)				if((err = SendCmd(mKonfig.mAnschlussArt[1] == 0 ? "102#" : "102*")) != 0) Throw_(err);		}		pb.Set(progressIndex++);		if(mKonfig.mAnschlussArt[0] == 0)		{			for(int i=0; i<10; ++i)			{				if(mKonfig.mMSN[0][i][0] == 0)				{					if((err = SendCmd("14%c#", i+'0')) != 0) Throw_(err);				} else {					if((err = SendCmd("14%c%#s#", i+'0', mKonfig.mMSN[0][i])) != 0) Throw_(err);					if((err = SendCmd("18%c*", i+'0')) != 0) Throw_(err);					if((err = SendCmd("16%c*", i+'0')) != 0) Throw_(err);					for(int j=0; j<8; ++j)					{						if(mKonfig.mApp[0][i][j]<0)							continue;						if((err = SendCmd("16%c%2.2d", i+'0', int(mKonfig.mApp[0][i][j]))) != 0) Throw_(err);					}				}			}		} else {			if((err = SendCmd("11%#s#", mKonfig.mAnl[0])) != 0) Throw_(err);		}		pb.Set(progressIndex++);		if(GetExtS0() > 1)		// ggf. für den 2. externen S0 Bus ebenfalls konfigurieren		{			pb.SetInfo("\pSende 2.Amtseinstellungen");			if(mKonfig.mAnschlussArt[1] == 0)			{				for(int i=0; i<10; ++i)				{					if(mKonfig.mMSN[1][i][0] == 0)					{						if((err = SendCmd("15%c#", i+'0')) != 0) Throw_(err);					} else {						if((err = SendCmd("15%c%#s#", i+'0', mKonfig.mMSN[1][i])) != 0) Throw_(err);						if((err = SendCmd("19%c*", i+'0')) != 0) Throw_(err);						if((err = SendCmd("17%c*", i+'0')) != 0) Throw_(err);						for(int j=0; j<8; ++j)						{							if(mKonfig.mApp[1][i][j]<0)								continue;							if((err = SendCmd("17%c%2.2d", i+'0', int(mKonfig.mApp[1][i][j]))) != 0) Throw_(err);						}					}				}			} else {				if((err = SendCmd("12%#s#", mKonfig.mAnl[1])) != 0) Throw_(err);			}		}		// MSN Signalisierung		pb.SetInfo("\pSende MSN Signalisierung");		for(int i=0; i<MAX_APP_COUNT; ++i)		{			pb.Set(progressIndex++);			if(GetAppNo(i) < 0)				continue;			if(mApp[i].mMSN[0] < 0)			{				if((err = SendCmd("32%2.2d", int(GetAppNo(i)))) != 0) Throw_(err);			} else {				if((err = SendCmd("300%2.2d", int(mApp[i].mMSN[0]))) != 0) Throw_(err);			}			if(GetExtS0() > 1)			{				if(mApp[i].mMSN[1] < 0)				{					if((err = SendCmd("33%2.2d", int(GetAppNo(i)))) != 0) Throw_(err);				} else {					if((err = SendCmd("310%2.2d", int(mApp[i].mMSN[1]))) != 0) Throw_(err);				}			}		}		pb.Set(progressIndex++);		// AVA		pb.SetInfo("\pSende AVA");		if((err = SendCmd("40%c", mKonfig.mAVA + '1')) != 0) Throw_(err);		for(int k=0; k<2; ++k)		{			for(int i=0; i<4; ++i)			{				if((err = SendCmd("4%c%c*", k*3+'1', i+'1')) != 0) Throw_(err);				if(mKonfig.mAVA_Extern[k][i])				{					if((err = SendCmd("4%c%c*%#s#", k*3+'2', i+'1', mKonfig.mAVA_Ext[k][i])) != 0) Throw_(err);					if((err = SendCmd("4%c%c%2.2d", k*3+'3', i+'1', mKonfig.mAVA_Geb[k][i])) != 0) Throw_(err);				} else {					for(int j=0; j<6; ++j)					{						if(mKonfig.mAVA_Var[k][i][j] < 0) continue;						if((err = SendCmd("4%c%c%2.2d", k*3+'2', i+'1', mKonfig.mAVA_Var[k][i][j])) != 0) Throw_(err);					}				}			}		}		pb.Set(progressIndex++);		// Türfreisprecheinrichtung		pb.SetInfo("\pSende Türfreisprecheinrichtung");		if((err = SendCmd("50%c", mKonfig.mTAVA + '1')) != 0) Throw_(err);		for(int k=0; k<2; ++k)		{			if((err = SendCmd("5%c*", k*3+'1')) != 0) Throw_(err);			if(mKonfig.mTFE_Extern[k])			{				if((err = SendCmd("5%c*%#s#", k*3+'2', mKonfig.mTFE_Ext[k])) != 0) Throw_(err);			} else {				for(int j=0; j<6; ++j)				{					if(mKonfig.mTFE_Var[k][j] < 0) continue;					if((err = SendCmd("5%c%2.2d", k*3+'2', mKonfig.mTFE_Var[k][j])) != 0) Throw_(err);				}			}		}		// Teilnehmer-Berechtigungen		pb.SetInfo("\pSende Teilnehmer-Berechtigungen");		for(int i=0; i<MAX_APP_COUNT; ++i)		{			pb.Set(progressIndex++);			if(GetAppNo(i) < 0)				continue;			char	b = '4';			switch(GetAppBerechtigung(i)) {			case EB_Vollamt:b = '0'; break;			case EB_Inland:	b = '1'; break;			case EB_Ort:	b = '2'; break;			case EB_Halbamt:b = '3'; break;			}			if((err = SendCmd("20%c%2.2d", b,int(GetAppNo(i)))) != 0) Throw_(err);			if(GetExtS0() > 1)				if((err = SendCmd("21%c%2.2d", mApp[i].mRichtung+'0',int(GetAppNo(i)))) != 0) Throw_(err);			if((err = SendCmd("2%c%2.2d", mApp[i].mAuto ? '3' : '2',int(GetAppNo(i)))) != 0) Throw_(err);			if((err = SendCmd("2%c%2.2d", mApp[i].mTFE ? '5' : '4',int(GetAppNo(i)))) != 0) Throw_(err);			if((err = SendCmd("2%c%2.2d", mApp[i].mAVABer ? '7' : '6',int(GetAppNo(i)))) != 0) Throw_(err);			if((err = SendCmd("2%c%2.2d", mApp[i].mDispNum ? '9' : '8',int(GetAppNo(i)))) != 0) Throw_(err);			if((err = SendCmd("3%c%2.2d", mApp[i].mKeyPad ? '7' : '6',int(GetAppNo(i)))) != 0) Throw_(err);			if((err = SendCmd("3%c%2.2d", mApp[i].mSendNum ? '9' : '8',int(GetAppNo(i)))) != 0) Throw_(err);			if((err = SendCmd("8%c%2.2d", mApp[i].mGeb ? '1' : '0',int(GetAppNo(i)))) != 0) Throw_(err);		}		pb.Set(progressIndex++);		// Kurzwahlen		pb.SetInfo("\pSende Kurzwahlen");		if((err = SendCmd("77#")) != 0) Throw_(err);		for(int i=0; i<100; ++i)		{			pb.Set(progressIndex++);			if(mKonfig.mKurz[i][0] == 0)				continue;			if((err = SendCmd("77%2.2d%#s#", i, mKonfig.mKurz[i])) != 0) Throw_(err);		}		if(GetVersion() >= 0x300)		{			// Sperrwerk			pb.SetInfo("\pSende Sperrwerk");			if((err = SendCmd("78#")) != 0) Throw_(err);			for(int i=0; i<10; ++i)			{				pb.Set(progressIndex++);				if(mKonfig.mSperr[i][0] == 0)					continue;				if((err = SendCmd("78%2.2d%#s#", i, mKonfig.mSperr[i])) != 0) Throw_(err);			}			// Freiwerk			pb.SetInfo("\pSende Freiwerk");			if((err = SendCmd("79#")) != 0) Throw_(err);			for(int i=0; i<30; ++i)			{				pb.Set(progressIndex++);				if(mKonfig.mFrei[i][0] == 0)					continue;				if((err = SendCmd("79%2.2d%#s#", i, mKonfig.mFrei[i])) != 0) Throw_(err);			}		}		pb.Set(progressIndex++);		// Gebühren etc.		pb.SetInfo("\pSende restliche Einstellungen");		if(mKonfig.mGebInfo == 2)		{			if((err = SendCmd("83*")) != 0) Throw_(err);		} else {			if((err = SendCmd("83%c", mKonfig.mGebInfo+'1')) != 0) Throw_(err);		}		pb.Set(progressIndex++);		if(mKonfig.mMusic < 3)		{			if((err = SendCmd("97%c", mKonfig.mMusic+'0')) != 0) Throw_(err);		}		pb.Set(progressIndex++);		Finish();	}	catch(LException err) {		if(err != userCanceledErr)			ErrorAlert(err);	} 	::InitCursor();	mSd = 0L;}#endif/*** *	Passwort in der Elmeg ändern ***/void		CElmeg::ChangePasswort(){	try{		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err, 130);			return;		} 		StDialogHandler	theHandler(3700, this);		LWindow		*theDialog = theHandler.GetDialog();		LStr255		thePIN("\p0000");		theDialog->Show();		while(true) {			MessageT	hitMessage = theHandler.DoDialog();			if(hitMessage == msg_Cancel) {				return;			} else if(hitMessage == msg_OK) {				LEditText	*editName = dynamic_cast<LEditText*>(theDialog->FindPaneByID('MSNv')); FailNIL_(editName);				editName->GetDescriptor(thePIN);				break;			}		}		mSd = &sd;		char		buf[128];		Prepare(buf);		// neue PIN senden		Send(buf, "92%#s%#s", StringPtr(thePIN), StringPtr(thePIN));		Finish();	}	catch(LException err) {		if(err != userCanceledErr)			ErrorAlert(err);	} 	::InitCursor();	mSd = 0L;}/*** *	Anrufweiterschaltung setzen ***/void		CElmeg::Anrufweiterschaltung(){	StDialogHandler	theHandler(3600, this);	LWindow		*theDialog = theHandler.GetDialog();	LPopupButton	*pop_but = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('MSNc')); FailNIL_(pop_but);	SInt16	msnConvTable[20];	BlockFill(&msnConvTable, -1, sizeof(msnConvTable));	MenuRef		mref = pop_but->GetMacMenuH();	FailNIL_(mref);	for(int i=::CountMenuItems(mref); i>0; --i)		::DeleteMenuItem(mref, 1);	int	menuCount = 0;	for(int j=0; j<GetExtS0(); ++j)	{		for(int i=-1; i<10; ++i)		{			if(i >= 0 && mKonfig.mMSN[j][i][0] == 0)				continue;			msnConvTable[menuCount] = (j << 8) | UInt8(i);			LStr255	theStr(3000, j+1);			if(i < 0)			{				theStr += LStr255(3000,3);			} else {				theStr += LStr255(mKonfig.mMSN[j][i]);			}			::AppendMenu(mref, "\p ");			::SetMenuItemText(mref, ::CountMenuItems(mref), theStr);			++menuCount;		}	}	pop_but->SetMaxValue(menuCount);	pop_but->SetValue(1);	theDialog->Show();	while(true) {		MessageT	hitMessage = theHandler.DoDialog();		if(hitMessage == msg_Cancel) {			break;		} else if(hitMessage == msg_OK) {			LEditText	*editName = dynamic_cast<LEditText*>(theDialog->FindPaneByID('Numm')); FailNIL_(editName);			LStr255		theNumber;			editName->GetDescriptor(theNumber);			int			s0 = msnConvTable[pop_but->GetValue()-1];			LRadioGroupView	*dienst_grp = dynamic_cast<LRadioGroupView*>(theDialog->FindPaneByID('Dien')); FailNIL_(dienst_grp);			LRadioGroupView	*vari_grp = dynamic_cast<LRadioGroupView*>(theDialog->FindPaneByID('Vari')); FailNIL_(vari_grp);			int			theDienst = dienst_grp->GetCurrentRadioID();			int			theVariante = vari_grp->GetCurrentRadioID();			try{				SerialDriver	sd(gPrefs->P.Port, false);				try{					sd.Open();				}				catch(LException err) {					ErrorAlert(err, 130);					return;				} 				mSd = &sd;				char		buf[128];				Prepare(buf, false);				// Weiterleitung setzen				theDienst %= 100;				char	theMSN[2];				int		err;				if(GetAnlageAnschlussart() == 0)				{			// Mehrgeräteanschluß					SInt8	theMSNChar = SInt8(s0);					theMSN[0] = (theMSNChar >= 0) ? (theMSNChar + '0') : '*';					theMSN[1] = 0;				} else {	// Anlagenanschluß					theMSN[0] = 0;				}				mTimeout = 60 * 10;		// 10s Timeout!				if(theVariante != 3650)	// == AUS				{					err = Send(buf, "6%c%2.2d%s%#s#", theVariante % 10 + (s0 >> 8) * 3 + '0', theDienst, theMSN, StringPtr(theNumber));				} else {					int	err1 = Send(buf, "6%c%2.2d%s#", '1' + (s0 >> 8) * 3, theDienst, theMSN);					int	err2 = Send(buf, "6%c%2.2d%s#", '2' + (s0 >> 8) * 3, theDienst, theMSN);					int	err3 = Send(buf, "6%c%2.2d%s#", '3' + (s0 >> 8) * 3, theDienst, theMSN);					if(err3) err = err3;					if(err2) err = err2;					if(err1) err = err1;				}				Finish();				if(err)					ErrorAlert(err);			}			catch(LException err) {				if(err != userCanceledErr)					ErrorAlert(err);			} 			::InitCursor();			mSd = 0L;		}	}}/*** *	Elmeg zurücksetzen ***/void		CElmeg::Reset(){	try{		SerialDriver	sd(gPrefs->P.Port, false);		try{			sd.Open();		}		catch(LException err) {			ErrorAlert(err, 130);			return;		} 		mSd = &sd;		ProgressBar	pb(1000, 7, 20);		int			progressIndex = 0;		pb.Set(progressIndex++);		char		buf[128];		Prepare(buf);		// Programmiermodus unbedingt aus, damit der Reset sofort durchgeführt wird!		SendCmd("prog_end");		// Anlage zurücksetzen		pb.Set(progressIndex++);Send(buf, "90");		for(int i=0; i<20; ++i)		{			pb.Set(progressIndex++);			UInt32	l;			::Delay(60,&l);		// 1s Delay			GetData(buf);		}		Finish();	}	catch(LException err) {		if(err != userCanceledErr)			ErrorAlert(err);	} 	::InitCursor();	mSd = 0L;}#endif