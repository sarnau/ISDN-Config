// ===========================================================================//	CElmeg.cp						©1994 Metrowerks Inc. All rights reserved.// ===========================================================================#include "SharewareFlags.h"#if INCLUDE_ELMEG#include "CElmeg.h"#include <LCaption.h>#include <UModalDialogs.h>#include <string.h>#include "MRFUtilities.h"#include "CPreferences.h"#include <UMemoryMgr.h>#include <LWindow.h>#include <LStdControl.h>#include <LEditField.h>#include <PP_Messages.h>Int32	CElmeg::GetVersion() const{	return 0;}// Versionnummer als String zurückgebenvoid	CElmeg::GetVersionStr(LStr255 &oVersionStr) const{	oVersionStr.Assign(mVersion, strlen(mVersion));}// Namen der Telefonanlage zurückgebenvoid	CElmeg::GetAnlagenName(LStr255 &oAnlageName) const{	switch(GetAnlagenTyp()) {	case AT_L0:  oAnlageName = "\pEumex 306"; break;	case AT_L1:  oAnlageName = "\pEumex 308/2"; break;	case AT_L2:  oAnlageName = "\pEumex 308"; break;	case AT_C23: oAnlageName = "\pElmeg C23"; break;	case AT_C43: oAnlageName = "\pElmeg C43"; break;	}}// Offset eines Apparates auf unsere Struktur ermittelnUInt16	CElmeg::GetAppOffset(SInt16 iAppIndex) const{	for(int i=0; i<GetAppCount(); i++) {		if((mKonfig[0x195 + i * 57 + 43] - '1') == iAppIndex)			return 0x195 + i * 57;	}	return 0x195;}// Durchwahlnummer eines Apparates ermittelnUInt16	CElmeg::GetAppNo(SInt16 iAppIndex) const{	return mKonfig[GetAppOffset(iAppIndex) + 43] - '0';}Endgeraetedienst	CElmeg::GetAppDienst(SInt16 iAppIndex) const{	switch(mKonfig[GetAppOffset(iAppIndex) + 6]) {	default:							return Endgeraetedienst_Unbekannt;	case eAnalogDeviceTelephone:		return Endgeraetedienst_Fernsprechen;	case eAnalogDeviceFax:				return Endgeraetedienst_Fax;	case eAnalogDeviceModem:			return Endgeraetedienst_Modem;	case eAnalogDeviceAnsweringMachine:	return Endgeraetedienst_Anrufbeantworter;	case eAnalogDeviceKombiPort:		return Endgeraetedienst_Kombi;	}}Endgeraeteberechtigung	CElmeg::GetAppBerechtigung(SInt16 iAppIndex) const{	switch(mKonfig[GetAppOffset(iAppIndex)+ 45]) {	default:							return EB_unbekannt;	case eAmtsBerechtigtInterNational:	return EB_Vollamt;	case eAmtsBerechtigtNational:		return EB_Inland;	case eAmtsBerechtigtOrt:			return EB_Ort;	case eAmtsBerechtigtHalbAmt:		return EB_Halbamt;	case eAmtsBerechtigtKeinAmt:		return EB_keine;	}}// Apparat aktiv?Boolean	CElmeg::IsAppActive(SInt16 iAppIndex) const{	return !mKonfig[GetAppOffset(iAppIndex) + 2];}// Namen eines Apparates ermittelnvoid	CElmeg::GetAppName(SInt16 iAppIndex, LStr255 &oAppName) const{	oAppName = mEndgName[iAppIndex];}// Namen eines Apparates ermittelnvoid	CElmeg::SetAppName(SInt16 iAppIndex, const LStr255 &iAppName){	BlockFill(mEndgName[iAppIndex], 0, sizeof(Str31));	LString::CopyPStr(iAppName, mEndgName[iAppIndex], sizeof(Str31));}void	CElmeg::SetDefault(Boolean iOptionalFlag){#pragma unused(iOptionalFlag)	BlockMoveData("01.02", mVersion, 6);	Handle	h = GetResource('DATA', 3000);	FailNIL_(h);	BlockMoveData(*h, mKonfig, sizeof(mKonfig));	mKonfig[2] = gPrefs->P.DefAnlage - 1;	BlockFill(&mEndgName, 0, sizeof(mEndgName));	for(int i=0; i<3; i++) {		LStr255	theAppName(1000, 13);		theAppName += LStr255(Int32(GetAppNo(i)));		LString::CopyPStr(theAppName, mEndgName[i]);	}}CElmeg::CElmeg(){	SetDefault();	SetDirty(false);}// Apparat möglich? Nein => Default-Apparat liefernchar		CElmeg::CheckGoodApp(char inApp, Boolean retNull){#pragma unused(retNull)	return inApp;}// interne Struktur überprüfen und ggf. korrigierenvoid		CElmeg::CheckData(){}Boolean		CElmeg::IsElmegData(Handle inH){	StHandleLocker	lock(inH);	UInt32			theSize = GetHandleSize(inH);	return (*(long*)*inH) == 'ElmG';}void		CElmeg::SetISDNData(Handle inH){	if(inH == nil) {		SetDefault();	} else {		StHandleLocker	lock(inH);		UInt32			theSize = GetHandleSize(inH);		Ptr				pp = *inH;		pp += sizeof(long);		::BlockMoveData(pp, mKonfig, sizeof(mKonfig));		*(long*)(mKonfig + 0x2c) = '0000';		pp += sizeof(mKonfig);		::BlockMoveData(pp, mVersion, sizeof(mVersion));		pp += sizeof(mVersion);		::BlockMoveData(pp, mEndgName, sizeof(mEndgName));	}	CheckData();	GetDefaultAttachable()->ExecuteAttachments(msg_AnlageDirty, nil);}// wir schreiben für die Anlage stets 1kb, für jeden der max. 64 Apparate 1/2kb an Daten.// dazu kommen noch 64 Shorts (die Gebühren)Handle		CElmeg::GetISDNData(){	Handle		h = NewHandleClear(sizeof(long) + sizeof(mKonfig) + sizeof(mVersion) + sizeof(mEndgName));	ThrowIfMemError_(); ThrowIfNil_(h);	StHandleLocker	lock(h);	Ptr		pp = *h;	// Magic	*((long*)pp)++ = 'ElmG';	// Anlagenkonfiguration	*(long*)(mKonfig + 0x2c) = '0000';	::BlockMoveData(&mKonfig, pp, sizeof(mKonfig));	pp += sizeof(mKonfig);	// Versionsnummer der Anlagensoftware anhängen	::BlockMoveData(&mVersion, pp, sizeof(mVersion));	pp += sizeof(mVersion);	// Endgerätenamen anhängen	::BlockMoveData(&mEndgName, pp, sizeof(mEndgName));	pp += sizeof(mEndgName);	return h;}// ---------------------------------------------------------------------------//		• Anlangeinformationen// ---------------------------------------------------------------------------void		CElmeg::AnlageInfoDialog(){	StDialogHandler	theHandler(3000, this);	LWindow		*theDialog = theHandler.GetDialog();	FailNIL_(theDialog);	LCaption *str = (LCaption*) theDialog->FindPaneByID('Anla');	FailNIL_(str);	LStr255	s;	GetAnlagenName(s);	str->SetDescriptor(s);	str = (LCaption*) theDialog->FindPaneByID('SWVe');	FailNIL_(str);	GetVersionStr(s);	str->SetDescriptor(s);	str = (LCaption*) theDialog->FindPaneByID('S0ex');	FailNIL_(str);	str->SetDescriptor((LStr255)(GetExtS0()));	str = (LCaption*) theDialog->FindPaneByID('S0in');	FailNIL_(str);	str->SetDescriptor((LStr255)(GetIntS0()));	str = (LCaption*) theDialog->FindPaneByID('abSc');	FailNIL_(str);	str->SetDescriptor((LStr255)(GetAB()));	LStdPopupMenu	*spop1 = (LStdPopupMenu*) theDialog->FindPaneByID('Ansc');	FailNIL_(spop1);	spop1->SetValue(GetAnlageAnschlussart() + 1);	// MSN	LEditField		*editMSN = (LEditField*)theDialog->FindPaneByID('MSN ');	FailNIL_(editMSN);	char	*smsn = (char*)&mKonfig[0x168];	LStr255	theMSN(smsn, strlen(smsn));	editMSN->SetDescriptor(theMSN);	theDialog->SetLatentSub(editMSN);	editMSN->SelectAll();	LStdPopupMenu	*spop2 = (LStdPopupMenu*) theDialog->FindPaneByID('Dien');	FailNIL_(spop2);	LStdPopupMenu	*spop3 = (LStdPopupMenu*) theDialog->FindPaneByID('Cond');	FailNIL_(spop3);	LEditField		*editName = (LEditField*)theDialog->FindPaneByID('Rufn');	FailNIL_(editName);	int		aktDienst = 0;	// Update erzwingen	// Werte auslesen und merken	LStr255	theW[4];	UInt8	theWTyp[4];	for(int i=0; i<4; i++) {		SInt16	theIndex = 0x33;		switch(i) {		case 1:	theIndex = 0x54; break;		case 2:	theIndex = 0xD8; break;		case 3:	theIndex = 0x13b; break;		}		char	*sp = (char*)&mKonfig[theIndex];		theW[i].Assign(sp, strlen(sp));		theWTyp[i] = mKonfig[theIndex + 31];	}	bool	isVisible = false;	while (true) {		if(aktDienst != spop2->GetValue()) {			if(aktDienst) {				theWTyp[aktDienst - 1] = spop3->GetValue() - 1;				editName->GetDescriptor(theW[aktDienst - 1]);			}			aktDienst = spop2->GetValue();			spop3->SetValue(theWTyp[aktDienst - 1] + 1);			editName->SetDescriptor(theW[aktDienst - 1]);		}		if(!isVisible) {			theDialog->Show();			isVisible = true;		}		MessageT	hitMessage = theHandler.DoDialog();		if(hitMessage == msg_Cancel) {			break;		} else if (hitMessage == msg_OK) {			bool	theDoUpdate = false;			LStr255	msnNeu;			editMSN->GetDescriptor(msnNeu);			if(msnNeu != theMSN) {				LString::CopyPStr(msnNeu, &mKonfig[0x168]);				p2cstr(&mKonfig[0x168]);				SetDirty();			}			if(aktDienst) {				theWTyp[aktDienst - 1] = spop3->GetValue() - 1;				editName->GetDescriptor(theW[aktDienst - 1]);			}			// Werte auslesen und merken			for(int i=0; i<4; i++) {				SInt16	theIndex = 0x33;				switch(i) {				case 1:	theIndex = 0x54; break;				case 2:	theIndex = 0xD8; break;				case 3:	theIndex = 0x13b; break;				}				char	*sp = (char*)&mKonfig[theIndex];				LStr255	theStr(sp, strlen(sp));				int		theTyp = mKonfig[theIndex + 31];				if(theStr == theW[i] && theTyp == theWTyp[i])					continue;				SetDirty();				LString::CopyPStr(theW[i], &mKonfig[theIndex]);				p2cstr(&mKonfig[theIndex]);				mKonfig[theIndex + 31] = theWTyp[i];			}			if(GetAnlageAnschlussart() != (spop1->GetValue() - 1)) {				SetDirty();				mKonfig[0x31] = spop1->GetValue() == 1 ? 2 : 1;				theDoUpdate = true;				StDialogHandler	theHandler(3001, this);				LWindow		*theDialog = theHandler.GetDialog();				theDialog->Show();				while (true) {					// Let DialogHandler process events					MessageT	hitMessage = theHandler.DoDialog();					if (hitMessage == msg_Cancel) {						break;					} else if (hitMessage == msg_OK) {						break;					}				}			}			CheckData();			if(theDoUpdate)				GetDefaultAttachable()->ExecuteAttachments(msg_AnlageDirty, nil);			break;		}	}}// ---------------------------------------------------------------------------//		• Endgeräteinformationen// ---------------------------------------------------------------------------void		CElmeg::GeraetInfoDialog(short geraet){	StDialogHandler	theHandler(3500, this);	LWindow		*theDialog = theHandler.GetDialog();	// Gerätenummer an den Fenstertitel hängen	LStr255	titel;	theDialog->GetDescriptor(titel);	titel += LStr255(Int32(GetAppNo(geraet)));	LStr255	s;	GetIndString(s, 1000, 5);	titel += s;	theDialog->SetDescriptor(titel);	LEditField		*editName = (LEditField*)theDialog->FindPaneByID('Enam');	FailNIL_(editName);	LStr255	theGName;	GetAppName(geraet, theGName);	editName->SetDescriptor(theGName);	theDialog->SetLatentSub(editName);	editName->SelectAll();	LStdPopupMenu	*spop1 = (LStdPopupMenu*)theDialog->FindPaneByID('Wahl');	FailNIL_(spop1);	LStdPopupMenu	*spop2 = (LStdPopupMenu*)theDialog->FindPaneByID('Dien');	FailNIL_(spop2);	// Datex-J disablen (gibt's bei Elmeg nicht)	MenuRef		mref = spop2->GetMacMenuH();	DisableItem(mref, 4);	int	theBer = 5;	switch(GetAppBerechtigung(geraet)) {	case EB_Halbamt:theBer = 4; break;	case EB_Ort:	theBer = 3; break;	case EB_Inland:	theBer = 2; break;	case EB_Vollamt:theBer = 1; break;	}	spop1->SetValue(theBer);	int	theDienst = 1;	switch(GetAppDienst(geraet)) {	case Endgeraetedienst_Kombi:theDienst = 6; break;	case Endgeraetedienst_Anrufbeantworter:theDienst = 5; break;	case Endgeraetedienst_Modem:theDienst = 3; break;	case Endgeraetedienst_Fax:theDienst = 2; break;	}	spop2->SetValue(theDienst);	// MSN	LEditField		*editMSN = (LEditField*)theDialog->FindPaneByID('MSN ');	FailNIL_(editMSN);	char	*smsn = (char*)&mKonfig[GetAppOffset(geraet) + 12];	LStr255	theMSN(smsn, strlen(smsn));	editMSN->SetDescriptor(theMSN);	// Gerät gesperrt?	LStdCheckBox	*schk1 = (LStdCheckBox*)theDialog->FindPaneByID('Sper');	FailNIL_(schk1);	schk1->SetValue(mKonfig[GetAppOffset(geraet) + 2]);	// Rufnummernanzeige kommend	LStdCheckBox	*schk2 = (LStdCheckBox*)theDialog->FindPaneByID('Rufk');	FailNIL_(schk2);	schk2->SetValue(mKonfig[GetAppOffset(geraet) + 47]);	// Rufnummernanzeige gehend	LStdCheckBox	*schk3 = (LStdCheckBox*)theDialog->FindPaneByID('Rufg');	FailNIL_(schk3);	schk3->SetValue(mKonfig[GetAppOffset(geraet) + 49]);	// Verbindungsdaten	LStdCheckBox	*schk4 = (LStdCheckBox*)theDialog->FindPaneByID('Verb');	FailNIL_(schk4);	schk4->SetValue(mKonfig[GetAppOffset(geraet) + 10]);	// Umschalteberechtigung	LStdCheckBox	*schk5 = (LStdCheckBox*)theDialog->FindPaneByID('Umsc');	FailNIL_(schk5);	schk5->SetValue(mKonfig[GetAppOffset(geraet)] != 0);	// Anrufvariante Tag	LStdCheckBox	*schk6 = (LStdCheckBox*)theDialog->FindPaneByID('ATag');	FailNIL_(schk6);	schk6->SetValue(mKonfig[0x04 + 2 * geraet] != 0);	// Anrufvariante Nacht	LStdCheckBox	*schk7 = (LStdCheckBox*)theDialog->FindPaneByID('ANac');	FailNIL_(schk7);	schk7->SetValue(mKonfig[0x18 - 2 * geraet] != 0);	theDialog->Show();	while (true) {					// Let DialogHandler process events		MessageT	hitMessage = theHandler.DoDialog();		if (hitMessage == msg_Cancel) {			break;		} else if (hitMessage == msg_OK) {			bool	theDoUpdate = false;			LStr255	msnNeu;			editMSN->GetDescriptor(msnNeu);			if(msnNeu != theMSN) {				LString::CopyPStr(msnNeu, &mKonfig[GetAppOffset(geraet) + 12]);				p2cstr(&mKonfig[GetAppOffset(geraet) + 12]);				SetDirty();			}			LStr255	nameNeu;			editName->GetDescriptor(nameNeu);			if(nameNeu != theGName) {				SetAppName(geraet, nameNeu);				theDoUpdate = true;				SetDirty();			}			if(theBer != spop1->GetValue()) {				theBer = eAmtsBerechtigtKeinAmt;				switch(spop1->GetValue()) {				case 1:	theBer = eAmtsBerechtigtInterNational; break;				case 2:	theBer = eAmtsBerechtigtNational; break;				case 3:	theBer = eAmtsBerechtigtOrt; break;				case 4:	theBer = eAmtsBerechtigtHalbAmt; break;				}				mKonfig[GetAppOffset(geraet) + 45] = theBer;				SetDirty();			}			if(theDienst != spop2->GetValue()) {				theDienst = eAnalogDeviceUnknown;				bool	knockknock = false;				switch(spop2->GetValue()) {				case 1:	theDienst = eAnalogDeviceTelephone; knockknock = true; break;				case 2:	theDienst = eAnalogDeviceFax; break;				case 3:	theDienst = eAnalogDeviceModem; break;				case 5:	theDienst = eAnalogDeviceAnsweringMachine; break;				case 6:	theDienst = eAnalogDeviceKombiPort; knockknock = true; break;				}				mKonfig[GetAppOffset(geraet) + 6] = theDienst;				// Anklopfschutz für Modem, etc				mKonfig[GetAppOffset(geraet) + 8] = !knockknock;				SetDirty();				theDoUpdate = true;			}			// Sperre			if(mKonfig[GetAppOffset(geraet) + 2] != schk1->GetValue()) {				SetDirty();				mKonfig[GetAppOffset(geraet) + 2] = schk1->GetValue();				theDoUpdate = true;			}			// Sperre			if(mKonfig[GetAppOffset(geraet) + 2] != schk1->GetValue()) {				SetDirty();				mKonfig[GetAppOffset(geraet) + 2] = schk1->GetValue();			}			// Rufnummernanzeige kommend			if(mKonfig[GetAppOffset(geraet) + 47] != schk2->GetValue()) {				SetDirty();				mKonfig[GetAppOffset(geraet) + 47] = schk2->GetValue();			}			// Rufnummernanzeige gehend			if(mKonfig[GetAppOffset(geraet) + 49] != schk3->GetValue()) {				SetDirty();				mKonfig[GetAppOffset(geraet) + 49] = schk3->GetValue();			}			// Verbindungsdaten			if(mKonfig[GetAppOffset(geraet) + 10] != schk4->GetValue()) {				SetDirty();				mKonfig[GetAppOffset(geraet) + 10] = schk4->GetValue();			}			// Umschalteberechtigung			if(mKonfig[GetAppOffset(geraet)] != schk5->GetValue()) {				SetDirty();				mKonfig[GetAppOffset(geraet)] = schk5->GetValue();			}			// Anrufvariante Tag			if((mKonfig[0x04 + 2 * geraet] != 0) != schk6->GetValue()) {				SetDirty();				mKonfig[0x04 + 2 * geraet] = schk6->GetValue() ? (geraet + '1') : 0;			}			// Anrufvariante Nacht			if((mKonfig[0x18 - 2 * geraet] != 0) != schk7->GetValue()) {				SetDirty();				mKonfig[0x18 - 2 * geraet] = schk7->GetValue() ? (geraet + '1') : 0;			}			CheckData();			if(theDoUpdate)				GetDefaultAttachable()->ExecuteAttachments(msg_AnlageDirty, nil);			break;		}	}}/*** *	Elmeg-I/O-Klasse ***/#include "EITYPESH.H"#include "GLTYPESH.H"#define SOH		0x01#define STX		0x02#define ETX 	0x03#define EOT 	0x04#define ENQ 	0x05#define ACK 	0x06#define NAK 	0x15#define CAN 	0x18#define CRC 	'C'#define ESC 	0x1B/*** *	CRC über die Nutzdaten berechnen ***/UInt16		CElmeg::CalcCRC(const UInt8 *ptr, UInt16 nCount){	UInt16	crc = 0;	while (nCount--) {		crc ^= *ptr++ << 8;		for(int i = 0; i <= 7; i++)			if(crc & 0x8000)				crc = (crc << 1) ^ 0x1021;			else				crc <<= 1;	}	return crc;}/*** *	Block an die Elmeg senden ***/void		CElmeg::TransmitBlock(const UInt8 *iBlockPtr, UInt16 iBlockSize){	// Checksumme berechnen...	UInt16	theCheckSum = CalcCRC(iBlockPtr, iBlockSize);	UInt8	theCmdBuf[8192];	UInt8	*theCmdPtr = theCmdBuf;	// Start der Übertragung, bzw. des Blockes...	*theCmdPtr++ = STX;		for(; iBlockSize; iBlockSize--) {		switch(*iBlockPtr) {		case STX:		case ETX:		case ESC:	// Falls das zu sendende byte einem Steuerzeichen entspricht, ein ESCAPE vorsenden...				*theCmdPtr++ = ESC;		default:*theCmdPtr++ = *iBlockPtr++;				break;		}    }	// Ende der Nutzdaten	*theCmdPtr++ = ETX;	// Checksumme übertragen	*theCmdPtr++ = theCheckSum >> 8;	*theCmdPtr++ = theCheckSum;	// Ende der Übertragung	*theCmdPtr++ = EOT;	// Daten über die RS232 schicken	mSd->Write(theCmdBuf, theCmdPtr - theCmdBuf);	// Warte auf antwort; falls keine kommt, dann NAK als Default...	UInt8	bResp;	if(mSd->Read(&bResp, 1) == 0)		Throw_(ioErr);	if(bResp != ACK)		Throw_(ioErr);}/*** *	Block von der Elmeg erwarten ***/void		CElmeg::ReceiveBlock(UInt8 *oBlockPtr, UInt16 &ioBlockSize){	UInt16	theMaxBlockSize = ioBlockSize;	ioBlockSize = 0;	UInt8	theByte;	do {		if(mSd->Read(&theByte, 1) != 1)			Throw_(ioErr);				// Timeout!	} while(theByte != STX);	UInt8	*theBuf = oBlockPtr;	int		theCount = 0;	while(1) {		if(mSd->Read(&theByte, 1) != 1)			Throw_(ioErr);			// Timeout!		if(theByte == ETX)			break;		if(theByte == ESC)			// ESC überlesen			if(mSd->Read(&theByte, 1) != 1)				Throw_(ioErr);		// Timeout!		theCount++;		if(theCount > theMaxBlockSize)	// Bufferüberlauf?			Throw_(memFullErr);		*theBuf++ = theByte;	}	// Prüfsumme über die empfangenen Daten errechnen	UInt16	theCRC = CalcCRC(oBlockPtr, theCount);	UInt8	theCRCHigh;	if(mSd->Read(&theCRCHigh, 1) != 1)		Throw_(ioErr);				// Timeout!	UInt8	theCRCLow;	if(mSd->Read(&theCRCLow, 1) != 1)		Throw_(ioErr);				// Timeout!	if(mSd->Read(&theByte, 1) != 1)		Throw_(ioErr);				// Timeout!	if(UInt8(theCRC >> 8) != theCRCHigh && UInt8(theCRC) != theCRCLow) {		theByte = NAK;		mSd->Write(&theByte, 1);	// Fehler		Throw_(ioErr);	}	if(theByte != EOT)		Throw_(ioErr);	// alles ok!	theByte = ACK;	mSd->Write(&theByte, 1);	ioBlockSize = theCount;}/*** *	Elmeg auslesen ***/void		CElmeg::Auslesen(){	Try_{		UInt8			theBuf[4096];		UInt16			theCount;		SerialDriver	sd(gPrefs->P.Port, false);		Try_{			sd.Open();		}		Catch_(err) {			ErrorAlert(err, 130);			return;		} EndCatch_		CursHandle	theCursH = ::GetCursor(watchCursor);		if (theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		mSd->FlushIO();		// Versionsnummer der Anlage abfragen	    theBuf[0] = ComTask;	    theBuf[1] = eEvEinrConfVersionReq;		TransmitBlock(theBuf, 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theBuf[0] == ComTask && theBuf[1] == eEvEinrConfVersion) {			BlockMoveData(theBuf+2, mVersion, sizeof(mVersion)-1);			mVersion[sizeof(mVersion) - 1] = 0;		} else {			Throw_(ioErr);		}		// Einstellungen der Anlage auslesen	    theBuf[0] = ComTask;	    theBuf[1] = eEvEinrConfDataReq;		TransmitBlock(theBuf, 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theCount == 920 && theBuf[0] == ComTask && theBuf[1] == eEvEinrConfData) {			BlockMoveData(theBuf+2, mKonfig, sizeof(mKonfig));			*(long*)(mKonfig + 0x2c) = '0000';	// Passwort löschen!			SetDirty();		} else {			Throw_(ioErr);		}		InitCursor();		mSd = 0L;		GetDefaultAttachable()->ExecuteAttachments(msg_AnlageDirty, nil);	}	Catch_(err) {		ErrorAlert(err);	} EndCatch_}/*** *	Elmeg wegschreiben ***/#if !DEMO_VERSIONvoid		CElmeg::Senden(){	Try_{		UInt8			iKonfig[918];	// Konfiguration der Anlage		UInt8			theBuf[4096];		UInt16			theCount;		SerialDriver	sd(gPrefs->P.Port, false);		Try_{			sd.Open();		}		Catch_(err) {			ErrorAlert(err, 130);			return;		} EndCatch_		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		mSd->FlushIO();		// alte Einstellungen der Anlage auslesen	    theBuf[0] = ComTask;	    theBuf[1] = eEvEinrConfDataReq;		TransmitBlock(theBuf, 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theCount == 920 && theBuf[0] == ComTask && theBuf[1] == eEvEinrConfData) {			BlockMoveData(theBuf+2, iKonfig, sizeof(iKonfig));		} else {			Throw_(ioErr);		}		// Passwort unterverändert?		if(*(long*)(iKonfig + 0x2c) != *(long*)(mKonfig + 0x2c)) {			StDialogHandler	theHandler(3501, this);			LWindow		*theDialog = theHandler.GetDialog();			theDialog->Show();			while (true) {					// Let DialogHandler process events				MessageT	hitMessage = theHandler.DoDialog();				if (hitMessage == msg_Cancel) {					Throw_(userCanceledErr);				} else if (hitMessage == msg_OK) {					LEditField		*thePassword = (LEditField*)theDialog->FindPaneByID('Pass');					FailNIL_(thePassword);					LStr255	thePW;					thePassword->GetDescriptor(thePW);					UInt32	thePWL[2];					LString::CopyPStr(thePW, (UInt8*)&thePWL);					p2cstr((UInt8*)&thePWL);					if(thePWL[0] == *(long*)(iKonfig + 0x2c))						break;					thePassword->SetDescriptor("\p");				}			}		}		theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		// Einstellungen in die Anlage schreiben	    theBuf[0] = ComTask;	    theBuf[1] = eEvEinrConfData;		mKonfig[2] = iKonfig[2];		// Anlagentyp übertragen!!!	    BlockMoveData(mKonfig, theBuf+2, sizeof(mKonfig));	    *(long*)(theBuf + 0x2c + 2) = *(long*)(iKonfig + 0x2c);	// Passwort nicht ändern!		TransmitBlock(theBuf, sizeof(mKonfig) + 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theCount != 2 || theBuf[0] != ComTask || theBuf[1] != eEvEinrConfAck)			Throw_(ioErr);	}	Catch_(err) {		if(err != userCanceledErr)			ErrorAlert(err);	} EndCatch_	InitCursor();	mSd = 0L;}#endif/*** *	Passwort in der Elmeg ändern ***/void		CElmeg::ChangePasswort(){	Try_{		UInt8			theBuf[4096];		UInt16			theCount;		SerialDriver	sd(gPrefs->P.Port, false);		Try_{			sd.Open();		}		Catch_(err) {			ErrorAlert(err, 130);			return;		} EndCatch_		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		mSd->FlushIO();		// Einstellungen der Anlage auslesen	    theBuf[0] = ComTask;	    theBuf[1] = eEvEinrConfDataReq;		TransmitBlock(theBuf, 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theCount != 920 || theBuf[0] != ComTask || theBuf[1] != eEvEinrConfData)			Throw_(ioErr);		{			StDialogHandler	theHandler(3502, this);			LWindow		*theDialog = theHandler.GetDialog();			theDialog->Show();			while (true) {					// Let DialogHandler process events				MessageT	hitMessage = theHandler.DoDialog();				if (hitMessage == msg_Cancel) {					Throw_(userCanceledErr);				} else if (hitMessage == msg_OK) {					LEditField		*thePassword = (LEditField*)theDialog->FindPaneByID('Pass');					FailNIL_(thePassword);					LStr255	thePW;					thePassword->GetDescriptor(thePW);					UInt32	thePWL[2];					LString::CopyPStr(thePW, (UInt8*)&thePWL);					p2cstr((UInt8*)&thePWL);					if(thePWL[0] == *(long*)(theBuf + 2 + 0x2c)) {						thePassword = (LEditField*)theDialog->FindPaneByID('NPas');						FailNIL_(thePassword);						LStr255	thePW;						thePassword->GetDescriptor(thePW);						UInt32	thePWL[2];						LString::CopyPStr(thePW, (UInt8*)&thePWL);						p2cstr((UInt8*)&thePWL);						*(long*)(theBuf + 2 + 0x2c) = thePWL[0];						break;					} else {						SysBeep(10);SysBeep(10);SysBeep(10);						thePassword->SetDescriptor("\p");					}				}			}		}		theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		// Einstellungen in die Anlage schreiben		TransmitBlock(theBuf, sizeof(mKonfig) + 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theCount != 2 || theBuf[0] != ComTask || theBuf[1] != eEvEinrConfAck)			Throw_(ioErr);	}	Catch_(err) {		if(err != userCanceledErr)			ErrorAlert(err);	} EndCatch_	InitCursor();	mSd = 0L;}/*** *	Elmeg zurücksetzen ***/void		CElmeg::Reset(){	Try_{		UInt8			iKonfig[918];	// Konfiguration der Anlage		UInt8			theBuf[4096];		UInt16			theCount;		SerialDriver	sd(gPrefs->P.Port, false);		Try_{			sd.Open();		}		Catch_(err) {			ErrorAlert(err, 130);			return;		} EndCatch_		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		mSd = &sd;		mSd->FlushIO();		// alte Einstellungen der Anlage auslesen	    theBuf[0] = ComTask;	    theBuf[1] = eEvEinrConfDataReq;		TransmitBlock(theBuf, 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theCount == 920 && theBuf[0] == ComTask && theBuf[1] == eEvEinrConfData) {			BlockMoveData(theBuf+2, iKonfig, sizeof(iKonfig));		} else {			Throw_(ioErr);		}		// Passwort unterverändert?		if(*(long*)(iKonfig + 0x2c) != '0000') {			StDialogHandler	theHandler(3501, this);			LWindow		*theDialog = theHandler.GetDialog();			theDialog->Show();			while (true) {					// Let DialogHandler process events				MessageT	hitMessage = theHandler.DoDialog();				if (hitMessage == msg_Cancel) {					Throw_(userCanceledErr);				} else if (hitMessage == msg_OK) {					LEditField		*thePassword = (LEditField*)theDialog->FindPaneByID('Pass');					FailNIL_(thePassword);					LStr255	thePW;					thePassword->GetDescriptor(thePW);					UInt32	thePWL[2];					LString::CopyPStr(thePW, (UInt8*)&thePWL);					p2cstr((UInt8*)&thePWL);					if(thePWL[0] == *(long*)(iKonfig + 0x2c))						break;					thePassword->SetDescriptor("\p");				}			}		}		theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		// Einstellungen in die Anlage schreiben	    theBuf[0] = ComTask;	    theBuf[1] = eEvEinrConfData;		Handle	h = GetResource('DATA', 3000);		FailNIL_(h);		BlockMoveData(*h, theBuf+2, sizeof(mKonfig));		theBuf[2+2] = iKonfig[2];//	    *(long*)(theBuf + 0x2c + 2) = *(long*)(iKonfig + 0x2c);	// Passwort nicht ändern!		TransmitBlock(theBuf, sizeof(mKonfig) + 2);		theCount = sizeof(theBuf);	    ReceiveBlock(theBuf, theCount);		if(theCount != 2 || theBuf[0] != ComTask || theBuf[1] != eEvEinrConfAck)			Throw_(ioErr);	}	Catch_(err) {		if(err != userCanceledErr)			ErrorAlert(err);	} EndCatch_	InitCursor();	mSd = 0L;}#endif