#include "MRFUtilities.h"/*** *	Datei in den Papierkorb legen ***/OSErr		FSpTrashFile(FSSpecPtr theFile, Boolean doDelete){OSErr		theErr;short		vRefNum;long		dirID;FSSpec		theTrash;	if(doDelete) {		theErr = FSpDelete(theFile);		if(theErr == fnfErr || theErr == noErr)			return noErr;	}	theErr = FindFolder(theFile->vRefNum, kTrashFolderType, kCreateFolder, &vRefNum, &dirID);	if(theErr != noErr) return theErr;	theErr = FSMakeFSSpec(vRefNum, dirID, "\p", &theTrash);	if(theErr != noErr) return theErr;	theErr = CatMove(theFile->vRefNum, theFile->parID, theFile->name, theTrash.parID, theTrash.name);	return theErr;}/*** *	Variables for the Command-period checker. ***/#define	kModifiersMask		0xFF00 & ~cmdKey	// We need all modifiers except the command key for KeyTrans()#define kOtherCharCodeMask	0x00FF0000			// Get the key out of the ASCII byte.#define kPeriod				'.'/*** *	Ist der aktuelle Prozess im Vordergrund? Besser als mit Suspend & Resume, aber erst ab System 7 * *	Quelle: Macintosh Programming Secrets (Second Edition, p. 508) ***/static Boolean		IsFrontProcess(){ProcessSerialNumber	aPSN;ProcessSerialNumber	currentPSN = { 0, kCurrentProcess };Boolean				result;	GetFrontProcess(&aPSN);	SameProcess(&aPSN, &currentPSN, &result);	return result;}/*** *	Diese Routine ŸberprŸft, ob ein EventRecord ein Command-Punkt enthŠlt *	Command-Punkt bedeutet auf dem Mac: Funktion abbrechen. * *	Quelle: Macintosh Programming Secrets (Second Edition, p. 506) * *	Radical cool way to see if the event record represents a Command-period *	Keypress. Normally, you might wonder, What's the problem? All you have to *	do is check the modifiers field to see if the Command key is down, and *	check the message field to see what key was pressed. Well, the problem is *	that under some systems, holding down the Command key negates any effect *	the Shift key has. THis means that on system where the period is a *	shifted character, when you hold down the Command key, you won't be able *	to press period. * *	The way to fix this is to rerun the sequence of events involved in mapping *	a key code into an ASCII value, except that this time we don't factor the *	Command key into the equation. * *	The event record has everything we need. It has the modifier keys that *	were pressed at the time of the event, and it has the key code. What we do *	is take the modifiers, clear the bit that says the Command key was *	pressed, and pass the modified modifiers and the key code to KeyTrans. *	After that, we'll be able to examine the resulting ASCII value on its own *	merits. * *	From Harvey's Technical Note #263: International Canceling ***/static Boolean		CmdPeriod(EventRecord *theEvent){Boolean			result;short			keyCode;long			virtualKey, keyInfo, lowChar, highChar, keyCID;unsigned long	state;Handle			hKCHR;	result = false;	if ((theEvent->what == keyDown) || (theEvent->what == autoKey)) {		// See if the Command key is down. If it is, find out the ASCII		// equivalent for the accompanying key.		if ((theEvent->modifiers & cmdKey) != 0) {			virtualKey = (theEvent->message & keyCodeMask) >> 8;			// Mask out the Command key and merge in the virtualKey			keyCode = (theEvent->modifiers & kModifiersMask) | virtualKey;			state	= 0;			keyCID	= GetScriptVariable(GetScriptManagerVariable(smKeyScript), smScriptKeys);			hKCHR	= GetResource('KCHR', keyCID);			if (hKCHR != nil) {				keyInfo = KeyTranslate(*hKCHR, keyCode, &state);				ReleaseResource(hKCHR);			} else {				keyInfo = theEvent->message;			}			lowChar =  keyInfo & charCodeMask;			highChar = (keyInfo & kOtherCharCodeMask) >> 16;			if ((lowChar == kPeriod) || (highChar == kPeriod))				result = true;		}	// end the Command key is down	}	// end key down event	return result;}/*** *	Diese Routine ŸberprŸft, ob der User Command-Punkt gedrŸckt hat. *	Command-Punkt bedeutet auf dem Mac: Funktion abbrechen. * *	Quelle: Macintosh Programming Secrets (Second Edition, p. 505) * *	Looks for a Command-period in the event queue. If we are running under the *	Mac OS, we find the head of the queue and walk the elements, looking for a *	keyDown event. This won't work under A/UX, which doesn't maintain a normal *	Mac OS event queue. When running under A/UX, we make a special call, *	asking A/UX to look through its private structures for a specific event *	for us. * *	Note that this routine returns false, if we are running in the background. *	This is because we don't want to stop whatevet we're doing if the user *	presses Command-period for the foreground application. ***/Boolean		AbortInQueue(){	EvQElPtr	queueEntryPtr;	Boolean		result;	result = false;	if(IsFrontProcess()) {		// Running under Mac OS, so walk the queue. The head is in		// the low-memory location returned by GetEvQHdr, and		// follows the normal OS queue conventions. For each entry		// in the queue, call "CmdPeriod" to test it.		queueEntryPtr = (EvQElPtr) GetEvQHdr()->qHead;		while (!result && (queueEntryPtr != nil)) {			result = CmdPeriod((EventRecord*) &queueEntryPtr->evtQWhat);			if (!result) {				queueEntryPtr = (EvQElPtr) queueEntryPtr->qLink;			}		}	// Scanning queue	}	// If front process	return result;}/*** *	zwei Pascal-Strings auf Gleichheit testen ***/void	BlockFill(void *s, char filler, long size){char	*sp = (char*)s;	for(long i=0; i<size; i++)		sp[i] = filler;}