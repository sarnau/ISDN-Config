// ===========================================================================//	CISDNApp.cp					©1994 Metrowerks Inc. All rights reserved.// ===========================================================================////	A simple Application class which manages text documents.#include <LString.h>#include <LStdControl.h>#include <LTableView.h>#include <UModalDialogs.h>#include <UMemoryMgr.h>#include <UDrawingState.h>#include <LGrowZone.h>#include <LMenu.h>#include <LMenuBar.h>#include <LWindow.h>#include <UDesktop.h>#include <LArrayIterator.h>#include <LTextEditView.h>#include <UEnvironment.h>#include <LPopupButton.h>#include <UControlRegistry.h>#ifndef __APPEARANCE__#include <Appearance.h>#endif#include "CISDNApp.h"#include "CISDNDesktop.h"#include "CISDNAnlageIconView.h"#include "CPreferences.h"#include "SerialComm.h"#if INCLUDE_ISTEC#include "CISTEC.h"#endif#if INCLUDE_ELMEG#include "CElmeg.h"#endif#if INCLUDE_EURACOM#include "CEuracom.h"#endifCISDNApp	*gTheApp;// ===========================================================================//		• Main Program// ===========================================================================void main(){									// Set Debugging options#if 0	SetDebugThrow_(debugAction_Nothing);	SetDebugSignal_(debugAction_Nothing);#else	#if 0		SetDebugThrow_(debugAction_SourceDebugger);		SetDebugSignal_(debugAction_SourceDebugger);	#else		SetDebugThrow_(debugAction_Alert);		SetDebugSignal_(debugAction_Alert);	#endif#endif	InitializeHeap(3);				// Initialize Memory Manager									// Parameter is number of Master Pointer									//   blocks to allocate									// Initialize standard Toolbox managers	UQDGlobals::InitializeToolbox(&qd);	new LGrowZone(20000);			// Install a GrowZone function to catch									//    low memory situations.									//    Parameter is size of reserve memory									//    block to allocated. The first time									//    the GrowZone function is called,									//    there will be at least this much									//    memory left (so you'll have enough									//    memory to alert the user or finish									//    what you are doing).	UEnvironment::InitEnvironment();		// MUST CALL THIS!! There are some											// internals to PowerPlant that this											// establishes for us.	CISDNApp	theApp;				// Create instance of your Application	gTheApp = &theApp;	theApp.Run();					//   class and run it}// ===========================================================================//		• CISDNApp Class// ===========================================================================// ---------------------------------------------------------------------------//		• CISDNApp// ---------------------------------------------------------------------------//	ConstructorCISDNApp::CISDNApp(){	// tell the Appearance Manager (AM) we're an AM client. Why must we do this?	// If a user is not running the AM, then of course the check short-circuits	// and we'll end up using the GA implementations. No fuss, no muss.	// If the AM is installed on a user's machine, they could run it in one of	// two modes: "full" mode or "compatability" mode. In full mode, every	// application will utilize the Appearance Manager (whether it likes it	// or not). But this could cause some problems for certain applications	// that might not have yet been written to be AM-savvy. So a user might	// opt to run their Mac in "compatability" mode. This way apps will	// not use the AM and just pass on through to the old way of being (in	// theory). However, if you have (re)written your app to be AM-savvy	// and would like to "always" take advantage of the AM, then you need	// to call ::RegisterAppearanceClient(). That way if the user has the	// AM in compat mode, your app will still take advantage of the AM. Make	// sense? If not, give it a try. Run an app in full mode, then run an	// app in compat mode. Try it both with a non-AM savvy app, and then one	// that takes advantage of the AM. Just experiment some and you'll see	// how it all works out. :-)		// And since we know this app will be an AM-savvy app, we'll register	// ourselves to always take advantage of the AM#if 0	if ( UEnvironment::HasFeature( env_HasAppearance ) ) {		::RegisterAppearanceClient();	}#endif	// Register the Appearance Manager/GA classes	//	UControlRegistry::RegisterClasses();//	UControlRegistry::RegisterAMClasses();	UControlRegistry::RegisterGAClasses();	RegisterClass_(LTableView);	RegisterClass_(LTextEditView);//	URegistrar::RegisterClass(CDragEditField::class_ID, (ClassCreatorFunc) CDragEditField::CreateFromStream);//	URegistrar::RegisterClass(CISDNAnlageIconView::class_ID, (ClassCreatorFunc) CISDNAnlageIconView::CreateFromStream);//	URegistrar::RegisterClass(CGebTable::class_ID, (ClassCreatorFunc) CGebTable::CreateFromStream);//	URegistrar::RegisterClass(CGebTableView::class_ID, (ClassCreatorFunc) CGebTableView::CreateFromStream);//	URegistrar::RegisterClass(CKurzTable::class_ID, (ClassCreatorFunc) CKurzTable::CreateFromStream);//	URegistrar::RegisterClass(CKurzTableView::class_ID, (ClassCreatorFunc) CKurzTableView::CreateFromStream);//	URegistrar::RegisterClass(CNahTable::class_ID, (ClassCreatorFunc) CNahTable::CreateFromStream);//	URegistrar::RegisterClass(CNahTableView::class_ID, (ClassCreatorFunc) CNahTableView::CreateFromStream);//	URegistrar::RegisterClass(CSperrTable::class_ID, (ClassCreatorFunc) CSperrTable::CreateFromStream);//	URegistrar::RegisterClass(CSperrTableView::class_ID, (ClassCreatorFunc) CSperrTableView::CreateFromStream);	gPrefs = new CPreferences;}// ---------------------------------------------------------------------------//		• ~CISDNApp// ---------------------------------------------------------------------------//	DestructorCISDNApp::~CISDNApp(){	ThrowIfNil_(gPrefs);	delete gPrefs;}// ---------------------------------------------------------------------------//		• ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCISDNApp::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean	cmdHandled = true;	switch (inCommand) {		case 5000: case 5001: case 5002: case 5003: case 5004:		case 5005: case 5006: case 5007: case 5008: case 5009:		case 5010: case 5011: case 5012: case 5013: case 5014:		case 5015: case 5016: case 5017: case 5018: case 5019:			ThrowIfNil_(gPrefs);			LMenu	*theMenu = LMenuBar::GetCurrentMenuBar()->FetchMenu(130);			ThrowIfNil_(theMenu);			short	index = theMenu->IndexFromCommand(inCommand);			Str255	itemString;			GetMenuItemText(theMenu->GetMacMenuH(), index, itemString);			gPrefs->P.Port = itemString;			break;		default:			cmdHandled = LDocApplication::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}// ---------------------------------------------------------------------------//		• FindCommandStatus// ---------------------------------------------------------------------------//	Pass back status of a (menu) commandvoidCISDNApp::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	outUsesMark = false;	switch (inCommand) {		// Serielle Schnittstelle wählen (max. 20 Ports - mal sehen, wann jemand dieses Limit bemerkt :-)		case 5000: case 5001: case 5002: case 5003: case 5004:		case 5005: case 5006: case 5007: case 5008: case 5009:		case 5010: case 5011: case 5012: case 5013: case 5014:		case 5015: case 5016: case 5017: case 5018: case 5019:			outEnabled = true;			outUsesMark = true;			LMenu	*theMenu = LMenuBar::GetCurrentMenuBar()->FetchMenu(130);			ThrowIfNil_(theMenu);			short	index = theMenu->IndexFromCommand(inCommand);			Str255	itemString;			GetMenuItemText(theMenu->GetMacMenuH(), index, itemString);			// kein Port eingestellt? => den ersten nehmen!			ThrowIfNil_(gPrefs);			if(gPrefs->P.Port.Length() == 0) {				gPrefs->P.Port = itemString;			}			if(LStr255(itemString) == gPrefs->P.Port)				outMark = checkMark;			else				outMark = noMark;			break;		default:			LDocApplication::FindCommandStatus(inCommand, outEnabled, outUsesMark,								outMark, outName);			break;	}}// ---------------------------------------------------------------------------//		• OpenDocument// ---------------------------------------------------------------------------//	Open a Document filevoid			CISDNApp::OpenDocument(FSSpec *inMacFSSpec){	CISDNDesktop	*theDoc = new CISDNDesktop(this, inMacFSSpec);	ThrowIfNil_(theDoc);}// ---------------------------------------------------------------------------//		• MakeNewDocument// ---------------------------------------------------------------------------//	Create a new DocumentLModelObject	*CISDNApp::MakeNewDocument(){//	if(AEInteractWithUser(30, nil, nil) == noErr) {		// Liste der Namen an das Popup-Menü anhängen		ThrowIfNil_(gSerialPortnames);		LArrayIterator	iterator(*gSerialPortnames, LArrayIterator::from_Start);		Str255	theSerialName;		MenuRef	theMenu = ::GetMenu(500);		ThrowIfNil_(theMenu);		for(int index = 1; iterator.Next(&theSerialName); index++) {			::AppendMenu(theMenu, "\p ");			// den Itemtext setzen wir später, da bei InsertMenuItem() Steuerzeichen, wie			// "/" ausgewertet werden :-(			::SetMenuItemText(theMenu, index, theSerialName);		}		StDialogHandler	theHandler(500, this);		LWindow		*theDialog = theHandler.GetDialog();		ThrowIfNil_(theDialog);		// aktuellen Namen der seriellen Schnittstelle wählen		LPopupButton	*spop0 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Schn'));		ThrowIfNil_(spop0);		SInt16	theFoundItem = 1;		for(int item=1; item<32; item++) {			Str255	itemString;			GetMenuItemText(spop0->GetMacMenuH(), item, itemString);			if(itemString[0] == 0) break;			if(LStr255(itemString) != gPrefs->P.Port)				continue;			theFoundItem = item;			break;		}		spop0->SetValue(theFoundItem);		LPopupButton	*spop3 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Hers'));		ThrowIfNil_(spop3);#if ISTEC_ONLY		spop3->Disable();		spop3->SetValue(Anlage_Emmerich);#endif#if EURACOM_ONLY		spop3->Disable();		spop3->SetValue(Anlage_Ackermann);#endif#if ELMEG_ONLY		spop3->Disable();		spop3->SetValue(Anlage_Elmeg);#endif#if MORE_VERSIONS		spop3->SetValue(gPrefs->P.DefHersteller);#endif#if INCLUDE_EURACOM		LPopupButton	*spop11 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Anl1'));		ThrowIfNil_(spop11);#endif#if INCLUDE_ELMEG		LPopupButton	*spop12 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Anl2'));		ThrowIfNil_(spop12);		ThrowIfNil_(gPrefs);#if 0		MenuRef		mref = spop12->GetMacMenuH();		ThrowIfNil_(mref);		DisableItem(mref, 1);		DisableItem(mref, 2);		DisableItem(mref, 3);		DisableItem(mref, 5);		gPrefs->P.DefAnlage = CElmeg::ELMEG_C88;#endif#endif#if INCLUDE_ISTEC		LPopupButton	*spop13 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Anl3'));		ThrowIfNil_(spop13);#endif		LPopupButton	*spop1x = nil;		LPopupButton	*spop2 = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('NSof'));		ThrowIfNil_(spop2);#if INCLUDE_ISTEC		int	id = 1;		if(spop3->GetValue() == Anlage_Emmerich && gPrefs->P.DefAnlage <= CISTEC::AT_I1008) {			if(gPrefs->P.DefSoftware == 192) id = 2;			if(gPrefs->P.DefSoftware == 193) id = 3;			if(gPrefs->P.DefSoftware == 195) id = 4;			if(gPrefs->P.DefSoftware == 200) id = 5;		}		spop2->SetValue(id);		spop2->Show();#else		spop2->Hide();#endif		MessageT	hitMessage;		bool		theShowFlag = false;		do {			LPopupButton	*spop = dynamic_cast<LPopupButton*>(theDialog->FindPaneByID('Anl0' + spop3->GetValue()));//			ThrowIfNil_(spop);			if(spop != spop1x && spop != nil) {				spop->Enable();				spop->SetValue((spop1x == nil) ? gPrefs->P.DefAnlage : spop1x->GetValue());				spop->Show();				if(spop1x != nil) {					spop1x->Hide();					spop1x->Disable();				}				spop1x = spop;			}#if INCLUDE_ISTEC			if(spop3->GetValue() != Anlage_Emmerich || spop13->GetValue() > CISTEC::AT_I1008) {				spop2->Disable();				spop2->SetValue(1);			} else {				spop2->Enable();			}#endif			if(!theShowFlag) {		 		theDialog->Show();				theShowFlag = true;			}			hitMessage = theHandler.DoDialog();		} while(hitMessage != msg_OK);#if MORE_VERSIONS		gPrefs->P.DefHersteller = spop3->GetValue();#endif		gPrefs->P.DefAnlage = spop1x->GetValue();#if INCLUDE_ISTEC		switch(spop2->GetValue()) {		case 1:	gPrefs->P.DefSoftware = 160; break;		case 2:	gPrefs->P.DefSoftware = 192; break;		case 3:	gPrefs->P.DefSoftware = 193; break;		case 4:	gPrefs->P.DefSoftware = 195; break;		case 5:	gPrefs->P.DefSoftware = 200; break;		}#endif		// Modem- oder Druckeranschluß wählen		ObeyCommand(spop0->GetValue() + 4999, 0L);#if 0	} else {#if ISTEC_ONLY		gPrefs->P.DefHersteller = Anlage_Emmerich;		gPrefs->P.DefAnlage = CISTEC::AT_I1008;#endif#if EURACOM_ONLY		gPrefs->P.DefHersteller = Anlage_Ackermann;		gPrefs->P.DefAnlage = AT_I180;#endif#if ELMEG_ONLY		gPrefs->P.DefHersteller = Anlage_Elmeg;		gPrefs->P.DefAnlage = CElmeg::ELMEG_C88;#endif		gPrefs->P.DefSoftware = 200;	}#endif	return new CISDNDesktop(this, nil);}// ---------------------------------------------------------------------------//		• ChooseDocument// ---------------------------------------------------------------------------//	Prompt the user to select a document to openstatic pascal Boolean	myFileFilter(CInfoPBPtr ci, void *param){#pragma unused (param)//	DebugStr(ci->hFileInfo.ioNamePtr);	if(ci->hFileInfo.ioFlFndrInfo.fdType == 'EPak') return false;// richtiger Filetype	if(ci->hFileInfo.ioFlLgLen == 1181L) return false;			// richtige Dateilänge!	return true;}void			CISDNApp::ChooseDocument(){	StandardFileReply	macFileReply;	UDesktop::Deactivate();#if 1	Point			pp = { -1, -1 };	SFTypeList		typeList = { 'EPak', '????' };	FileFilterYDUPP	ff = NewFileFilterYDProc(myFileFilter);	CustomGetFile(ff, 2, typeList, &macFileReply, 0, pp, nil, nil, nil, nil, nil);	DisposeRoutineDescriptor(ff);#else	SFTypeList			typeList;	typeList[0] = 'EPak';	::StandardGetFile(nil, 1, typeList, &macFileReply);#endif	UDesktop::Activate();	if (macFileReply.sfGood) {		SendAEOpenDoc(macFileReply.sfFile);	}}void			CISDNApp::ShowAboutBox(){#if ELMEG_ONLY	CElmeg::DoAbout();#else//	if(AEInteractWithUser(30, nil, nil) == noErr) {		extern void DoAbout();		DoAbout();//	}#endif}// ---------------------------------------------------------------------------------//		• Initialize// ---------------------------------------------------------------------------------void			CISDNApp::Initialize(){	// Setup the font menu.	LMenuBar	*theMenuBar = LMenuBar::GetCurrentMenuBar();	ThrowIfNil_( theMenuBar );	// Namen der seriellen Schnittstellen ermitteln	SerialDriver	sd;	sd.BuildMenu();	ThrowIfNil_(gSerialPortnames);	// Liste der Namen an das Bearbeiten-Menü anhängen	LArrayIterator	iterator(*gSerialPortnames, LArrayIterator::from_Start);	Str255			theSerialName;	LMenu			*theSerialMenu = theMenuBar->FetchMenu(130);	ThrowIfNil_( theSerialMenu );	for(int index = 1; iterator.Next(&theSerialName); index++) {		theSerialMenu->InsertCommand("\p ", 5000 + index - 1, 999);		// den Itemtext setzen wir später, da bei InsertMenuItem() Steuerzeichen, wie		// "/" ausgewertet werden :-(		::SetMenuItemText(theSerialMenu->GetMacMenuH(), theSerialMenu->IndexFromCommand(5000 + index - 1), theSerialName);	}}/*** *	About-Box zeigen und ein leeres Dokument anlegen ***/void			CISDNApp::StartUp(){	FSSpec		theFile;	GetIndString(theFile.name, 300, 1);	try {		if(::FSMakeFSSpec(0, 0, theFile.name, &theFile) != noErr)		{			MakeNewDocument();			goto raus;		}		SendAEOpenDoc(theFile);	}	catch(LException inErr) {		MakeNewDocument();	} raus:#if ELMEG_ONLY	CElmeg::DoAbout();#else	#if DEMO_VERSION		extern void DoAbout();		DoAbout();	#else		// About-Box nur beim ersten Start darstellen		if(gPrefs->P.FirstLaunch)			ShowAboutBox();	#endif#endif}