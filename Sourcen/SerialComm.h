/*** *	Library für die serielle Schnittstelle ***/#pragma once	// include this header				// only once per source file#include <Serial.h>#include <LString.h>#include <LArray.h>extern LArray		*gSerialPortnames;//#define	SERIALBUF	0L		// Größe des Eingangsbuffers#define	SERIALBUF	4096L		// Größe des Eingangsbuffers#define	XOn			0x11		// Software-Handshake-Codes#define	XOff		0x13#define	SDInitPara	baud9600+data8+stop10+noParityclass SerialDriver {	LStr255			SDName;			// Name des aktiven Ports	short			SDIn,SDOut;		// RefNum für Lesen und Schreiben	short			SDPort;			// aktueller Ausgabeport#if SERIALBUF	StringPtr		SDInBuf;		// Buffer für den Eingang#endif	unsigned short	SDTimeout;		// Timeoutlänge beim Empfang in 60Hz	OSErr			SDCBOpenErr;	Boolean	CBOpen(short index,LStr255 portname,LStr255 indriver,LStr255 outdriver);	Boolean	CBAppendMenu(short index,LStr255 portname,LStr255 indriver,LStr255 outdriver);	void	Lookup(Boolean (SerialDriver::*lookup)(short index,LStr255 portname,LStr255 indriver,LStr255 outdriver));	void	DebugPrint(const char* header,const StringPtr s,unsigned short len);public:	SerialDriver() { SDName[0] = 0; SDInBuf = 0L; SDIn = 0; SDOut = 0; SDPort = 0; };	SerialDriver(LStr255 drvName, Boolean iOpenFlag = true) { SDName = drvName; SDInBuf = 0L; SDPort = 0; SDIn = 0; SDOut = 0; if(iOpenFlag) Open(); };	~SerialDriver() { Close(); };	void	Open(UInt16 iSerialInit = SDInitPara, Boolean iHWHandshake = false);	void	Close();	OSErr	Wait(unsigned short timeout,long *count);	void	Write(StringPtr s,unsigned short count);	short	Read(StringPtr buf,unsigned short maxbytes);	void	DTR(Boolean flag);	void	FlushIO();	void	SetTimeout(const unsigned short timeout) { SDTimeout = timeout; };	void	BuildMenu();};