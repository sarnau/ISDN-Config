// ===========================================================================//	CGebTable.cp					© 1996, Markus Fritze. All rights reserved.// ===========================================================================#include "CGebTable.h"#include <LTableMonoGeometry.h>#include <LTableMultiSelector.h>#include "CISDNDesktop.h"#include <fp.h>#include <UTextTraits.h>bool    CGebTable::sRegisterClass = PPFactory<CGebTable>::RegisterClass();bool    CGebTableView::sRegisterClass = PPFactory<CGebTableView>::RegisterClass();// ---------------------------------------------------------------------------//		• FinishCreateSelf// ---------------------------------------------------------------------------//	Finish Creating a Pane////	This function gets called after creating a Pane from a data stream.//	Override to perform finishing touches that depend on the entire//	Pane hierarchy being constructed.////	For example, if a View wants to store a pointer to a SubPane,//	it should override this function to call FindPaneByID for that//	Pane. This saves the overhead of repeatedly calling FindPaneByID//	when the View wants to access that SubPane. You can't do this from//	a Constructor because SubPanes are created after their SuperView.const SInt16	GT_Spalte_1 = 100;const SInt16	GT_Spalte_2 = 50;const SInt16	GT_Spalte_3 = 70;voidCGebTable::FinishCreateSelf(){	CGebTableView	*table = (CGebTableView*)FindPaneByID('GeTA');	ThrowIfNil_(table);	mAnlage = CISDNDesktop::GetAnlage(this);	ThrowIfNil_(mAnlage);	mAnlage->AddAttachment(this);	table->SetTableGeometry(new LTableMonoGeometry(table, (GT_Spalte_1 + GT_Spalte_2 + GT_Spalte_3), 16));	table->SetTableSelector(new LTableMultiSelector(table));	int		theItemCount = mAnlage->GetAppGebCount() + 1 + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_No);	table->InsertCols(1, 0, nil, 0, Refresh_No);	// Fenstergröße, Minimum + Maximum setzen (dazu muß das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort());	ThrowIfNil_(theWind);	theWind->Show();	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	theRect.right = theRect.left + (GT_Spalte_1 + GT_Spalte_2 + GT_Spalte_3)  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = (GT_Spalte_1 + GT_Spalte_2 + GT_Spalte_3)  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(theItemCount > 10) theItemCount = 10;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		• ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanCGebTable::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean			cmdHandled = true;	CGebTableView	*table = (CGebTableView*)FindPaneByID('GeTA');	ThrowIfNil_(table);	ThrowIfNil_(mAnlage);	switch (inCommand) {	case cmd_Clear:		{		Boolean	theSumDirty = false;		TableIndexT	theRows, theColumns;		table->GetTableSize(theRows, theColumns);		for(int theRow=2; theRow<=theRows; theRow++) {			STableCell	theCell(theRow, 1);			if(!table->CellIsSelected(theCell))				continue;			// alle löschen?			if(theRows == theCell.row) {				for(int i=0; i<mAnlage->GetAppGebCount(); i++)					mAnlage->SetAppGeb(i, 0);				table->RefreshCellRange(STableCell(1, 1), STableCell(theRows, 1));				theSumDirty = false;				continue;			}			// einzelne Zelle löschen			// Einheiten löschen			mAnlage->SetAppGeb(theCell.row - 2, 0);			// Zelle updaten			table->RefreshCell(theCell);			theSumDirty = true;		}		// Summe updaten?		if(theSumDirty) {			STableCell	theCell(theRows, 1);			table->RefreshCell(theCell);		}		}		break;	case cmd_SelectAll:		{		table->SelectAllCells();		table->UnselectCell(STableCell(1,1));		TableIndexT	theRows, theColumns;		table->GetTableSize(theRows, theColumns);		table->RefreshCellRange(STableCell(2,1), STableCell(theRows, 1));		}		break;	case cmd_Close:			default:		cmdHandled = LWindow::ObeyCommand(inCommand, ioParam);		break;	}	return cmdHandled;}// ---------------------------------------------------------------------------//		• FindCommandStatus// ---------------------------------------------------------------------------//	Pass back status of a (menu) commandvoidCGebTable::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	CGebTableView	*table = (CGebTableView*)FindPaneByID('GeTA');	ThrowIfNil_(table);	switch (inCommand) {		case cmd_Clear:			TableIndexT	theRows, theColumns;			table->GetTableSize(theRows, theColumns);			for(int theRow=2; theRow<=theRows; theRow++) {				STableCell	theCell(theRow, 1);				if(!table->CellIsSelected(theCell))					continue;				outEnabled = true;			}			break;		case cmd_SelectAll:			outEnabled = true;			break;		default:			LWindow::FindCommandStatus(inCommand, outEnabled, outUsesMark,								outMark, outName);			break;	}}// ---------------------------------------------------------------------------//		• ExecuteSelf(MessageT inMessage, void *ioParam)// ---------------------------------------------------------------------------//	Draw the contents of the specified Cellvoid		CGebTable::ExecuteSelf(MessageT inMessage, void *ioParam){#pragma unused (inMessage, ioParam)	CGebTableView	*table = (CGebTableView*)FindPaneByID('GeTA');	ThrowIfNil_(table);	TableIndexT	theRows, theColumns;	table->GetTableSize(theRows, theColumns);	table->RemoveRows(theRows, 1, Refresh_No);	int		theItemCount = mAnlage->GetAppGebCount() + 1 + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_Yes);	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	int	aktCount = (theRect.bottom - theRect.top - (ScrollBar_Size - 1)) / 16;	theRect.right = theRect.left + (GT_Spalte_1 + GT_Spalte_2 + GT_Spalte_3)  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	// Fenstergröße, Minimum + Maximum setzen (dazu muß das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort());	ThrowIfNil_(theWind);	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = (GT_Spalte_1 + GT_Spalte_2 + GT_Spalte_3)  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(aktCount > theItemCount) aktCount = theItemCount;	theRect.bottom = theRect.top + 16  * aktCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		• CGebTableView// ---------------------------------------------------------------------------//	CGebTableView::CGebTableView(LStream *inStream) : LTableView(inStream){	mAnlage = CISDNDesktop::GetAnlage(this);	ThrowIfNil_(mAnlage);}// ---------------------------------------------------------------------------//		• ClickSelect// ---------------------------------------------------------------------------//	Adjust selection in response to a click in the specified cell////	Return whether or not to process the click as a normal clickBooleanCGebTableView::ClickSelect(	const STableCell		&inCell,	const SMouseDownEvent	&inMouseDown){	if(inCell.row == 1) return false;	// Klick in die erste Reihe ist nicht möglich!	if(mTableSelector != nil)		mTableSelector->ClickSelect(inCell, inMouseDown);	return true;}// ---------------------------------------------------------------------------//		• DrawCell// ---------------------------------------------------------------------------//	Draw the contents of the specified CellvoidCGebTableView::DrawCell(	const STableCell	&inCell,	const Rect			&inLocalRect){	UTextTraits::SetPortTextTraits(129);	SInt16		theRow = inCell.row - 1;	// Linien zwischen den Zellen	::MoveTo(inLocalRect.left + GT_Spalte_1 - 1, inLocalRect.top);	::LineTo(inLocalRect.left + GT_Spalte_1 - 1, inLocalRect.bottom);	::MoveTo(inLocalRect.left + GT_Spalte_1 + GT_Spalte_2 - 1, inLocalRect.top);	::LineTo(inLocalRect.left + GT_Spalte_1 + GT_Spalte_2 - 1, inLocalRect.bottom);	// die Titelzeile	if(theRow == 0) {		::MoveTo(inLocalRect.left, inLocalRect.bottom - 1);		::LineTo(inLocalRect.right, inLocalRect.bottom - 1);		::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);		::DrawString(LStr255(1000, 23));		::MoveTo(inLocalRect.left + GT_Spalte_1 + 4, inLocalRect.bottom - 4);		::DrawString(LStr255(1000, 24));		::MoveTo(inLocalRect.left + GT_Spalte_1 + GT_Spalte_2 + 4, inLocalRect.bottom - 4);		::DrawString(LStr255(1000, 25));		return;	}	LStr255		theAppName;	SInt32		theGebuehren;	ThrowIfNil_(mAnlage);	if(theRow <= mAnlage->GetAppGebCount()) {			// ein Apparat?		mAnlage->GetAppName(theRow - 1, theAppName);	// dessen Namen nehmen		theGebuehren = mAnlage->GetAppGeb(theRow - 1);	// und die Gebühren holen	} else {		// Summenzeile überstreichen		::MoveTo(inLocalRect.left, inLocalRect.top);		::LineTo(inLocalRect.right, inLocalRect.top);		theAppName.Assign(1000, 26);					// "Summe"		theGebuehren = 0L;		for(int i=0; i<mAnlage->GetAppGebCount(); i++)			theGebuehren += mAnlage->GetAppGeb(i);		// Summe aller Gebühren bilden	}	// 1. Spalte: Name des Apparates	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);	::DrawString(theAppName);	// 2. Spalte: Anzahl der Einheiten	LStr255	gebStr = LStr255(theGebuehren);	::MoveTo(inLocalRect.left + GT_Spalte_1 + GT_Spalte_2 - 3 - StringWidth(gebStr), inLocalRect.bottom - 4);	::DrawString(gebStr);	// 3. Spalte: DM-Betrag der Gebühren	LStr255		ss;	if(theGebuehren != 0L) {		ss.Assign((double_t)theGebuehren * 0.12, FIXEDDECIMAL, 2);	} else {		ss.Assign(1000, 27);	}	ss += LStr255(1000, 10);	::MoveTo(inLocalRect.left + GT_Spalte_1 + GT_Spalte_2 + GT_Spalte_3 - 3 - StringWidth(ss), inLocalRect.bottom - 4);	::DrawString(ss);}