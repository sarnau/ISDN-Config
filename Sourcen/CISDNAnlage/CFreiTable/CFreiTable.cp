// ===========================================================================//	CFreiTable.cp					© 1996, Markus Fritze. All rights reserved.// ===========================================================================#include "CFreiTable.h"#include <LTableMultiGeometry.h>#include <LTableSingleSelector.h>#include <UModalDialogs.h>#include <UTextTraits.h>#include <LEditField.h>#include "CISDNDesktop.h"#if INCLUDE_ELMEGbool    CFreiTable::sRegisterClass = PPFactory<CFreiTable>::RegisterClass();bool    CFreiTableView::sRegisterClass = PPFactory<CFreiTableView>::RegisterClass();// ---------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------//	Finish Creating a Pane////	This function gets called after creating a Pane from a data stream.//	Override to perform finishing touches that depend on the entire//	Pane hierarchy being constructed.////	For example, if a View wants to store a pointer to a SubPane,//	it should override this function to call FindPaneByID for that//	Pane. This saves the overhead of repeatedly calling FindPaneByID//	when the View wants to access that SubPane. You can't do this from//	a Constructor because SubPanes are created after their SuperView.const SInt16	KT_Spalte_1 = 150;voidCFreiTable::FinishCreateSelf(){	CFreiTableView	*table = (CFreiTableView*)FindPaneByID('FrTA');	Assert_(table);	mAnlage = CISDNDesktop::GetAnlage(this);	Assert_(mAnlage);	mAnlage->AddAttachment(this);	table->SetTableGeometry(new LTableMultiGeometry(table, KT_Spalte_1, 16));	table->SetTableSelector(new LTableSingleSelector(table));	SInt16		theItemCount = mAnlage->GetFreinummerCount() + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_No);	table->InsertCols(1, 0, nil, 0, Refresh_No);	table->SetColWidth(KT_Spalte_1, 1, 1);	// Fenstergrš§e, Minimum + Maximum setzen (dazu mu§ das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort());	theWind->Show();	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	theRect.right = theRect.left + KT_Spalte_1  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = KT_Spalte_1  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(theItemCount > 10) theItemCount = 10;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		¥ ExecuteSelf(MessageT inMessage, void *ioParam)// ---------------------------------------------------------------------------//	Draw the contents of the specified Cellvoid		CFreiTable::ExecuteSelf(MessageT inMessage, void *ioParam){#pragma unused (inMessage, ioParam)	CFreiTableView	*table = (CFreiTableView*)FindPaneByID('FrTA');	Assert_(table);	TableIndexT	theRows, theColumns;	table->GetTableSize(theRows, theColumns);	table->RemoveRows(theRows, 1, Refresh_No);	int		theItemCount = mAnlage->GetFreinummerCount() + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_Yes);	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	int	aktCount = (theRect.bottom - theRect.top - (ScrollBar_Size - 1)) / 16;	theRect.right = theRect.left + KT_Spalte_1  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	// Fenstergrš§e, Minimum + Maximum setzen (dazu mu§ das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort());	Assert_(theWind);	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = KT_Spalte_1  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(aktCount > theItemCount) aktCount = theItemCount;	theRect.bottom = theRect.top + 16  * aktCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		¥ CFreiTableView// ---------------------------------------------------------------------------//	CFreiTableView::CFreiTableView(LStream *inStream) : LTableView(inStream){	mAnlage = CISDNDesktop::GetAnlage(this);}// ---------------------------------------------------------------------------//		¥ ClickSelect// ---------------------------------------------------------------------------//	Adjust selection in response to a click in the specified cell////	Return whether or not to process the click as a normal clickBooleanCFreiTableView::ClickSelect(	const STableCell		&inCell,	const SMouseDownEvent	&inMouseDown){	if(inCell.row == 1) return false;	// Klick in die erste Reihe ist nicht mšglich!	if(mTableSelector != nil)		mTableSelector->ClickSelect(inCell, inMouseDown);	return true;}// ---------------------------------------------------------------------------//		¥ DrawCell// ---------------------------------------------------------------------------//	Draw the contents of the specified CellvoidCFreiTableView::DrawCell(	const STableCell	&inCell,	const Rect			&inLocalRect){	UTextTraits::SetPortTextTraits(129);	LStr255	theNummer;	if(inCell.row == 1) {		::MoveTo(inLocalRect.left, inLocalRect.bottom - 1);		::LineTo(inLocalRect.right, inLocalRect.bottom - 1);		theNummer.Assign(1000, 17);	} else {		mAnlage->GetFreinummer(inCell.row - 1, theNummer);	}	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);	::DrawString(theNummer);}// ---------------------------------------------------------------------------//		¥ ClickCell// ---------------------------------------------------------------------------//	Handle a mouse click within the specified CellvoidCFreiTableView::ClickCell(	const STableCell&		inCell,	const SMouseDownEvent&	/* inMouseDown */){	if(sClickCount < 2) return;	StDialogHandler	theSubHandler(306, this);	LWindow		*theSubDialog = theSubHandler.GetDialog();	LStr255	theNummer;	mAnlage->GetFreinummer(inCell.row - 1, theNummer);	LEditField	*theTelNumber = (LEditField*)theSubDialog->FindPaneByID('TeNr');	theTelNumber->SetDescriptor(theNummer);	theSubDialog->Show();	while (true) {					// Let DialogHandler process events		MessageT	hitMessage = theSubHandler.DoDialog();		if (hitMessage == msg_Cancel) {			break;		} else if(hitMessage == msg_OK) {			LStr255	theNumTemp;			theTelNumber->GetDescriptor(theNumTemp);			if(theNumTemp != theNummer) {				mAnlage->SetFreinummer(inCell.row - 1, theNumTemp);				mAnlage->SetDirty();				RefreshCell(inCell);			}			break;		}	}}#endif