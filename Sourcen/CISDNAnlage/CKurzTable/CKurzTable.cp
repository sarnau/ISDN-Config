// ===========================================================================//	CKurzTable.cp					© 1996, Markus Fritze. All rights reserved.// ===========================================================================#include "CKurzTable.h"#include <LTableMultiGeometry.h>#include <LTableSingleSelector.h>#include <UModalDialogs.h>#include <UTextTraits.h>#include <LEditField.h>#include "CISDNDesktop.h"#if INCLUDE_EURACOM || INCLUDE_ELMEGbool    CKurzTable::sRegisterClass = PPFactory<CKurzTable>::RegisterClass();bool    CKurzTableView::sRegisterClass = PPFactory<CKurzTableView>::RegisterClass();// ---------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------//	Finish Creating a Pane////	This function gets called after creating a Pane from a data stream.//	Override to perform finishing touches that depend on the entire//	Pane hierarchy being constructed.////	For example, if a View wants to store a pointer to a SubPane,//	it should override this function to call FindPaneByID for that//	Pane. This saves the overhead of repeatedly calling FindPaneByID//	when the View wants to access that SubPane. You can't do this from//	a Constructor because SubPanes are created after their SuperView.const SInt16	KT_Spalte_1 = 25;const SInt16	KT_Spalte_2 = 150;const SInt16	KT_Spalte_3 = 235;voidCKurzTable::FinishCreateSelf(){	CKurzTableView	*table = (CKurzTableView*)FindPaneByID('KuTA'); FailNIL_(table);	mAnlage = CISDNDesktop::GetAnlage(this); 	FailNIL_(mAnlage);	mAnlage->AddAttachment(this);	table->SetTableGeometry(new LTableMultiGeometry(table, KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3, 16));	table->SetTableSelector(new LTableSingleSelector(table));	SInt16		theItemCount = mAnlage->GetKurzwahlCount() + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_No);	table->InsertCols(3, 0, nil, 0, Refresh_No);	table->SetColWidth(KT_Spalte_1, 1, 1);	table->SetColWidth(KT_Spalte_2, 2, 2);	table->SetColWidth(KT_Spalte_3, 3, 3);	// Fenstergrš§e, Minimum + Maximum setzen (dazu mu§ das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort()); FailNIL_(theWind);	theWind->Show();	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	theRect.right = theRect.left + (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3)  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3)  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(theItemCount > 10) theItemCount = 10;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		¥ ExecuteSelf(MessageT inMessage, void *ioParam)// ---------------------------------------------------------------------------//	Draw the contents of the specified Cellvoid		CKurzTable::ExecuteSelf(MessageT inMessage, void *ioParam){#pragma unused (inMessage, ioParam)	CKurzTableView	*table = (CKurzTableView*)FindPaneByID('KuTA'); FailNIL_(table);	TableIndexT	theRows, theColumns;	table->GetTableSize(theRows, theColumns);	table->RemoveRows(theRows, 1, Refresh_No);	int		theItemCount = mAnlage->GetKurzwahlCount() + 1;	table->InsertRows(theItemCount, 0, nil, 0, Refresh_Yes);	Rect	theRect = (*((WindowPeek)GetMacPort())->contRgn)->rgnBBox;	int	aktCount = (theRect.bottom - theRect.top - (ScrollBar_Size - 1)) / 16;	theRect.right = theRect.left + (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3)  + ScrollBar_Size - 1;	theRect.bottom = theRect.top + 16  * theItemCount + ScrollBar_Size - 1;	Rect	theMinMaxRect;	// Fenstergrš§e, Minimum + Maximum setzen (dazu mu§ das Fenster sichtbar sein!)	LWindow	*theWind = LWindow::FetchWindowObject(GetMacPort()); FailNIL_(theWind);	theWind->GetMinMaxSize(theMinMaxRect);	theMinMaxRect.left = (KT_Spalte_1 + KT_Spalte_2 + KT_Spalte_3)  + ScrollBar_Size - 1;	theMinMaxRect.top = 16 * 5 + ScrollBar_Size - 1;	theMinMaxRect.right = theRect.right - theRect.left;	theMinMaxRect.bottom = theRect.bottom - theRect.top;	theWind->SetMinMaxSize(theMinMaxRect);	SDimension16	theStdSize;	theStdSize.width = theMinMaxRect.right;	theStdSize.height = theMinMaxRect.bottom;	theWind->SetStandardSize(theStdSize);	if(aktCount > theItemCount) aktCount = theItemCount;	theRect.bottom = theRect.top + 16  * aktCount + ScrollBar_Size - 1;	theWind->DoSetBounds(theRect);	theWind->Refresh();}// ---------------------------------------------------------------------------//		¥ CKurzTableView// ---------------------------------------------------------------------------//	Return a new TableView object initialized using data from a StreamCKurzTableView::CKurzTableView(LStream *inStream) : LTableView(inStream){	mAnlage = CISDNDesktop::GetAnlage(this); 	FailNIL_(mAnlage); }// ---------------------------------------------------------------------------//		¥ ClickSelect// ---------------------------------------------------------------------------//	Adjust selection in response to a click in the specified cell////	Return whether or not to process the click as a normal clickBooleanCKurzTableView::ClickSelect(	const STableCell		&inCell,	const SMouseDownEvent	&inMouseDown){	if(inCell.col == 1 || inCell.row == 1) return false;	// Klick in die erste Spalte/Reihe ist nicht mšglich!	if(mTableSelector != nil)		mTableSelector->ClickSelect(inCell, inMouseDown);	return true;}// ---------------------------------------------------------------------------//		¥ DrawCell// ---------------------------------------------------------------------------//	Draw the contents of the specified CellvoidCKurzTableView::DrawCell(	const STableCell	&inCell,	const Rect			&inLocalRect){ 	FailNIL_(mAnlage);	UTextTraits::SetPortTextTraits(129);	LStr255	theAppKurzNoStr;	LStr255	theAppNummer;	LStr255	theAppName;	if(inCell.row == 1) {		::MoveTo(inLocalRect.left, inLocalRect.bottom - 1);		::LineTo(inLocalRect.right, inLocalRect.bottom - 1);		theAppKurzNoStr.Assign(1000, 16);		theAppNummer.Assign(1000, 17);		theAppName.Assign(1000, 18);	} else {		SInt16	theAppKurzNo;		mAnlage->GetKurzwahl(inCell.row - 1, theAppKurzNo, theAppNummer, theAppName);		theAppKurzNoStr = LStr255(SInt32(theAppKurzNo));	}	switch(inCell.col) {	case 1:	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);			::DrawString(theAppKurzNoStr);			::MoveTo(inLocalRect.right - 1, inLocalRect.top);			::LineTo(inLocalRect.right - 1, inLocalRect.bottom);			break;	case 2:	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);			::DrawString(theAppNummer);			::MoveTo(inLocalRect.right - 1, inLocalRect.top);			::LineTo(inLocalRect.right - 1, inLocalRect.bottom);			break;	case 3:	::MoveTo(inLocalRect.left + 4, inLocalRect.bottom - 4);			::DrawString(theAppName);			break;	}}// ---------------------------------------------------------------------------//		¥ ClickCell// ---------------------------------------------------------------------------//	Handle a mouse click within the specified CellvoidCKurzTableView::ClickCell(	const STableCell&		inCell,	const SMouseDownEvent&	/* inMouseDown */){	if(sClickCount < 2) return; 	FailNIL_(mAnlage);	StDialogHandler	theSubHandler(300, this);	LWindow		*theSubDialog = theSubHandler.GetDialog(); FailNIL_(theSubDialog);	SInt16	theAppKurzNo;	LStr255	theAppNummer;	LStr255	theAppName;	mAnlage->GetKurzwahl(inCell.row - 1, theAppKurzNo, theAppNummer, theAppName);	LEditField	*theTelNumber = (LEditField*)theSubDialog->FindPaneByID('TeNr'); FailNIL_(theTelNumber);	theTelNumber->SetDescriptor(theAppNummer);	LEditField	*theName = (LEditField*)theSubDialog->FindPaneByID('Name'); FailNIL_(theName);	theName->SetDescriptor(theAppName);	theName->SetKeyFilter(AllInputField);	if(inCell.col == 3) {	// Doppelklick auf den Namen?		LCommander::SwitchTarget(theName);	// Cursor ins Feld setzen		theName->SelectAll();				// und alles selektieren	}	theSubDialog->Show();	while (true) {					// Let DialogHandler process events		MessageT	hitMessage = theSubHandler.DoDialog();		if (hitMessage == msg_Cancel) {			break;		} else if(hitMessage == msg_OK) {			LStr255	theNumTemp, theNameTemp;			theTelNumber->GetDescriptor(theNumTemp);			theName->GetDescriptor(theNameTemp);			if(theNumTemp != theAppNummer || theNameTemp != theAppName) {				mAnlage->SetKurzwahl(inCell.row - 1, theNumTemp, theNameTemp);				mAnlage->SetDirty();				STableCell	theCell = inCell;				STableCell	theEndCell = inCell;				theCell.col = 1;				theEndCell.col = 3;				RefreshCellRange(theCell, theEndCell);			}			break;		}	}}// ---------------------------------------------------------------------------//		¥ AllInputField// ---------------------------------------------------------------------------//	Key Filter for all charactersEKeyStatus	CKurzTableView::AllInputField(TEHandle	inMacTEH,									   UInt16	inKeyCode,									   UInt16	&ioCharCode,									   UInt16	inModifiers){#pragma unused(inMacTEH, inModifiers)	EKeyStatus	theKeyStatus = keyStatus_PassUp;	UInt16		theKey = inKeyCode;	UInt16		theChar = ioCharCode;	if (UKeyFilters::IsTEDeleteKey(theKey)) {		theKeyStatus = keyStatus_TEDelete;	} else if (UKeyFilters::IsTECursorKey(theKey)) {		theKeyStatus = keyStatus_TECursor;	} else if (UKeyFilters::IsExtraEditKey(theKey)) {		theKeyStatus = keyStatus_ExtraEdit;	} else if (UKeyFilters::IsActionKey(theKey)) {		theKeyStatus = keyStatus_PassUp;	} else {		theKeyStatus = keyStatus_Input;	}	return theKeyStatus;}#endif