/*** *	Euracom.h * *	(c)1996 Ackermann ***/#pragma once// jedwedes Alignment abschalten!#ifdef __MWERKS__#pragma align_array_members off#pragma options align=packed#endif#define MSN_MAX_ANZ			10	// max. Anzahl von MSN's pro S0-Port#define MSN_MAX_LEN			8	// max. Anzahl von Ziffern pro MSN#define RUF_NR_LEN			24	// max. Länge einer Rufnummer#define KURZ_NAME_LEN		38	// max. Länge einer Kurzwahlnummer#define USER_TO_USER_LEN	32	// max. Länge einer User to User Nachricht#define HAUPT_ANL_RNR_LEN	8	// max. Länge der Hauptanlagenrufnummer#define NAH_BER_NR_LEN		5	// max. Länge der Nahbereichsnummer#define MAX_RUF_VAR_LEN		30	// max. Listenlänge (max. Anzahl der Apparate)// Bit  0..7: analoge Teilnehmer 1…8// Bit  8..9: optionale TFE-Schnittstellen// Bit 10.19: interne S0-Teilnehmer an Port 2// Bit 20.29: interne S0-Teilnehmer an Port 3// Bit 30.31: ungenutzt#define KURZWAHL_MAX_BLOCK_ANZ	8	// Anzahl der Kurzwahleinträge in einem Buffer#define K_CMD_OFFSET_MASK				(UInt8)0xE0#define K_READ_CMD_OFFSET				(UInt8)0x00#define K_WRITE_CMD_OFFSET				(UInt8)0x20#define K_SERVICE_CMD_OFFSET			(UInt8)0x40#define K_STATUS_CMD_OFFSET				(UInt8)0x60#define K_A_ANL_OFFSET					(UInt8)0x00#define K_B_ANL_OFFSET					(UInt8)0x10#define K_READ_S0_PORT					(UInt8)(K_READ_CMD_OFFSET + 0x00)#define K_READ_S0_TLN					(UInt8)(K_READ_CMD_OFFSET + 0x01)#define K_READ_TLN_RUFNR_LIST			(UInt8)(K_READ_CMD_OFFSET + 0x02)#define K_READ_TLN_BER_LIST				(UInt8)(K_READ_CMD_OFFSET + 0x03)#define K_READ_TLN_RUF_VERT_LIST		(UInt8)(K_READ_CMD_OFFSET + 0x04)#define K_READ_TLN_GEB_KONF_LIST		(UInt8)(K_READ_CMD_OFFSET + 0x05)#define K_READ_ST_KON_LIST				(UInt8)(K_READ_CMD_OFFSET + 0x06)#define K_READ_NAH_BER_LIST				(UInt8)(K_READ_CMD_OFFSET + 0x07)#define K_READ_SPERR_BER_LIST			(UInt8)(K_READ_CMD_OFFSET + 0x08)#define K_READ_KURZ_ZENT_LIST			(UInt8)(K_READ_CMD_OFFSET + 0x09)#define K_READ_ANL_DAT_LIST				(UInt8)(K_READ_CMD_OFFSET + 0x0a)#define K_READ_TLN_DATA_LIST			(UInt8)(K_READ_CMD_OFFSET + 0x0b)#define K_READ_TLN_GEB_LIST				(UInt8)(K_READ_CMD_OFFSET + 0x0c)#define K_WRITE_S0_PORT					(UInt8)(K_WRITE_CMD_OFFSET + 0x00)#define K_WRITE_S0_TLN					(UInt8)(K_WRITE_CMD_OFFSET + 0x01)#define K_WRITE_TLN_RUFNR_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x02)#define K_WRITE_TLN_BER_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x03)#define K_WRITE_TLN_RUF_VERT_LIST		(UInt8)(K_WRITE_CMD_OFFSET + 0x04)#define K_WRITE_TLN_GEB_KONF_LIST		(UInt8)(K_WRITE_CMD_OFFSET + 0x05)#define K_WRITE_ST_KON_LIST				(UInt8)(K_WRITE_CMD_OFFSET + 0x06)#define K_WRITE_NAH_BER_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x07)#define K_WRITE_SPERR_BER_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x08)#define K_WRITE_KURZ_ZENT_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x09)#define K_WRITE_ANL_DAT_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x0a)#define K_WRITE_TLN_DATA_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x0b)#define K_WRITE_TLN_GEB_LIST			(UInt8)(K_WRITE_CMD_OFFSET + 0x0c)// Timeouts:// normal (DOS-Version) 10s besser (neu: Windows-Version) 3s// EPROM-CRC: 100s#define K_GET_EPROM_VER					(UInt8)(K_SERVICE_CMD_OFFSET + 0x00)#define K_GET_EPROM_CRC					(UInt8)(K_SERVICE_CMD_OFFSET + 0x01)#define K_CHECK_EEP						(UInt8)(K_SERVICE_CMD_OFFSET + 0x02)#if 0#define K_TEST_RAM						(UInt8)(K_SERVICE_CMD_OFFSET + 0x03)#define K_CHK_RUFE						(UInt8)(K_SERVICE_CMD_OFFSET + 0x04)#define K_CHK_HOERTOENE					(UInt8)(K_SERVICE_CMD_OFFSET + 0x05)#define K_CHK_KOPPELFELD				(UInt8)(K_SERVICE_CMD_OFFSET + 0x06)#define K_CHK_S0_ANSCHLUSS				(UInt8)(K_SERVICE_CMD_OFFSET + 0x07)#define K_GET_ERROR_SPEICHER			(UInt8)(K_SERVICE_CMD_OFFSET + 0x08)#endif#define K_WR_OK							(UInt8)(K_STATUS_CMD_OFFSET + 0x00)#define K_V24_WR_EINRICHT_START			(UInt8)(K_STATUS_CMD_OFFSET + 0x01)#define K_V24_RD_EINRICHT_START			(UInt8)(K_STATUS_CMD_OFFSET + 0x02)#define K_V24_EINRICHT_ENDE				(UInt8)(K_STATUS_CMD_OFFSET + 0x03)//#define K_V24_SERVICE_KZ				(UInt8)(K_STATUS_CMD_OFFSET + 0x04)#define K_CRC_ERR						(UInt8)(K_STATUS_CMD_OFFSET + 0x09)#define K_CMD_ERR						(UInt8)(K_STATUS_CMD_OFFSET + 0x0a)#define K_CMD_PRIO_CHANGED				(UInt8)(K_STATUS_CMD_OFFSET + 0x0b)#define K_V24_ERR						(UInt8)(K_STATUS_CMD_OFFSET + 0x0c)//#define K_B_ANL_DATEN					(UInt8)(K_STATUS_CMD_OFFSET + 0x0d)#define K_V24_WR_EINRICHT_START_REPEAT	(UInt8)(K_STATUS_CMD_OFFSET + 0x0e)#define K_V24_EINRICHT_ENDE_REPEAT		(UInt8)(K_STATUS_CMD_OFFSET + 0x0f)typedef struct {	UInt8		InfoLen;			// Länge des Buffers inkl. Längeneintrag	UInt8		MsgType;			// Typ der Message	UInt16		Checksumm;			// Prüfsumme über die Daten (wenn vorhanden!)	UInt8		Data[1];			// Daten (1 Nullbyte wird auch bei leeren Nachrichten übertragen!)} Hdr;typedef struct IsdnS0TInZuordType {	UInt32		ATInZuordnung;		// Zuordnungsfeld der eigenen Anlage	UInt32		BTInZuordnung;		// Zuordnungsfeld der benachbarten Anlage} IsdnS0TInZuordType;#define PORT_NICHT_KONFIGURIERT		0x00#define PORT_DIRECTION_FILTER		0xc0#define PORT_DIRECTION_INTERN		0x40#define PORT_DIRECTION_EXTERN		0x80#define PORT_DIRECTION_QUER			0xc0#define PORT_MODE_FILTER			0x30#define PORT_MODE_PTP				0x00	// Anlagenanschluß#define PORT_MODE_PTMP				0x10	// Mehrgeräte#define PORT_MODE_S2M				0x20	// Primärmultiplex#define TLN_PROTOKOLL_FILTER		0x0e#define TLN_PROTOKOLL_EDSS1			0x02#define PORT_WAHL_FILTER			0x01// Momentan wie Bit 4!!!! WICHTIG!#define PORT_WAHL_MSN				0x00	// Mehrgeräte (keine Durchwahl)#define PORT_WAHL_DDI				0x01	// Anlagenschluß (Durchwahl)typedef struct IsdnPort {	UInt8				PortTyp;	char				Anlagenrufnummer[RUF_NR_LEN];	char				MsnBlock[MSN_MAX_ANZ][MSN_MAX_LEN+1];	IsdnS0TInZuordType	TIn[MSN_MAX_ANZ];} IsdnPort;typedef struct IsdnKonf {	UInt8				AnzPort;	// Anzahl der genutzten ISDN-Ports	IsdnPort			Port[3];	// Infos für die einzelnen Ports} IsdnKonf;#define ANL_TYP_ANL			1		// Standardanlage (Einzelanlage)#define ANL_TYP_UNT_NAH		2		// Unteranlage direkt an Hauptanlage#define ANL_TYP_UNT_FERN	3		// Unteranlage über Amt an Hauptanlage#define ANL_TYP_A_VERN		4		// Vernetze Anlage "Master"#define ANL_TYP_B_VERN		5		// Vernetze Anlage "Slave"typedef struct RufNrZuord {	char				HauptAnl[HAUPT_ANL_RNR_LEN+1];	// Hauptanlagenrufnummer (bei ferner Hauptanlage)	char				Rufnummer[MAX_RUF_VAR_LEN][3];	// Telefonnummern der Apparate (2 Ziffern + Nullbyte)	UInt8				HauptAnlNahFern;	// s.o.} RufNrZuord;#define ANZ_AB_PORT			10#define ANZ_TFE_PORT		2typedef struct TInBerechtigung {	UInt32				Masterber;		// Apparate-Flags für Masterberechtigung	UInt32				Aufschaltsch;	// Apparate-Flags für Aufschaltsperre	UInt32				Aufschalt;		// Apparate-Flags für Aufschalterlaubnis	Uchar				Berechtigung[MAX_RUF_VAR_LEN];			// Amtsberechtigungen (siehe Bitmaske)	Uchar				Geraetetyp[ANZ_AB_PORT - ANZ_TFE_PORT];	// Telefon, Fax, Modem, Kombi} TInBerechtigung;typedef struct TInRufvert {	UInt32				Aval;				// Anrufvariante #1	UInt32				BAval;	UInt32				Ava2;				// Anrufvariante #2	UInt32				BAva2;	UInt32				Tfe1;				// Türfreisprecheinrichtung #1	UInt32				BTfe1;	UInt32				Tfe2;				// Türfreisprecheinrichtung #2	UInt32				BTfe2;	UInt32				Rws;				// Rufweiterschaltung	UInt32				BRwr;	UInt32				Zweitwecker1;		// Zweitwecker #1	UInt32				Zweitwecker2;		// Zweitwecker #2	UInt8				RwsTime;			// globale Zeit der Rufweiterschaltung	UInt8				AutoAmtGlob;		// 1 = automatische Amtsholung} TInRufvert;typedef struct SteuerKontakt {	UInt16				StartZeit;				// Stunden * 100 + Minuten	UInt16				EndZeit;				// Stunden * 100 + Minuten	UInt16				Ask1Zeit;				// Schaltzeit Aktor #1 (0..120 Sekunden)	UInt16				Ask2Zeit;				// Schaltzeit Aktor #2	UInt8				Kontakt1;				// Aktor #1: öffnen, schließen, deaktiviert (0..2?!?)	UInt8				Kontakt2;				// Aktor #2: öffnen, schließen, deaktiviert	UInt8				Autoanwahl;				// 1 = automatische Anwahl	char				Rnr1[RUF_NR_LEN+1];	char				Rnr2[RUF_NR_LEN+1];		// 3 Rufnummern, die  bis zum Erfolg durchprobiert werden	char				Rnr3[RUF_NR_LEN+1];	Uchar				UserToUser[USER_TO_USER_LEN+1];	// Alarmmeldung, via ISDN (wenn freigeschaltet)} SteuerKontaktType;#define CODE_NR_LEN			6typedef struct GlobAnlDaten {	char				UserToUser[USER_TO_USER_LEN+1];	// User2User Text für ISDN-Übermittlung	char				CodeNummer[CODE_NR_LEN+1];		// Codenummer für diverse Zwecke	char				Landeskennung[CODE_NR_LEN+1];	// "49" in Deutschland	char				OrtsKennZif[NAH_BER_NR_LEN+1];	// "40" in Hamburg	char				Hotline[RUF_NR_LEN+1];			// für automatische Weiterleitung	UInt8				Moh;							// Musik on Hold-Flag (0,1,2 für aus, intern, extern)	UInt8				AmtAmtWeitergabe;				// Bit 0: 1 = Rufweitergabe														// Bit 1: 1 = LM über Rufnummern 98/99														// Bit 2: 1 = Privatgespräche	UInt8				Reserve[0x1F];					// noch unbenutzt (müssen 0 sein!)	UInt8				AktAva;		// Einzelanlage = 0;									// ferne Unteranlage, vernetzte Anlage = 1									// lokale Unteranlage = 2} GlobAnlDaten;#define FW_GEB_PRN_MASK					(UInt8)0xfc#define FW_GEB_PRN_DRUCKER				(UInt8)0x02#define FW_GEB_PRN_DEST_MASK			(UInt8)0xf3#define FW_GEB_PRN_DEST_AUS				(UInt8)0x00#define FW_GEB_PRN_DEST_EIN				(UInt8)0x04#define FW_GEB_PRN_DEST_GEK				(UInt8)0x08#define FW_GEB_MSG_TO_TLN				(UInt8)0x10#define FW_GEB_IMPULS_MASK				(UInt8)0x1f#define FW_GEB_IMPULS_16K				(UInt8)0x20#define FW_GEB_IMPULS_12K				(UInt8)0x40//#define FW_GEB_IMPULS_50HZ			(UInt8)0x80#define FW_PC_COM1						(UInt8)0x01#define FW_PC_COM2						(UInt8)0x02#define FW_PRN_CALL_FROM_AMT			(UInt8)0x04#define FW_PRN_CONN_FROM_AMT			(UInt8)0x08typedef struct TInGebKonf {	UInt32				Pc;	UInt32				Prn;	UInt32				PrnEin;	UInt32				PrnGek;	UInt32				GebToTIn;	Uchar				Peak[MAX_RUF_VAR_LEN+1];		// pro Apparat	UInt8				GrundFaktor;	Uchar				UserFaktor[MAX_RUF_VAR_LEN+1];	// pro Apparat	UInt8				Flags;	UInt8				WaehrFaktor;	// n.u.	UInt8				GebImpuls;		// GebInfo zum Teilnehmer (bitfeld)	UInt8				GebInfo;		// n.u.	UInt8				PrnZeilenAnz;	// Anzahl der zu druckenden Zeilen} TInGebKonf;typedef struct EinrichtKonfig {	IsdnKonf			S0[2];	RufNrZuord			RufNr[2];	TInBerechtigung		TInBer[2];	TInRufvert			TInRufVert[2];	TInGebKonf			TInGebKonf[2];	SteuerKontakt		StKon[2];	GlobAnlDaten		AnlDat;	UInt8				HauptUnteranlage;	// Anlagenflag} EinrichtKonfig;	// 2099 Bytes langtypedef struct TInDataStruct {	UInt8				PortNr;			// zugehöriger Port	UInt32				Geb;			// Gebührenimpuls?!?	UInt8				IntRufNr;		// binär codierte Internrufnummer	UInt16				SchaltStatus;	// Status der Schalt-LMs2	UInt16				WeckZeit;		// Weckzeit in Minuten	UInt16				Rechte;			// Berechtigung des Teilnehmers	UInt16				Abteilung;		// Abrechnungstechnische Einheit	UInt16				Gruppe;			// Räumliche Einheit	UInt16				KW_Tab;			// Default: -1 für nicht belegt	UInt16				CFB_Id[RUF_NR_LEN+1];	// Default: -1 für nicht belegt	UInt16				CFNR_Id[RUF_NR_LEN+1];	// Default: -1 für nicht belegt	UInt8				CFNR_Zeit;		// Default: 0 Sekunden für CFNR => CFU	UInt8				Typ;			// Teilnehmerklasse und Dienste} TInDataStruct;#define SOS_ERROR_BUF_LEN			0x40typedef struct SosFktErrorStruct {	UInt16				Info;			// Funktionskennung	UInt16				LinNum;			// Zeilennummer	UInt16				ErrorC;			// Fehlercode	UInt8				Task;			// Nummer des Prozesses} SosFktErrorStruct;typedef struct ErrorStruct {	UInt16				ErrorCnt;		// Anzahl der Einträge in der Euracom	SosFktErrorStruct	Err[SOS_ERROR_BUF_LEN];} ErrorStruct;typedef struct RdErrorStruct {	UInt16				ErrorCnt;		// Anzahl der Einträge in der Euracom	SosFktErrorStruct	Err[16];		// maximal 10 Einträge} RdErrorStruct;#define ANZ_NAH_BER_NR		20#define ANZ_SPERR_NR		20#define SPERR_NR_LEN		5typedef struct NahSperrBer {	char				Nahber[ANZ_NAH_BER_NR][NAH_BER_NR_LEN+1];	// Nahbereichsnummern	char				Sperrber[ANZ_SPERR_NR][SPERR_NR_LEN+1];		// Sperrbereichsnummern} NahSperrBer;#define ANZ_KW_NR					200typedef struct KurzwZiele {	char				RufNr[RUF_NR_LEN+1];	// einfach der Nummernstring} KurzwZiele;typedef struct KzWork {	KurzwZiele			RNr[ANZ_KW_NR];		// Kurzwahl	char				Namen[ANZ_KW_NR][KURZ_NAME_LEN+1];	// dazugehöriger Name (momentan ungenutzt)} KzWork;typedef struct KurzwahlKonfig {	KzWork				Kurz;	NahSperrBer			NahSperr;} KurzwahlKonfig;#ifdef __MWERKS__#pragma options align=reset#pragma align_array_members reset#endif