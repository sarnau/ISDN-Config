#include "SharewareFlags.h"#if INCLUDE_EURACOM#include "CEuracom.h"#include "MRFUtilities.h"#include "ProgressBar.h"#include "CPreferences.h"/*** *	Befehl von der Euracom erwarten ***/void		CEuracom::GetCommand(StringPtr iBuf){	iBuf[0] = 0;					// LŠngenbyte lšschen	do {		if(mSd->Read(iBuf, 1) != 1)	// LŠngenbyte lesen			Throw_(ioErr);			// Timeout!	} while(iBuf[0] == 0);			// Nullbytes ignorieren!	if(mSd->Read(iBuf + 1, iBuf[0] - 1) != iBuf[0] - 1)	// Rest des Befehls lesen		Throw_(ioErr);				// Timeout!}/*** *	CRC Ÿber die Nutzdaten berechnen ***/UInt16		CEuracom::CalcCRC(const void *iPtr, UInt16 iCount){const UInt8		*iSPtr = (const UInt8*)(iPtr);UInt16			oCRC = 0x0000;	while(iCount-- > 0) {		if(oCRC & 1) {			oCRC >>= 1;			oCRC |= 0x8000;		} else			oCRC >>= 1;		oCRC += *iSPtr;		iSPtr++;	}	return oCRC;}/*** *	Senden an die Euracom initieren ***/void		CEuracom::InitCommand(){	UInt8	cmd[256];	BlockFill(cmd, 0, sizeof(cmd));	// 256 Nullbytes senden	mSd->Write(cmd, sizeof(cmd));}/*** *	Befehl an die Euracom senden ***/void		CEuracom::SendCommand(UInt8 iCmd, const void *iData, UInt16 len){UInt8		cmd[256];	BlockFill(&cmd, 0x00, sizeof(cmd));	cmd[1] = iCmd;	if(len > 0) {		SignalIf_(iData == nil);		UInt16	theCRC = CalcCRC(iData, len);		cmd[2] = theCRC;		cmd[3] = theCRC >> 8;		::BlockMoveData(iData, cmd + 4, len);	} else {		cmd[2] = cmd[3] = 0x00;		cmd[4] = (iData == 0) ? 0 : *(char*)iData;	// ein Dummy-Nullbyte bzw. Parameter senden		len = 1;	}	cmd[0] = len + 4;	mSd->Write(cmd, cmd[0]);}/*** *	Befehl senden und auf Antwort warten ***/void		CEuracom::SendAndRead(UInt8 iCmd, StringPtr oBuf, UInt8 iParam){	SendCommand(iCmd, &iParam);	mSd->SetTimeout(60 * 2);	// Timeout = 2s	GetCommand(oBuf);}/*** *	Euracom auslesen ***/void		CEuracom::Auslesen(){	try{		SerialDriver	sd(gPrefs->P.Port, false);		mSd = &sd;		try{			sd.Open(baud4800+data8+stop10+noParity);			sd.DTR(true);			InitCommand();		}		catch(LException err) {			ErrorAlert(err, 130);			return;		} 		ProgressBar	pb(1000, 1, 10);		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		EinrichtKonfig	theAnlage;		BlockFill(&theAnlage, 0x00, sizeof(mAnlage));		Str255			theBuf;		// Kommunikation beginnen		SendAndRead(K_V24_RD_EINRICHT_START, theBuf);		if(theBuf[0] != 4 && theBuf[1] != K_WR_OK) Throw_(ioErr);		pb.Set(1);		// 1. Port auslesen		SendAndRead(K_READ_S0_PORT, theBuf, 0x00);		if(theBuf[1] != K_READ_S0_PORT) Throw_(ioErr);		UInt8	thePortAnz = theBuf[4] - 1;		theAnlage.S0[0].AnzPort = thePortAnz;		::BlockMoveData(theBuf + 5, &theAnlage.S0[0].Port[0], sizeof(IsdnPort));		// ggf. weitere Ports lesen		for(UInt8 thePortIndex = 1; thePortAnz-- > 0; thePortIndex++) {			SendAndRead(K_READ_S0_PORT, theBuf, thePortIndex);			if(theBuf[1] != K_READ_S0_PORT) Throw_(ioErr);			::BlockMoveData(theBuf + 5, &theAnlage.S0[0].Port[thePortIndex], sizeof(IsdnPort));		}		pb.Set(2);		// Isdn S0 TIn Zuordnung lesen		// 1. Port auslesen		SendAndRead(K_READ_S0_TLN, theBuf, 0x00);		if(theBuf[1] != K_READ_S0_TLN) Throw_(ioErr);		::BlockMoveData(theBuf + 5, &theAnlage.S0[0].Port[0].TIn[0], sizeof(IsdnS0TInZuordType));		// ggf. weitere Ports lesen		thePortAnz = theAnlage.S0[0].AnzPort;		for(UInt8 thePortIndex = 1; thePortAnz-- > 0; thePortIndex++) {			SendAndRead(K_READ_S0_TLN, theBuf, thePortIndex);			if(theBuf[1] != K_READ_S0_TLN) Throw_(ioErr);			::BlockMoveData(theBuf + 5, &theAnlage.S0[0].Port[thePortIndex].TIn[0], sizeof(IsdnS0TInZuordType));		}		pb.Set(3);		// Rufnummernzuordnung lesen		SendAndRead(K_READ_TLN_RUFNR_LIST, theBuf);		if(theBuf[1] != K_READ_TLN_RUFNR_LIST) Throw_(ioErr);		::BlockMoveData(theBuf + 4, &theAnlage.RufNr[0], sizeof(RufNrZuord));		pb.Set(4);		// Berechtigungen lesen		SendAndRead(K_READ_TLN_BER_LIST, theBuf);		if(theBuf[1] != K_READ_TLN_BER_LIST) Throw_(ioErr);		::BlockMoveData(theBuf + 4, &theAnlage.TInBer[0], sizeof(TInBerechtigung));		pb.Set(5);		// Rufverteilung lesen		SendAndRead(K_READ_TLN_RUF_VERT_LIST, theBuf);		if(theBuf[1] != K_READ_TLN_RUF_VERT_LIST) Throw_(ioErr);		::BlockMoveData(theBuf + 4, &theAnlage.TInRufVert[0], sizeof(TInRufvert));		pb.Set(6);		// globale Anlagendaten lesen		SendAndRead(K_READ_ANL_DAT_LIST, theBuf);		if(theBuf[1] != K_READ_ANL_DAT_LIST) Throw_(ioErr);		::BlockMoveData(theBuf + 4, &theAnlage.AnlDat, sizeof(GlobAnlDaten));		pb.Set(7);		// Steuerkontakte lesen		SendAndRead(K_READ_ST_KON_LIST, theBuf);		if(theBuf[1] != K_READ_ST_KON_LIST) Throw_(ioErr);		::BlockMoveData(theBuf + 4, &theAnlage.StKon[0], sizeof(SteuerKontakt));		pb.Set(8);		// GebŸhrenkonfiguration lesen		SendAndRead(K_READ_TLN_GEB_KONF_LIST, theBuf);		if(theBuf[1] != K_READ_TLN_GEB_KONF_LIST) Throw_(ioErr);		::BlockMoveData(theBuf + 4, &theAnlage.TInGebKonf[0], sizeof(TInGebKonf));		pb.Set(9);		// Kommunikation abschlie§en		SendCommand(K_V24_EINRICHT_ENDE);		pb.Set(10);		IntelSwap(theAnlage);					// und fŸr das Auslesen drehen		mAnlage = theAnlage;		InitCursor();		SetDirty();		ExecuteAttachments(msg_AnlageDirty, nil);	}	catch(LException err) {		ErrorAlert(err);	} 	mSd = 0L;}/*** *	Euracom wegschreiben ***/#if !DEMO_VERSIONvoid		CEuracom::Senden(){	try{		SerialDriver	sd(gPrefs->P.Port);		mSd = &sd;		int	theAppCount = 64;				// 64 Apparate Ÿbertragen		ProgressBar	pb(1000, 2, 3 + theAppCount);		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);	}	catch(LException err) {		ErrorAlert(err);	} 	InitCursor();	mSd = 0L;}#endif/*** *	Euracom zurŸcksetzen ***/void		CEuracom::Reset(){	try{		SerialDriver	sd(gPrefs->P.Port);		mSd = &sd;		const int		theSeconds = 30;	// 30 Sekunden warten		const int		the60Ticks = 15;	// 4 mal pro Sekunde (60/15 = 4Hz) ein Update der Progressbar		ProgressBar	pb(1000, 7, (60 / the60Ticks) * theSeconds);		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);	}	catch(LException err) {		ErrorAlert(err);	} 	InitCursor();	mSd = 0L;}/*** *	Euracom zurŸcksetzen ***/#if !DEMO_VERSIONvoid		CEuracom::ReadGeb(){	try{		SerialDriver	sd(gPrefs->P.Port);		mSd = &sd;		CursHandle	theCursH = ::GetCursor(watchCursor);		if(theCursH != nil)			::SetCursor(*theCursH);		FSSpec	fs;		GetIndString(fs.name, 1000, 8);		fs.parID = 0L;		fs.vRefNum = 0;		LFileStream	fss(fs);		LStr255		s;		try{			fss.OpenDataFork(fsWrPerm);	// Datei šffnen		}		catch(LException err) {			fss.CreateNewDataFile('ttxt', 'TEXT', smSystemScript);	// bei Bedarf erstellen			fss.OpenDataFork(fsWrPerm);		} 		fss.SetMarker(fss.GetLength(), streamFrom_Start);	// Ptr aufs Dateiende		// Datum/Uhrzeit		UInt32	rawSecs;		Str255	resultStr;		GetDateTime(&rawSecs);		IUDateString(rawSecs, shortDate, resultStr);		s = resultStr;		s += "\p;";		s += resultStr;		s += "\p ";		IUTimeString(rawSecs, false, resultStr);		s += resultStr;		s += "\p;";		// bei rein analogen Euracom nur die analogen Apparate exportieren, sonst _alle_		SInt32	theAppCount = 64;		// Gesamtsumme		SInt32	sum = 0L;//		for(int i=0; i<theAppCount; i++)//			sum += mGeb[i];		s += LStr255(sum);		fss.WriteData((StringPtr)s + 1, s.Length());		// und die Einzelsummen		for(int i=0; i<theAppCount; i++) {			s = "\p;";			s += LStr255(SInt32(mGeb[i]));			fss.WriteData((StringPtr)s + 1, s.Length());		}		s = "\p\r";		fss.WriteData((StringPtr)s + 1, s.Length());	}	catch(LException err) {		ErrorAlert(err);	} 	InitCursor();	mSd = 0L;}#endif#endif