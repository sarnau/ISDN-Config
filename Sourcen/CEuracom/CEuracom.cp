// ===========================================================================//	CEuracom.cp						©1994 Metrowerks Inc. All rights reserved.// ===========================================================================#include "SharewareFlags.h"#if INCLUDE_EURACOM#include "CEuracom.h"#include "MRFUtilities.h"#include "CPreferences.h"#include <UMemoryMgr.h>// ---------------------------------------------------------------------------//		• CEuracom()// ---------------------------------------------------------------------------// Anlage definierenCEuracom::CEuracom(){	SetDefault();	SetDirty(false);}// ---------------------------------------------------------------------------//		• GetAnlagenName(LStr255 &oAnlageName) const// ---------------------------------------------------------------------------// Namen der Telefonanlage zurückgebenvoid	CEuracom::GetAnlagenName(LStr255 &oAnlageName) const{	switch(GetAnlagenTyp(1)) {	case AT_I180:			oAnlageName = "\p180";			break;	case AT_I181:			oAnlageName = "\p181";			break;	case AT_I182:			oAnlageName = "\p182";			break;	}	switch(GetAnlagenTyp(2)) {	case AT_I180:			oAnlageName += "\p & 180";			break;	case AT_I181:			oAnlageName += "\p & 181";			break;	case AT_I182:			oAnlageName += "\p & 182";			break;	default:break;	}}// ---------------------------------------------------------------------------//		• IsAppActive(SInt16 iAppIndex)// ---------------------------------------------------------------------------// Aufbau vom Apparate-Index://  0… 9: analoge Apparate + TFE (0…9) von Anlage 1// 10…19: analoge Apparate + TFE (0…9) von Anlage 2 (wenn vorhanden!)// 20…29: erster S0 (10…19) von Anlage 1 (wenn intern definiert!)// 30…39: zweiter S0 (20…29) von Anlage 1 (wenn intern definiert!)// 40…49: erster S0 (10…19) von Anlage 2 (wenn intern definiert!)// 50…59: zweiter S0 (20…29) von Anlage 2 (wenn intern definiert!)// wenn ein Bereich nicht definiert ist, rücken die anderen Bereiche aufBoolean	CEuracom::IndexToApp(SInt16 iAppIndex, SInt16 &oAnlage, SInt16 &oAnlIndex) const{	const Boolean	has2AB = (GetAnlagenTyp(2) > 0);	const Boolean	has1S0_2 = mAnlage.S0[0].AnzPort > 0 && (mAnlage.S0[0].Port[1].PortTyp & PORT_DIRECTION_FILTER) == PORT_DIRECTION_INTERN;	const Boolean	has1S0_3 = mAnlage.S0[0].AnzPort > 1 && (mAnlage.S0[0].Port[2].PortTyp & PORT_DIRECTION_FILTER) == PORT_DIRECTION_INTERN;	const Boolean	has2S0_2 = mAnlage.S0[1].AnzPort > 0 && (mAnlage.S0[1].Port[1].PortTyp & PORT_DIRECTION_FILTER) == PORT_DIRECTION_INTERN;	const Boolean	has2S0_3 = mAnlage.S0[1].AnzPort > 1 && (mAnlage.S0[1].Port[2].PortTyp & PORT_DIRECTION_FILTER) == PORT_DIRECTION_INTERN;	// analoge Anschlüsse von Anlage 1 (iAppIndex: 00..09)	if(/*has1AB*/1) {		oAnlage = 0;		oAnlIndex = iAppIndex;		if(iAppIndex < ANZ_AB_PORT) return true;	} else {//		iAppIndex += 0;	}	// analoge Anschlüsse von Anlage 2 (iAppIndex: 10..19)	if(has2AB) {		oAnlage = 1;		oAnlIndex = iAppIndex - ANZ_AB_PORT;		if(oAnlIndex < ANZ_AB_PORT) return true;	} else {		iAppIndex += ANZ_AB_PORT;	}	// 2. S0 Anschlüsse von Anlage 1 (iAppIndex: 20..29)	if(has1S0_2) {		oAnlage = 0;		oAnlIndex = iAppIndex - ANZ_AB_PORT;		if(oAnlIndex < (ANZ_AB_PORT + MSN_MAX_ANZ)) return true;	} else {		iAppIndex += ANZ_AB_PORT;	}	// 3. S0 Anschlüsse von Anlage 1 (iAppIndex: 30..39)	if(has1S0_3) {		oAnlage = 0;		oAnlIndex = iAppIndex - ANZ_AB_PORT;		if(oAnlIndex < (ANZ_AB_PORT + MSN_MAX_ANZ * 2)) return true;	} else {		iAppIndex += MSN_MAX_ANZ;	}	// 2. S0 Anschlüsse von Anlage 2 (iAppIndex: 40..49)	if(has2S0_2) {		oAnlage = 1;		oAnlIndex = iAppIndex - ANZ_AB_PORT - MSN_MAX_ANZ * 2;		if(oAnlIndex < (ANZ_AB_PORT + MSN_MAX_ANZ)) return true;	} else {		iAppIndex += MSN_MAX_ANZ;	}	// 3. S0 Anschlüsse von Anlage 2 (iAppIndex: 50..59)	if(has2S0_3) {		oAnlage = 1;		oAnlIndex = iAppIndex - ANZ_AB_PORT - MSN_MAX_ANZ * 2;		if(oAnlIndex < (ANZ_AB_PORT + MSN_MAX_ANZ * 2)) return true;	} else {//		iAppIndex += MSN_MAX_ANZ;	}	// illegaler Index!	oAnlage = 0;	oAnlIndex = 0;//	Throw_(err_AssertFailed);	return false;}// ---------------------------------------------------------------------------//		• IsAppActive(SInt16 iAppIndex)// ---------------------------------------------------------------------------// Apparat aktiv? (d.h. es ist ihm mindestens eine MSN zugeteilt)// Euracom: er muß eine interne Nummer haben!Boolean	CEuracom::IsAppActive(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return false;	return mAnlage.RufNr[theAnlage].Rufnummer[theAnlIndex][0] != 0;}// ---------------------------------------------------------------------------//		• GetAppNo(SInt16 iAppIndex)// ---------------------------------------------------------------------------// Durchwahlnummer eines Apparates ermittelnUInt16	CEuracom::GetAppNo(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return 0;	return SInt32(LStr255(mAnlage.RufNr[theAnlage].Rufnummer[theAnlIndex]));}// ---------------------------------------------------------------------------//		• GetAppName(SInt16 iAppIndex, LStr255 &oAppName)// ---------------------------------------------------------------------------// Namen eines Apparates ermittelnvoid	CEuracom::GetAppName(SInt16 iAppIndex, LStr255 &oAppName) const{	oAppName.Assign(1000, 13);}void	CEuracom::SetAppName(SInt16 iAppIndex, const LStr255 &iAppName){#pragma unused(iAppIndex, iAppName)}// ---------------------------------------------------------------------------//		• GetAppDienst(SInt16 iAppIndex)// ---------------------------------------------------------------------------// Dienstmerkmal eines Apparates zurückgebenEndgeraetedienst	CEuracom::GetAppDienst(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return Endgeraetedienst_Unbekannt;	if(theAnlIndex >= ANZ_AB_PORT) {		if((theAnlIndex - ANZ_AB_PORT) % 10 == 0)	// der digitale Apparat 0 ist die Sammelnummer			return Endgeraetedienst_DigitalSammelnummer;		return Endgeraetedienst_Digital;	// digitaler Apparat	}	if(theAnlIndex >= ANZ_AB_PORT - ANZ_TFE_PORT) return Endgeraetedienst_Tuerstelle;	switch(mAnlage.TInBer[theAnlage].Geraetetyp[theAnlIndex]) {	default:return Endgeraetedienst_Unbekannt;	case 0:	return Endgeraetedienst_Fernsprechen;		// Fernsprechen	case 1:	return Endgeraetedienst_Anrufbeantworter;	// Anrufbeantworter	case 2:	return Endgeraetedienst_Fax;				// Fax Gruppe 3	case 3:	return Endgeraetedienst_Modem;				// Daten/Modem	case 4:	return Endgeraetedienst_Kombi;				// Kombidienst	case 5:	return Endgeraetedienst_Tuerstelle;			// Türsprechstelle	}}// ---------------------------------------------------------------------------//		• GetAppBerechtigung(SInt16 iAppIndex) const// ---------------------------------------------------------------------------// Amtsberechtigung eines Apparates zurückgebenEndgeraeteberechtigung	CEuracom::GetAppBerechtigung(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return EB_unbekannt;	switch(mAnlage.TInBer[theAnlage].Berechtigung[theAnlIndex]) {	default:return EB_unbekannt;	case 0:	return EB_keine;	case 1:	return EB_Halbamt;	case 2:	return EB_Ort;	case 3:	return EB_Nah;	case 4:	return EB_Inland;	case 5:	return EB_Vollamt;	}}// ---------------------------------------------------------------------------//		• GetMasterberechtigung(SInt16 iAppIndex) const// ---------------------------------------------------------------------------// Boolean		CEuracom::GetMasterberechtigung(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return false;	return (mAnlage.TInBer[theAnlage].Masterber & (1L << theAnlIndex)) != 0L;}// ---------------------------------------------------------------------------//		• GetAufschaltsperre(SInt16 iAppIndex) const// ---------------------------------------------------------------------------// Boolean		CEuracom::GetAufschaltsperre(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return false;	return (mAnlage.TInBer[theAnlage].Aufschaltsch & (1L << theAnlIndex)) != 0L;}// ---------------------------------------------------------------------------//		• GetAufschalterlaubnis(SInt16 iAppIndex) const// ---------------------------------------------------------------------------// Boolean		CEuracom::GetAufschalterlaubnis(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return false;	return (mAnlage.TInBer[theAnlage].Aufschalt & (1L << theAnlIndex)) != 0L;}// ---------------------------------------------------------------------------//		• GetAppGeb(SInt16 iAppIndex)// ---------------------------------------------------------------------------// Gebührenzähler (Einheiten) eines Apparates ermittelnUInt16	CEuracom::GetAppGeb(SInt16 iAppIndex) const{	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return 0;	return mGeb[theAnlage][theAnlIndex];}// ---------------------------------------------------------------------------//		• SetAppGeb(SInt16 iAppIndex, UInt16 theGebcount)// ---------------------------------------------------------------------------// Gebührenzähler (Einheiten) eines Apparates setzenvoid	CEuracom::SetAppGeb(SInt16 iAppIndex, UInt16 theGebcount){	if(GetAppGeb(iAppIndex) == theGebcount) return;	// Wert nicht geändert!	SInt16	theAnlage;	SInt16	theAnlIndex;	if(!IndexToApp(iAppIndex, theAnlage, theAnlIndex)) return;	mGeb[theAnlage][theAnlIndex] = theGebcount;	SetDirty();}// ---------------------------------------------------------------------------//		• GetKurzwahl(SInt16 iKurzIndex, SInt16 &oAppKurzNo, LStr255 &oAppNummer, LStr255 &oAppName)// ---------------------------------------------------------------------------//void		CEuracom::GetKurzwahl(SInt16 iKurzIndex, SInt16 &oAppKurzNo, LStr255 &oAppNummer, LStr255 &oAppName) const{	if(iKurzIndex < 1 || iKurzIndex > ANZ_KW_NR) {		oAppKurzNo = -1;		return;	}	oAppKurzNo = 100 + iKurzIndex - 1;	oAppNummer.Assign((const char*)&mKurz.Kurz.RNr[iKurzIndex - 1].RufNr);	oAppName.Assign((const char*)&mKurz.Kurz.Namen[iKurzIndex - 1]);}// ---------------------------------------------------------------------------//		• SetKurzwahl(SInt16 iKurzIndex, const LStr255 oAppNummer, const LStr255 oAppName)// ---------------------------------------------------------------------------//void		CEuracom::SetKurzwahl(SInt16 iKurzIndex, const LStr255 oAppNummer, const LStr255 oAppName){	if(iKurzIndex < 1 || iKurzIndex > ANZ_KW_NR) return;	LString::CopyPStr(oAppNummer, StringPtr(mKurz.Kurz.RNr[iKurzIndex - 1].RufNr));	PtoCstr(StringPtr(mKurz.Kurz.RNr[iKurzIndex - 1].RufNr));	LString::CopyPStr(oAppName, StringPtr(mKurz.Kurz.Namen[iKurzIndex - 1]));	PtoCstr(StringPtr(mKurz.Kurz.Namen[iKurzIndex - 1]));}// ---------------------------------------------------------------------------//		• GetSperrnummer(SInt16 iIndex, LStr255 &oNummer)// ---------------------------------------------------------------------------//void		CEuracom::GetSperrnummer(SInt16 iIndex, LStr255 &oNummer) const{	if(iIndex < 1 || iIndex > ANZ_SPERR_NR) return;	oNummer.Assign((const char*)&mKurz.NahSperr.Sperrber[iIndex - 1]);}// ---------------------------------------------------------------------------//		• SetSperrnummer(SInt16 iIndex, const LStr255 &oNummer)// ---------------------------------------------------------------------------//void		CEuracom::SetSperrnummer(SInt16 iIndex, const LStr255 &oNummer){	if(iIndex < 1 || iIndex > ANZ_SPERR_NR) return;	LString::CopyPStr(oNummer, StringPtr(mKurz.NahSperr.Sperrber[iIndex - 1]));	PtoCstr(StringPtr(mKurz.NahSperr.Sperrber[iIndex - 1]));}// ---------------------------------------------------------------------------//		• GetNahbereichsnummer(SInt16 iIndex, LStr255 &oNummer)// ---------------------------------------------------------------------------//void		CEuracom::GetNahbereichsnummer(SInt16 iIndex, LStr255 &oNummer) const{	if(iIndex < 1 || iIndex > ANZ_NAH_BER_NR) return;	oNummer.Assign((const char*)&mKurz.NahSperr.Nahber[iIndex - 1]);}// ---------------------------------------------------------------------------//		• SetNahbereichsnummer(SInt16 iIndex, const LStr255 &oNummer)// ---------------------------------------------------------------------------//void		CEuracom::SetNahbereichsnummer(SInt16 iIndex, const LStr255 &oNummer){	if(iIndex < 1 || iIndex > ANZ_NAH_BER_NR) return;	LString::CopyPStr(oNummer, StringPtr(mKurz.NahSperr.Nahber[iIndex - 1]));	PtoCstr(StringPtr(mKurz.NahSperr.Nahber[iIndex - 1]));}// ---------------------------------------------------------------------------//		• GetExtS0()// ---------------------------------------------------------------------------// SInt32		CEuracom::GetExtS0() const{	// Anzahl der externen S0-Port zählen	SInt32	theAnz_extS0Bus = 0;	for(SInt32 i=0; i<=((GetAnlagenTyp(2) > 0) ? 1 : 0); i++) {	// und für alle Ports dieser Anlagen		for(SInt32 k=0; k<=mAnlage.S0[i].AnzPort; k++) {	// und für alle Ports dieser Anlagen			UInt8	thePortDir = mAnlage.S0[i].Port[k].PortTyp & PORT_DIRECTION_FILTER;			if(thePortDir == PORT_DIRECTION_EXTERN) theAnz_extS0Bus++;		}	}	return theAnz_extS0Bus;}// ---------------------------------------------------------------------------//		• GetIntS0()// ---------------------------------------------------------------------------// SInt32		CEuracom::GetIntS0() const{	// Anzahl der internen S0-Port zählen	SInt32	theAnz_intS0Bus = 0;	for(SInt32 i=0; i<=((GetAnlagenTyp(2) > 0) ? 1 : 0); i++) {	// und für alle Ports dieser Anlagen		for(SInt32 k=0; k<=mAnlage.S0[i].AnzPort; k++) {	// und für alle Ports dieser Anlagen			UInt8	thePortDir = mAnlage.S0[i].Port[k].PortTyp & PORT_DIRECTION_FILTER;			if(thePortDir == PORT_DIRECTION_INTERN) theAnz_intS0Bus++;		}	}	return theAnz_intS0Bus;}// ---------------------------------------------------------------------------//		• GetIntS0()// ---------------------------------------------------------------------------// SInt32		CEuracom::GetAB() const{	// bei vernetzten Anlagen hat man 16 ab-Schnittstellen, sonst 8	// zzgl. 2 Türsprechstellen!	return (GetAnlagenTyp(2) > 0) ? ((8 + 2) * 2) : (8 + 2);}// ---------------------------------------------------------------------------//		• GetAnlagenTyp(SInt16 iAnlage) const// ---------------------------------------------------------------------------// Anlagentyp ermitteln, dazu brauchen wir die Anzahl der S0-Ports und// müssen wissen, ob eine Vernetzung definiert ist (dann sind es zwei Anlagen!)SInt32		CEuracom::GetAnlagenTyp(SInt16 iAnlage) const{	if(iAnlage > 1) {#if 1		if(mAnlage.RufNr[0].HauptAnlNahFern == ANL_TYP_A_VERN)	// Anlage A ist Master?			return AT_I180 + mAnlage.S0[1].AnzPort;#else		// Vernetzt sind die Anlagen, wenn mindestens ein Port auf "Vernetzt" steht!		for(SInt32 k=0; k<=mAnlage.S0[0].AnzPort; k++) {	// und für alle Ports dieser Anlagen			if((mAnlage.S0[0].Port[k].PortTyp & PORT_DIRECTION_FILTER) != PORT_DIRECTION_QUER)				continue;			return AT_I180 + mAnlage.S0[1].AnzPort;		}#endif		// keine Unteranlage:		return 0;	} else {		return AT_I180 + mAnlage.S0[0].AnzPort;	}}// ---------------------------------------------------------------------------//		• SetDefault(Boolean iOptionalFlag)// ---------------------------------------------------------------------------// Defaultanlagen Parameter setzenvoid	CEuracom::SetDefault(Boolean iOptionalFlag){	if(iOptionalFlag) {		BlockFill(&mAnlage, 0x00, sizeof(mAnlage));		BlockFill(&mGeb, 0x00, sizeof(mGeb));		mSWVersion = gPrefs->P.DefSoftware;		SetLandesKennung(0L);	} else {		BlockFill(&mKurz, 0x00, sizeof(mKurz));	}	CheckData();}// ---------------------------------------------------------------------------//		• CheckGoodApp(char inApp, Boolean retNull)// ---------------------------------------------------------------------------// Apparat möglich? Nein => Default-Apparat liefernchar		CEuracom::CheckGoodApp(char inApp, Boolean retNull){char	retVal = retNull ? 0 : 0;	// gültiger ab-Apparat?	if(inApp < 21) return retVal;	if(inApp <= 20 + GetAB())		return inApp;	// gültiger S0-Apparat?	if(inApp < 51) return retVal;	if(inApp >= 51 + GetIntS0() * 10) return retVal;	return inApp;}// ---------------------------------------------------------------------------//		• CheckData()// ---------------------------------------------------------------------------// interne Struktur überprüfen und ggf. korrigierenvoid		CEuracom::CheckData(){	if(GetVersion() < 0x100 || GetVersion() > 0x109) {		mSWVersion = 0x107;		mVersion = LStr255(253, 1);	}	if(GetLandesKennung() == 0) {		LStr255		s(250,1);		SetLandesKennung(SInt32(s));	// Default-Ländervorwahl (49)	}	if(GetOrtsKennung() == 0) {		LStr255		s(251,1);		SetOrtsKennung(SInt32(s));	// Default-Ortsvorwahl (040)	}	if(GetCodeNummer() == 0) {		LStr255		s(252,1);		SetCodeNummer(SInt32(s));	// Default-Codezahl (999999)	}}// ---------------------------------------------------------------------------//		• IntelSwap(EinrichtKonfig &ioKonfig)// ---------------------------------------------------------------------------// Die Euracom speichert und kommuniziert mit Settings im Intel-Format////	Die Routine IntelSwap() swappt einen ganzen Settings-Satz//	Dadurch ist außerhalb der Kommunikation bzw. des Dateiformates stets das//	Motorola Format zu nehmen (sprich: nichts besonderes zu beachten!)UInt16			CEuracom::IntelSwap16(UInt16 iWord){	return (iWord >> 8) | (iWord << 8);}void			CEuracom::IntelSwap16R(UInt16 &iWordRef){	iWordRef = IntelSwap16(iWordRef);}UInt32			CEuracom::IntelSwap32(UInt32 iLong){	return (UInt32(IntelSwap16(iLong)) << 16) | IntelSwap16(iLong >> 16);}void			CEuracom::IntelSwap32R(UInt32 &ioLongRef){	ioLongRef = IntelSwap32(ioLongRef);}void			CEuracom::IntelSwap(EinrichtKonfig &ioKonfig){	for(int k=0; k<2; k++) {		for(int j=0; j<3; j++) {			for(int i=0; i<MSN_MAX_ANZ; i++) {				IsdnS0TInZuordType	*theZuordTypePtr = &ioKonfig.S0[k].Port[j].TIn[i];				IntelSwap32R(theZuordTypePtr->ATInZuordnung);				IntelSwap32R(theZuordTypePtr->BTInZuordnung);			}		}		TInBerechtigung	*TInBerPtr = &ioKonfig.TInBer[k];		IntelSwap32R(TInBerPtr->Masterber);		IntelSwap32R(TInBerPtr->Aufschaltsch);		IntelSwap32R(TInBerPtr->Aufschalt);		TInRufvert		*theTInRufVerPtr = &ioKonfig.TInRufVert[k];		IntelSwap32R(theTInRufVerPtr->Aval);		IntelSwap32R(theTInRufVerPtr->BAval);		IntelSwap32R(theTInRufVerPtr->Ava2);		IntelSwap32R(theTInRufVerPtr->BAva2);		IntelSwap32R(theTInRufVerPtr->Tfe1);		IntelSwap32R(theTInRufVerPtr->BTfe1);		IntelSwap32R(theTInRufVerPtr->Tfe2);		IntelSwap32R(theTInRufVerPtr->BTfe2);		IntelSwap32R(theTInRufVerPtr->Rws);		IntelSwap32R(theTInRufVerPtr->BRwr);		IntelSwap32R(theTInRufVerPtr->Zweitwecker1);		IntelSwap32R(theTInRufVerPtr->Zweitwecker2);		TInGebKonf		*TInGebKonfPtr = &ioKonfig.TInGebKonf[k];		IntelSwap32R(TInGebKonfPtr->Pc);		IntelSwap32R(TInGebKonfPtr->Prn);		IntelSwap32R(TInGebKonfPtr->PrnEin);		IntelSwap32R(TInGebKonfPtr->PrnGek);		IntelSwap32R(TInGebKonfPtr->GebToTIn);		SteuerKontakt	*StKonPtr = &ioKonfig.StKon[k];		IntelSwap16R(StKonPtr->StartZeit);		IntelSwap16R(StKonPtr->EndZeit);		IntelSwap16R(StKonPtr->Ask1Zeit);		IntelSwap16R(StKonPtr->Ask2Zeit);	}}// ---------------------------------------------------------------------------//		• IsEuracomData(Handle inH) [static]// ---------------------------------------------------------------------------// Ist das File ein File für die Euracom?Boolean		CEuracom::IsEuracomData(Handle inH){	StHandleLocker	lock(inH);	UInt32			theSize = GetHandleSize(inH);	if(theSize == 2135) {		LStr255	theStr(*inH, 35);		return theStr == "\pDaten Konfigurator EURACOM 18x V1.4";	}	return false;}// ---------------------------------------------------------------------------//		• SetISDNData(Handle inH)// ---------------------------------------------------------------------------// Konfiguration eintragenvoid		CEuracom::SetISDNData(Handle inH){	if(inH == nil) {		SetDefault();	} else {		StHandleLocker	lock(inH);		UInt32			theSize = GetHandleSize(inH);		if(theSize == 2135) {			LStr255	theStr(*inH, 35);			if(theStr == "\pDaten Konfigurator EURACOM 18x V1.4") {				EinrichtKonfig	theAnlage;		// Konfiguration der Anlage				::BlockMoveData(*inH + 36, &theAnlage, sizeof(theAnlage));				IntelSwap(theAnlage);				mAnlage = theAnlage;			}		}	}	CheckData();	ExecuteAttachments(msg_AnlageDirty, nil);}// ---------------------------------------------------------------------------//		• SetISDNData(Handle inH)// ---------------------------------------------------------------------------// Konfiguration zurückgebenHandle		CEuracom::GetISDNData(){	Handle		theH = NewHandleClear(2135);	StHandleLocker	lock(theH);	::BlockMoveData("Daten Konfigurator EURACOM 18x V1.4", *theH, 36);	EinrichtKonfig	theAnlage;		// Konfiguration der Anlage	theAnlage = mAnlage;	IntelSwap(theAnlage);	::BlockMoveData(&theAnlage, *theH + 36, sizeof(theAnlage));	return theH;}// ---------------------------------------------------------------------------//		• SetOptData(Handle inH)// ---------------------------------------------------------------------------//	optionale Konfiguration eintragenvoid		CEuracom::SetOptData(Handle inH){	if(inH == nil) {		SetDefault(true);	} else {		StHandleLocker	lock(inH);		UInt32			theSize = GetHandleSize(inH);		if(theSize == 13060) {			LStr255	theStr(*inH, 19);			if(theStr == "\pKwDaten EURACOM 18x") {				::BlockMoveData(*inH + 20, &mKurz, sizeof(mKurz));			}		}	}	CheckData();	ExecuteAttachments(msg_AnlageDirty, nil);}// ---------------------------------------------------------------------------//		• GetOptData// ---------------------------------------------------------------------------//	optionale Konfiguration zurückgebenHandle		CEuracom::GetOptData(){	Handle		theH = NewHandleClear(13060);	StHandleLocker	lock(theH);	::BlockMoveData("KwDaten EURACOM 18x", *theH, 20);	::BlockMoveData(&mKurz, *theH + 20, sizeof(mKurz));	return theH;}#endif