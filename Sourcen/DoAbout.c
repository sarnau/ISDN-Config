#include "SharewareFlags.h"#if !ELMEG_ONLY#include <UModalDialogs.h>#include <UMemoryMgr.h>#include <LString.h>#include <LTextEditView.h>#include <LWindow.h>#include <PP_Messages.h>#include "CISDNApp.h"void			DoAbout();/*** *	Trap-Abfragefunktionen ***/static inline SInt16		NumToolboxTraps(){	return (NGetTrapAddress(_InitGraf,ToolTrap) == NGetTrapAddress(0xAA6E,ToolTrap)) ?			0x200 : 0x400;}static inline TrapType	GetTrapType(UInt16 theTrap){	return (theTrap & 0x800) ? ToolTrap : OSTrap;}static Boolean		TrapAvailable(UInt16 theTrap){TrapType	fType;	fType = GetTrapType(theTrap);	if (fType == ToolTrap) {		theTrap &= 0x7FF;		if (theTrap >= NumToolboxTraps())	// Trap-Nummer zu groß?			return false;					// dann Fehler!	}	return NGetTrapAddress(theTrap,fType) != NGetTrapAddress(_Unimplemented,ToolTrap);}/*** *	GetGestaltResult() ermittelt den Rückgabewert der Gestalt Funktion. Falls ein *	Fehler auftritt, so wird 0 zurückgegeben. Somit ist diese Funktion nur dann *	brauchbar, wenn kein Fehler auftreten kann (Gegenbeispiel: AUX-Version erfragen) ***/static SInt32		GetGestaltResult(OSType gestaltSelector){SInt32	gestaltResult;	if (Gestalt(gestaltSelector,&gestaltResult) == noErr)		return gestaltResult;	else		return 0;}/*** * ***/static SInt16		GetStringsIndex(ResIDT resid, SInt16 id){StResource		theTempRes('DATA', resid);	FailNIL_(theTempRes);	SInt16	*sh = (SInt16*)*theTempRes;	SInt16	ret = 1;	for(int index = 1; index <= sh[0]; index++) {		if(sh[index] != id) continue;		ret = index;		break;	}	return ret;}/*** *	einen Pascal-String an unsere Stringhandle anhängen ***/static void			AddString(LStr255 theString, Handle destStrH, char *sindex){	Munger(destStrH, 0L, sindex, 2, &theString[1], theString[0]);	**destStrH += theString[0] - 2;}/*** *	eine 32 Bit-Zahl an unsere Stringhandle anhängen ***/static void			AddNumString(SInt32 theNum, Handle destStrH, char *sindex){	AddString(LStr255(theNum), destStrH, sindex);}/*** *	einen 'STR#'-String an unsere Stringhandle anhängen ***/static void			AddIndString(ResIDT strListID, SInt16 index, Handle destStrH, char *sindex){LStr255	theString(strListID, index);	AddString(theString, destStrH, sindex);}/*** *	ein einzelnes Zeichen an unsere Stringhandle anhängen ***/static void			AddChar(char *theChar, Handle destStrH, char *sindex){LStr255		theString = UInt8(*theChar);	AddString(theString, destStrH, sindex);}/*** *	Versionsnummer an unsere Stringhandle anhängen ***/static void			AddVersion(UInt32 version, Handle destStrH, char *sindex){LStr255		vStr;UInt16		subVersion = version;	version >>= 16;	vStr = SInt32(version >> 8);	vStr += "\p.";	vStr += LStr255(SInt32((version & 0xF0) >> 4));	if(version & 0x0F) {		vStr += "\p.";		vStr += LStr255(SInt32(version & 0x0F));	}	char	c;	switch((subVersion >> 8) & 0xFF) {	case 0x20:	// "Development"			c = 'd';			goto found;	case 0x40:	// "Alpha"			c = 'a';			goto found;	case 0x60:	// "Beta"			c = 'b';			goto found;	case 0x80:	// "Final"			if((char)subVersion == 0) break;	// keine Unterversion? => nix ausgeben			c = '-';	found:	vStr += c;			vStr += LStr255(SInt32((char)subVersion));			break;	}	AddString(vStr, destStrH, sindex);	sindex[1]++;}/*** * ***/static Handle	BuildInfoText(){Handle	ret = ::NewHandle(0L);	LStr255		stemp;	char		sindex[2];	Handle		iStrHandle = ::NewHandle(sizeof(Str255));FailNIL_(iStrHandle);	for(int index = 1; index < 12; index++) {		::GetIndString(stemp, 129, index);		::PtrToXHand(stemp, iStrHandle, stemp[0]+1);		*(short*)&sindex = '^0';		switch(index) {		case 1:	// Programmname				break;		case 2:	// Systemversion				{				AddVersion((long)GetGestaltResult(gestaltSystemVersion) << 16, iStrHandle, sindex);				int	j = (*(Intl0Hndl)::GetIntlResource(0))->intl0Vers >> 8;				int	i = GetStringsIndex(128, j);				AddIndString(132, i, iStrHandle, sindex);				if(i == 1) {					*(short*)&sindex = '^0';					AddNumString(j, iStrHandle, sindex);				}				}				break;		case 3:	// Programmcode#if defined(powerc) || defined(__powerc)				AddIndString(129, 18, iStrHandle, sindex);#else				AddIndString(129, 17, iStrHandle, sindex);#endif				break;		case 4:	// Computer				AddIndString(kMachineNameStrID, GetGestaltResult(gestaltMachineType), iStrHandle, sindex);				break;		case 5:	// Seriennummer				goto nextline;		case 6:	// 32-Bit QuickDraw-Version				if(TrapAvailable(_QDExtensions)) {					AddVersion(OffscreenVersion() << 16, iStrHandle, sindex);				} else {					AddIndString(129, 14, iStrHandle, sindex);					while(++sindex[1] < '5')						AddChar("", iStrHandle, sindex);				}				break;		case 7:	// QuickTime-Version				goto nextline;		case 8:	// AppleScript-Version				{				long		resp;				if(::Gestalt(gestaltAppleScriptVersion, &resp) == noErr) {					AddVersion(resp & 0xFFFF0000L, iStrHandle, sindex);				} else {					AddIndString(129, 12, iStrHandle, sindex);					while(++sindex[1] < '5')						AddChar("", iStrHandle, sindex);				}				}				break;		case 9:	// Arbeitsspeicher				AddNumString((TrapAvailable(_OSDispatch)?(long)TempTopMem():(long)TopMem()) >> 10, iStrHandle, sindex);				break;		case 10:// Programmspeicherplatz				AddNumString(((long)LMGetApplLimit() - (long)LMGetApplZone()) >> 10, iStrHandle, sindex);				break;		case 11:// Größter freier Block				long		growBytes;				AddNumString(MaxMem(&growBytes) >> 10, iStrHandle, sindex);				break;		}		long	theOldSize = GetHandleSize(ret);		long	theDeltaSize = GetHandleSize(iStrHandle) - 1;		::SetHandleSize(ret, theOldSize + theDeltaSize + 1);					// Platz für den neuen Text schaffen		::BlockMoveData(*iStrHandle + 1, *ret + theOldSize, theDeltaSize);	// Text anhängen		::BlockMoveData("\r", *ret + theOldSize + theDeltaSize, 1);			// Return anhängen	nextline: {}	}	return ret;}/*** *	“About…” aus dem Drop-Down-Menü wurde angewählt. ***/void			DoAbout(){	StDialogHandler	theHandler(20000, nil);	LWindow		*theDialog = theHandler.GetDialog(); FailNIL_(theDialog);	Handle		theInfoText = BuildInfoText(); FailNIL_(theInfoText);	LTextEditView	*theTextInfoPane = (LTextEditView*)theDialog->FindPaneByID('TInf'); FailNIL_(theTextInfoPane);	theTextInfoPane->SetTextHandle(theInfoText);	::DisposeHandle(theInfoText);	MessageT	hitMessage;	UInt32		theItem = 'Vers';	Boolean		theIdleFlag = false;	Boolean		theDialogIsInvisible = true;	Boolean		theSwitchDone = false;	Rect		viewRect;	GWorldPtr	aboutBoxWindow;	GDHandle	aboutDevice;	do {					// Let DialogHandler process events		if(!theIdleFlag) {			// aktiven Button disablen			LPane	*thePane = (LPane*)theDialog->FindPaneByID('Vers'); FailNIL_(thePane);			LPane	*theInfoPane = (LPane*)theDialog->FindPaneByID('TVer'); FailNIL_(theInfoPane);			if(theItem == 'Vers') {				thePane->Disable();				theInfoPane->Show();			} else {				thePane->Enable();				theInfoPane->Hide();			}			thePane = (LPane*)theDialog->FindPaneByID('Info'); FailNIL_(thePane);			theInfoPane = (LPane*)theDialog->FindPaneByID('TInf'); FailNIL_(theInfoPane);			if(theItem == 'Info') {				thePane->Disable();				theInfoPane->Show();			} else {				thePane->Enable();				theInfoPane->Hide();			}			thePane = (LPane*)theDialog->FindPaneByID('Dank'); FailNIL_(thePane);			theInfoPane = (LPane*)theDialog->FindPaneByID('TDan'); FailNIL_(theInfoPane);			theInfoPane->CalcPortFrameRect(viewRect);			GetGWorld(&aboutBoxWindow, &aboutDevice);			HLockHi((Handle)aboutBoxWindow->portPixMap);			if(theItem == 'Dank') {				thePane->Disable();				theInfoPane->Show();				theInfoPane->DontRefresh(true);				// Nach der Animation nur die ersten Zeilen ausgeben				Handle			theText;				TEHandle		theTE;				StScrpHandle	theStyle;				// Put Text in a TERecord				TextFont(applFont);				TextSize(9);				theTE = TEStyleNew(&viewRect, &viewRect); FailNIL_(theTE);				theText = GetResource('TEXT', 20001); FailNIL_(theText);				theStyle = (StScrpHandle) GetResource('styl', 20001); FailNIL_(theStyle);				HLock(theText);				HidePen();				TEStyleInsert(*theText, GetHandleSize(theText), theStyle, theTE);				ShowPen();				ReleaseResource(theText);				if(theStyle != nil)					ReleaseResource((Handle)theStyle);				TESetAlignment(teCenter, theTE);				TECalText(theTE);				// Determine height of the Text				EraseRect(&viewRect);				// Draw Text inside GWorld				(**theTE).viewRect = viewRect;				(**theTE).destRect = viewRect;				(**theTE).inPort = (GrafPtr)aboutBoxWindow;				TEUpdate(&viewRect, theTE);				TEDispose(theTE);			} else {				thePane->Enable();				theInfoPane->Hide();			}			if(theDialogIsInvisible) {				theDialog->Show();				theDialogIsInvisible = false;			}		}		hitMessage = theHandler.DoDialog();		theIdleFlag = hitMessage == msg_Nothing;		switch(hitMessage) {		case msg_Nothing:						break;		case 'Dank':		case 'Vers':		case 'Info':	theItem = hitMessage;						break;		}	} while(hitMessage != msg_OK);}#endif