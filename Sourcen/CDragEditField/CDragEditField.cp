// ===========================================================================//	CDragEditField.cp//	Written by Edward A. Figarsky//	©1995 Edward A. Figarsky. All rights reserved.//	//	You may use this class in any non-commercial program without//	permission.  The only restriction is that you must credit the//	author in your about box.  For commercial use, please contact//	the author at the email address below.//	//	DESCRIPTION:	This class, which sub-classes LEditField and LDragAndDrop,//					adds Drag and Drop capabilities to editText fields in//					windows and dialogs.//					//					Note: When receiving a drop, the entire item's contents//					are replaced.//				//	Send bug-reports and comments to figarsky@voicenet.com//// ===========================================================================#include "CDragEditField.h"#include <UDrawingState.h>#include <PP_Messages.h>#include <UTETextAction.h>#include <LView.h>bool    CDragEditField::sRegisterClass = PPFactory<CDragEditField>::RegisterClass();// ---------------------------------------------------------------------------//		¥ CDragEditField// ---------------------------------------------------------------------------//	Default Constructor.CDragEditField::CDragEditField()		: LEditField(),		  LDragAndDrop(UQDGlobals::GetCurrentPort(), this){	mHiliteRegion = NewRgn();	mHaveDragAndDrop = LDragAndDrop::DragAndDropIsPresent();}// ---------------------------------------------------------------------------//		¥ CDragEditField(LStream*)// ---------------------------------------------------------------------------//	Construct a CDragEditField from the data in a StreamCDragEditField::CDragEditField(LStream	*inStream)		: LEditField(inStream),		  LDragAndDrop(UQDGlobals::GetCurrentPort(), this){	mHiliteRegion = NewRgn();	mHaveDragAndDrop = LDragAndDrop::DragAndDropIsPresent();}// ---------------------------------------------------------------------------//		¥ CDragEditField(CDragEditField&)// ---------------------------------------------------------------------------//	Copy ConstructorCDragEditField::CDragEditField(const CDragEditField	&inOriginal)		: LEditField(inOriginal),		  LDragAndDrop(UQDGlobals::GetCurrentPort(), this){	mHiliteRegion = NewRgn();	CopyRgn(inOriginal.mHiliteRegion, mHiliteRegion);	mHaveDragAndDrop = inOriginal.mHaveDragAndDrop;}// ---------------------------------------------------------------------------//		¥ ~LEditField// ---------------------------------------------------------------------------//	DestructorCDragEditField::~CDragEditField(){	DisposeRgn(mHiliteRegion);}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Handle standard editing commands.//	mHiliteRegion needs to be updated following a Paste, or an UnDo of a Cut.//	Otherwise, the cursor will not be properly set to an arrowBooleanCDragEditField::ObeyCommand(CommandT	inCommand,						  void*		ioParam){	Boolean		cmdHandled = true;		switch (inCommand)	{		case cmd_ActionCut:		case cmd_ActionPaste:		case cmd_ActionClear:		case cmd_ActionTyping:			cmdHandled = LEditField::ObeyCommand(inCommand, ioParam);			TEGetHiliteRgn(mHiliteRegion, mTextEditH);			break;							default:			cmdHandled = LEditField::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ ClickSelf// ---------------------------------------------------------------------------//	Respond to Click inside a CDragEditField//	 If we're not the current target, copy LEditField's action: select nothing and//	  make this the target.//	 If, on the other hand, we are the current target, check to see if we're//	  dragging the mouse in the mHiliteRegion.  If so, we have a drag.//	 If we didn't do a drag, call LEditField's ClickSelf() to do whatever it does.//	 Lastly, update the mHiliteRegionvoidCDragEditField::ClickSelf(const SMouseDownEvent	&inMouseDown){	Boolean			letDadDoTheClick = TRUE;		if (!IsTarget()) {								// If not the Target, clicking in an  EditField makes it the Target.													// Since TEClick will set a new selection  range, clear the current													// selection range to avoid an ugly flash.		::TESetSelect(0, 0, mTextEditH);		SwitchTarget(this);	}	else	{		if(mHaveDragAndDrop)		{						if (PtInRgn(inMouseDown.whereLocal, mHiliteRegion))		// was wherePort			{				Boolean isDrag = ::WaitMouseMoved(inMouseDown.macEvent.where);								if (isDrag) {					//					// If we leave the window, the drag manager will be changing thePort,					// so we'll make sure thePort remains properly set.					//					letDadDoTheClick = FALSE;			// make sure we don't do normal TextEdit click stuff					mSuperView->FocusDraw();					CreateDragEvent(inMouseDown);					mSuperView->OutOfFocus(nil);				}			}		}	}	if (letDadDoTheClick)		{		LEditField::ClickSelf(inMouseDown);	}	TEGetHiliteRgn(mHiliteRegion, mTextEditH);}		// ---------------------------------------------------------------------------//		¥ AdjustCursorSelf// ---------------------------------------------------------------------------//	Normally, LEditField uses the standard I-Beam cursor.  But...//	We need to provide some visual cue that we're capable of dragging text.//	Therefore://	 If we have drag and drop, we're in the mHiliteRegion, and we are//	  the current target, make the cursor an arrow.//	 In all other cases, set the cursor to an iBeamCursor.//voidCDragEditField::AdjustCursorSelf(	Point inPortPt,	const EventRecord&	/* inMacEvent */){	PortToLocalPoint(inPortPt);		if (mHaveDragAndDrop&& PtInRgn(inPortPt, mHiliteRegion) && IsTarget() )	{		::SetCursor(&UQDGlobals::GetQDGlobals()->arrow);	}	else	{		CursHandle	theCursH = ::GetCursor(iBeamCursor);		if (theCursH != nil)			::SetCursor(*theCursH);	}	}// ---------------------------------------------------------------------------//		¥ CreateDragEvent// ---------------------------------------------------------------------------//	We've detected a mouse down and drag inside of mHiliteRegion.//	Since what we're doing is pretty simple, that's how I decided to keep it.////	Note://	 If you drag to the trash, the behavior is similar to a Cut.//	 Option-dragging is not implemented, but can be done fairly easily.//	 I'm not checking to see if the target is the source.  This allows us to//	  drag a portion of ourselves onto ouselves, thus replacing the entire text//	  with the dragged sub-text.  Not a problem as long as we have Undo.//	 A nice enhancement would be to drag an outline of the text, rather than//	  a plain rectangle.//voidCDragEditField::CreateDragEvent(const SMouseDownEvent &inMouseDown){	// private	short				len = (**mTextEditH).selEnd - (**mTextEditH).selStart;	Handle				theText = ::TEGetText(mTextEditH);	char				str[255];	if (len)						// Make sure we really have something to drag	{		Rect theRect = (*mHiliteRegion)->rgnBBox;		::BlockMoveData(&(*theText)[(**mTextEditH).selStart], str, len);								LDragTask theDragTask(inMouseDown.macEvent, theRect, 1, 'TEXT', str, len, 0L);			HandleTrashDrop(&theDragTask);	}}// ---------------------------------------------------------------------------//		¥ HandleTrashDrop// ---------------------------------------------------------------------------//	Handle the case where the destination is the trash.voidCDragEditField::HandleTrashDrop(LDragTask* inDragTask){	OSErr	theErr;	AEDesc	theDropDestination;		DragReference theDragRef = inDragTask->GetDragReference();	theErr = ::GetDropLocation(theDragRef, &theDropDestination);		if ((!theErr) && (theDropDestination.descriptorType != typeNull))	{				// Was the drag was to the finder?		if (theDropDestination.descriptorType == typeAlias)		{			Boolean	aliasWasChanged;			FSSpec	theDestinationFSSpec;			FSSpec	theTrashFSSpec;			short	theTrashVRefNum;			long	theTrashDirID;			//			// First, build the FSSpec of the destination to which the user dragged			// the object			//			HLock(theDropDestination.dataHandle);			theErr = ::ResolveAlias(	nil,										(AliasHandle) theDropDestination.dataHandle,										&theDestinationFSSpec,										&aliasWasChanged);			HUnlock(theDropDestination.dataHandle);			if (!theErr)			{				//				// Next, find the FSSpec of the system's trash				//				theErr = ::FindFolder(	kOnSystemDisk, kTrashFolderType, kDontCreateFolder,										&theTrashVRefNum, &theTrashDirID);				if (!theErr)				{										theErr = ::FSMakeFSSpec( theTrashVRefNum, theTrashDirID, nil, &theTrashFSSpec);					if (!theErr)					{												//						// If the two FSSpecs are equal, the drag was to the trash..						// And since we're talking about text, all we need to do is a TECut.						//						if ((			theDestinationFSSpec.vRefNum ==	theTrashFSSpec.vRefNum)						&& (			theDestinationFSSpec.parID	 ==	theTrashFSSpec.parID)						&& (EqualString(theDestinationFSSpec.name,		theTrashFSSpec.name, false, true)))						{							PostAction(new LTECutAction(mTextEditH, this, this));						}					}				}			}		}	}}// ---------------------------------------------------------------------------//		¥ ItemIsAcceptable// ---------------------------------------------------------------------------//	We'll accept 'TEXT' items.  Note that this will also work for text clipping files.BooleanCDragEditField::ItemIsAcceptable(DragReference inDragRef, ItemReference inItemRef){	FlavorFlags		theFlags;	Boolean			isOK;		isOK = (GetFlavorFlags(inDragRef, inItemRef, 'TEXT', &theFlags) == noErr);		return isOK;}// ---------------------------------------------------------------------------//		¥ ReceiveDragItem// ---------------------------------------------------------------------------//	The user has dropped a 'TEXT' flavored object on our edit field.//	Currently, we only support full replacement of the text.  No insertions//	are performed.////	We'll use a posted paste action so that it may be unDone.//voidCDragEditField::ReceiveDragItem(	DragReference	inDragRef,	DragAttributes	/* inDragAttrs */,	ItemReference	inItemRef,	Rect			&inItemBounds){#ifdef __MWERKS__	#pragma unused (inItemBounds)#endif	FlavorFlags			theFlags;					// Not really used.		//	// Check to make sure the drag contains a 'TEXT' item.	//	if (GetFlavorFlags(inDragRef, inItemRef, 'TEXT', &theFlags) == noErr)	{		Size				theDataSize;			// How much data there is for us.				::GetFlavorDataSize(inDragRef, inItemRef, 'TEXT', &theDataSize);		if (theDataSize)		{			char				theFlavorData[255];	// Where we will put that data.			Rect				frame;						ThrowIf_(theDataSize > 255);			//			//	Get the actual text we are receiving.			//	Then paste it into ourself.			//			::GetFlavorData(inDragRef, inItemRef, 'TEXT', theFlavorData, &theDataSize, 0L);			LCommander	*oldTarget = LCommander::GetTarget();			FocusDraw();			SwitchTarget(this);			CalcLocalFrameRect(frame);			::InvalRect(&frame);						::TESetSelect(0, 32767, mTextEditH);			::ZeroScrap();			PutScrap(theDataSize, 'TEXT', theFlavorData);			PostAction(new LTEPasteAction(mTextEditH, this, this));			SwitchTarget(oldTarget);		}	}}